# コードの修正をしてください
- スマホ時に上部の右のボタンを纏めるハンバーガーメニューを作りたい
  -- 履歴、PT、情報、続き、背景を纏めてください
  -- HTMLの修正に履歴、PT、情報ボタンを入れないでください。コンテナだけ準備してください。それらはsceneUI.jsで動的に作られています。
  -- jsは別ファイルにしましょう
- 既存のPCで出てきているボタンのスタイルを一切弄らないでください！！
- scenario.html以外にもページは存在しています。scenario.html以外のハンバーガーメニューは続き、背景ボタンを纏めてください

# 最重要指示（厳守してください）
- 防御的プログラミングを一旦忘れてください。貴方はメモリが足りません。ソース量が増えてバグを引き起こします。
- **既存コードのリファクタリングは絶対に禁止します。** 関数名、変数名、基本的な処理フロー、コードスタイルを変更しないでください。
- コメントを変更しないでください。
- 理由は、既存の他のシステムとの連携があり、安易な変更はシステム全体の動作不具合を引き起こすためです。
- 現在は機能追加のみを行うフェーズです。コードの品質改善や効率化は今回のスコープ外とします。
- 指示された機能追加以外の変更は一切行わないでください。

scenario.html
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>one and only - シナリオ</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link rel="stylesheet" href="styles.css" />
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2/dist/purify.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
  </head>

  <body>
    <div class="application-bar">
      <button id="back-to-menu">
        <div class="iconmoon icon-home3"></div>
        戻る
      </button>
      <button id="open-tutorial-list-button">
        <div class="iconmoon icon-book"></div>
        取説
      </button>
      <button id="save-load-button">
        <div class="iconmoon icon-address"></div>
        続き
      </button>
      <button id="change-bg-button">
        <div class="iconmoon icon-picture"></div>
        背景
      </button>
    </div>

    <div class="container">
      <div id="scene-history" class="scene-history" style="display: none">
        <div class="loading">履歴読込中...</div>
      </div>

      <div class="game-section">
        <div id="story" style="margin-bottom: 20px">
          <div class="loading">シーン読込中...</div>
        </div>
        <div id="last-scene-images" style="margin-bottom: 20px; text-align: center"></div>
        <div id="last-scene-added" class="r-flexbox"></div>

        <div id="player-action" style="margin-top: 20px">プレイヤーの行動を入力してください</div>
        <div class="carousel-wrapper">
          <div class="carousel-tabs-scrollable">
            <div class="carousel-tabs">
              <button class="carousel-tab active" data-carousel-target="0">通常</button>
              <button class="carousel-tab" data-carousel-target="1">アイテム</button>
            </div>
          </div>
          <div class="carousel-viewport">
            <div class="carousel-track">
              <div class="carousel-cell" data-cell-index="0">
                <div style="display: flex; margin-bottom: 10px; align-items: center">
                  <label style="display: flex; align-items: center; cursor: pointer">
                    <input type="checkbox" id="auto-generate-candidates-checkbox" style="width: 1.2em; height: 1.2em; margin: 0 10px 0 0" />
                    <span>AIが行動選択肢を作成する</span>
                  </label>
                </div>
                <div style="display: flex; flex-direction: column; gap: 10px">
                  <div id="action-candidates-container"></div>
                  <textarea id="player-input" rows="4" placeholder="プレイヤーの行動を入力..."></textarea>
                  <div class="c-flexbox" style="margin-bottom: 0">
                    <button id="next-scene" class="important">次のシーン</button>
                  </div>
                </div>

                <div class="c-flexbox" style="margin-top: 20px">
                  <!-- ▼ エンディング関連ボタン&モーダル（追加） -->
                  <button id="ending-button" style="display: none">エンディング</button>
                  <button id="clear-ending-button" style="display: none">クリア・エンディング</button>
                </div>
              </div>
              <div class="carousel-cell" data-cell-index="1">
                <div style="display: flex; flex-direction: column; gap: 10px">
                  <p style="font-size: 0.9em; color: #ccc; margin: 0">使用するアイテムを選択してください:</p>
                  <div id="item-chips-container" class="chips-container" style="min-height: 40px">
                    <span style="color: #aaa">(使用可能なアイテムはありません)</span>
                  </div>
                  <div class="c-flexbox" style="margin-bottom: 0">
                    <button id="use-item-button" class="important">選択したアイテムを使用</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <button id="get-card-button" style="display: none; margin-top: 20px">カードを取得する</button>
        <button id="view-all-sections-button" style="margin-top: 20px">全セクションを閲覧する</button>
      </div>
    </div>
    <div id="loading-modal" class="modal">
      <div class="modal-content">
        <p>AIが応答を生成しています...</p>
        <div class="loading" style="width: 50px; height: 50px; border-width: 5px; margin: 10px auto"></div>
        <button id="cancel-request-button">キャンセル(試行)</button>
      </div>
    </div>

    <script type="module" src="js/common.js"></script>
    <script type="module" src="js/multiModal.js"></script>
    <script type="module" src="js/indexedDB.js"></script>
    <script type="module" src="js/geminiApiClient.js"></script>
    <script type="module" src="js/stabilityApiClient.js"></script>
    <script type="module" src="js/background.js"></script>
    <script type="module" src="js/tutorialData.js"></script>
    <script type="module" src="js/tutorialManager.js"></script>
    <script type="module" src="js/universalSaveLoad.js"></script>
    <script type="module" src="js/sceneGlobals.js"></script>
    <script type="module" src="js/carousel.js"></script>
    <script type="module" src="js/sceneManager.js"></script>
    <script type="module" src="js/sceneMain.js"></script>
    <script type="module" src="js/sceneExtras.js"></script>
    <script type="module" src="js/sceneUI.js"></script>
  </body>
</html>
---
common.js
/*******************************************************
 * common.js
 * アプリ全体で使い回す共通関数 (トースト表示など)
 * ★ showToast 関数を export する
 *******************************************************/

/**
 * 簡易トーストメッセージの表示
 * （画面下部中央に表示）
 * @param {string} message 表示するメッセージ
 * @param {string} [type='info'] メッセージタイプ ('info', 'success', 'error') 見た目を変える用
 * ★ export を追加
 */
export function showToast(message, type = 'info') {
    // 既存トーストがあれば削除 (連続表示に対応)
    const oldToast = document.getElementById('toast-message');
    if (oldToast) {
        oldToast.remove();
    }

    // 新規トースト要素を作成
    const toast = document.createElement('div');
    toast.id = 'toast-message';
    toast.textContent = message;
    toast.className = `toast toast-${type}`; // タイプに応じてクラス付与 (CSSでスタイル定義)

    // 基本スタイル設定 (CSSでの定義推奨)
    Object.assign(toast.style, {
        position: 'fixed',
        bottom: '20px',
        left: '50%',
        transform: 'translateX(-50%)',
        padding: '12px 25px',
        borderRadius: '6px',
        fontSize: '0.95rem',
        zIndex: '10000', // 最前面に
        opacity: '0', // 初期透明
        transition: 'opacity 0.4s ease, transform 0.4s ease', // フェードイン/アウト + 上下移動
        fontFamily: 'sans-serif', // フォント指定
        boxShadow: '0 3px 8px rgba(0,0,0,0.2)',
    });

    // タイプ別スタイル (CSSで定義推奨)
    if (type === 'success') {
        toast.style.backgroundColor = 'rgba(76, 175, 80, 0.9)'; // 緑系
        toast.style.color = '#fff';
    } else if (type === 'error') {
        toast.style.backgroundColor = 'rgba(244, 67, 54, 0.9)'; // 赤系
        toast.style.color = '#fff';
    } else {
        // info (デフォルト)
        toast.style.backgroundColor = 'rgba(50, 50, 50, 0.9)'; // ダークグレー系
        toast.style.color = '#fff';
    }

    document.body.appendChild(toast);

    // フェードイン + 少し上に移動するアニメーション
    requestAnimationFrame(() => {
        toast.style.opacity = '1';
        toast.style.transform = 'translateX(-50%) translateY(-10px)'; // 少し上に
    });

    // 3秒後にフェードアウトして削除
    setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateX(-50%) translateY(10px)'; // 少し下に
        // transitionend イベントで要素を削除
        toast.addEventListener(
            'transitionend',
            () => {
                // まだ要素が存在すれば削除 (複数回呼ばれるのを防ぐ)
                if (toast.parentNode) {
                    toast.remove();
                }
            },
            { once: true }
        ); // イベントリスナーを一度だけ実行
    }, 3000); // 3秒後に消える
}

// --- DOMContentLoaded 内の処理 ---
// この部分は common.js がモジュールとして読み込まれた場合でも、
// そのファイルが読み込まれた時点で一度だけ実行されます。
// 特定のページ(index.htmlなど)でのみ実行したい処理は、
// そのページのメインJSファイル(menu.jsなど)に移動するのがより適切かもしれません。
window.addEventListener('DOMContentLoaded', async () => {
    console.log('[Common] DOMContentLoaded event fired.');

    // 「取説」ボタンのクリックイベント (これが common.js にあるのが適切か？)
    // このボタンは index.html にしか無い可能性が高い。
    // menu.js に移すことを検討。
    const tutorialButton = document.getElementById('open-tutorial-list-button');
    if (tutorialButton) {
        // リスナーが既に追加されていないか確認
        if (!tutorialButton.hasAttribute('data-common-listener-added')) {
            tutorialButton.addEventListener('click', () => {
                console.log('[Common] Tutorial button clicked (redirecting).');
                window.location.href = 'tutorialList.html';
            });
            tutorialButton.setAttribute('data-common-listener-added', 'true');
        }
    } else {
        // index.html 以外ではボタンがないので、このログは出る可能性がある
        // console.log("[Common] Tutorial button not found on this page.");
    }
});

// ファイル読み込み完了ログ
console.log('[Common] common.js loaded and showToast function exported.');
---
multiModal.js
// multiModal.js
// 複数同時表示を可能にする簡易サンプル
// ★ 元のスタイルに戻し、ES Modules 形式で export する

// --- クラス定義 (内部で使用) ---
class ModalInstance {
    constructor(options) {
        // ★ デフォルトオプションのマージは元のコードにはなかったので、そのまま受け取る
        this.options = { ...options };
        this.modalBackdrop = null;
        this.modalContainer = null;
        this.isOpen = false;
        // bind 'this' for event listeners
        this.onBackdropClick = this.onBackdropClick.bind(this);
        this.ok = this.ok.bind(this);
        this.cancel = this.cancel.bind(this);
        this.close = this.close.bind(this);
    }

    open() {
        if (this.isOpen) {
            console.warn('[MultiModal] Modal is already open.');
            return;
        }
        // DOM生成 (なければ)
        if (!this.modalBackdrop) {
            this.createDOM(); // 下で定義 (元のコード)
        }
        // オプション反映 (元のコード)
        this.applyAppearanceType(this.options.appearanceType || 'center');
        this.fillContents(); // 下で定義 (元のコード)

        // z-index 管理 (元のコード)
        const baseZ = 9999; // ★ 元のコードの baseZ
        const topZ = baseZ + getOpenedModalCount() * 2; // 元のコードの計算方法
        if (this.modalBackdrop) this.modalBackdrop.style.zIndex = topZ;
        if (this.modalContainer) this.modalContainer.style.zIndex = topZ + 1;

        // 表示 (元のコード)
        if (this.modalBackdrop) this.modalBackdrop.style.display = 'block'; // ★ 元通り block に
        this.isOpen = true;

        // モーダル外クリック (元のコード)
        if (this.options.closeOnOutsideClick && this.modalBackdrop) {
            this.modalBackdrop.addEventListener('click', this.onBackdropClick);
        }
        // 管理用リストに追加 (元のコード)
        addToGlobalModalList(this); // 下で定義
        console.log(`[MultiModal] Modal opened. Total open: ${getOpenedModalCount()}`);

        // onOpen コールバック (元のコード)
        if (typeof this.options.onOpen === 'function') {
            setTimeout(() => {
                try {
                    // ★ 元のコードでは引数を渡していないので、それに合わせる
                    this.options.onOpen();
                } catch (e) {
                    console.error('[MultiModal] Error in onOpen callback:', e);
                }
            }, 0);
        }
    }

    createDOM() {
        // ★ 元のコードの DOM 生成ロジックに戻す
        // バックドロップ
        this.modalBackdrop = document.createElement('div');
        this.modalBackdrop.className = 'mmodal-backdrop'; // CSSクラス名
        Object.assign(this.modalBackdrop.style, {
            position: 'fixed',
            top: '0',
            left: '0',
            width: '100%',
            height: '100%',
            backgroundColor: 'rgba(0, 0, 0, 0.7)', // 半透明の黒
            display: 'none', // 初期非表示
        });

        // コンテナ
        this.modalContainer = document.createElement('div');
        this.modalContainer.className = 'mmodal-container'; // CSSクラス名
        // ★ 元のスタイル設定に戻す
        Object.assign(this.modalContainer.style, {
            position: 'absolute', // backdrop基準
            backgroundColor: 'rgba(0,0,0,0.8)', // 元の背景色
            color: '#fff', // 元の文字色
            padding: '20px', // 元のパディング
            borderRadius: '5px', // 元の角丸
            width: 'calc(100% - 20px)', // ★ 元の幅計算
            boxSizing: 'border-box',
            overflow: 'auto', // ★ 元の overflow 設定
            maxHeight: '100vh', // ★ 元の maxHeight 設定
            // top, left, transform は applyAppearanceType で設定
        });

        // 構造と追加 (元のコード)
        this.modalBackdrop.appendChild(this.modalContainer);
        document.body.appendChild(this.modalBackdrop);
        console.log('[MultiModal] Modal DOM created (original style).');
    }

    applyAppearanceType(type) {
        // ★ 元のコードの AppearanceType ロジック
        if (!this.modalContainer) return;
        const s = this.modalContainer.style;
        // デフォルトスタイルをリセット (念のため)
        s.top = '';
        s.left = '';
        s.transform = '';

        if (type === 'center') {
            s.top = '50%';
            s.left = '50%';
            s.transform = 'translate(-50%, -50%)';
        } else if (type === 'top') {
            s.top = '0'; // ★ 元のコードでは top: 0
            s.left = '50%';
            s.transform = 'translate(-50%, 0)';
        } else {
            // デフォルト (type なし or 不明な type) は center と同じにする
            s.top = '50%';
            s.left = '50%';
            s.transform = 'translate(-50%, -50%)';
        }
        console.log(`[MultiModal] Applied appearance type: ${type || 'center'}`);
    }

    fillContents() {
        // ★ 元のコードの fillContents ロジック
        if (!this.modalContainer) return;
        this.modalContainer.innerHTML = ''; // クリア

        // タイトル (h2)
        if (this.options.title) {
            const h2 = document.createElement('h2'); // 元の h2
            h2.textContent = this.options.title;
            // 元のコードにはスタイル指定がなかったので追加しない
            this.modalContainer.appendChild(h2);
        }

        // 内容 (HTML)
        if (this.options.contentHtml) {
            const contentDiv = document.createElement('div');
            // 元のコードではクラス名指定なし
            // ★ DOMPurify によるサニタイズを追加（セキュリティ推奨）
            if (typeof DOMPurify !== 'undefined') {
                contentDiv.innerHTML = DOMPurify.sanitize(this.options.contentHtml, {
                    USE_PROFILES: { html: true },
                });
            } else {
                console.warn('[MultiModal] DOMPurify not found. Setting potentially unsafe HTML.');
                contentDiv.innerHTML = this.options.contentHtml;
            }
            this.modalContainer.appendChild(contentDiv);
        }

        // 右上閉じるボタン (×)
        if (this.options.showCloseButton !== false) {
            // ★ デフォルト true に変更 (元は指定がある場合のみ)
            const closeBtn = document.createElement('button');
            closeBtn.innerHTML = '&times;';
            closeBtn.setAttribute('aria-label', '閉じる');
            // ★ 元のスタイルに戻す
            Object.assign(closeBtn.style, {
                position: 'absolute',
                top: '10px',
                right: '10px',
                background: 'transparent',
                border: 'none',
                color: '#fff',
                fontSize: '1.2rem', // 元のサイズ
                cursor: 'pointer',
                padding: '0',
                lineHeight: '1', // 微調整
            });
            // closeButtonId オプションが指定されていれば、その値をIDとして設定
            if (this.options.closeButtonId) closeBtn.id = this.options.closeButtonId;
            closeBtn.addEventListener('click', this.cancel); // cancel メソッド呼び出し
            this.modalContainer.appendChild(closeBtn);
        }

        // ボタンエリア (元のコード)
        const buttonArea = document.createElement('div');
        buttonArea.className = 'mmodal-button-area'; // スタイル用クラス
        // ★ 元のスタイルに戻す
        Object.assign(buttonArea.style, {
            display: 'flex',
            justifyContent: 'center', // 元は center
            gap: '10px',
            marginTop: '20px',
        });

        let hasButtons = false;

        // 追加ボタン (元のコード)
        if (Array.isArray(this.options.additionalButtons)) {
            this.options.additionalButtons.forEach((bcfg) => {
                if (!bcfg || !bcfg.label) return;
                const btn = document.createElement('button');
                if (bcfg.id) btn.id = bcfg.id; // ID 設定
                btn.textContent = bcfg.label;
                if (typeof bcfg.onClick === 'function') {
                    // ★ 元のコードではインスタンスを渡していない
                    btn.addEventListener('click', () => {
                        try {
                            bcfg.onClick();
                        } catch (e) {
                            console.error(e);
                        }
                    });
                }
                if (bcfg.color) btn.style.backgroundColor = bcfg.color; // 色指定
                buttonArea.appendChild(btn);
                hasButtons = true;
            });
        }

        // キャンセルボタン (元のコード)
        if (typeof this.options.cancelLabel === 'string') {
            const cancelBtn = document.createElement('button');
            // ★ ID は指定があれば使う
            if (this.options.cancelButtonId) cancelBtn.id = this.options.cancelButtonId;
            cancelBtn.textContent = this.options.cancelLabel;
            cancelBtn.addEventListener('click', this.cancel);
            buttonArea.appendChild(cancelBtn);
            hasButtons = true;
        }

        // OKボタン (元のコード)
        if (typeof this.options.okLabel === 'string') {
            const okBtn = document.createElement('button');
            // ★ ID は指定があれば使う
            if (this.options.okButtonId) okBtn.id = this.options.okButtonId;
            okBtn.textContent = this.options.okLabel;
            if (this.options.okButtonColor)
                okBtn.style.backgroundColor = this.options.okButtonColor; // 色指定
            okBtn.disabled = this.options.okDisabled || false; // 無効状態
            okBtn.addEventListener('click', this.ok);
            buttonArea.appendChild(okBtn);
            hasButtons = true;
        }

        // ボタンがあればエリアを追加
        if (hasButtons) {
            this.modalContainer.appendChild(buttonArea);
        }
    }

    // 背景クリック時の処理 (元のコード)
    onBackdropClick(e) {
        if (e.target === this.modalBackdrop) {
            console.log('[MultiModal] Backdrop clicked, closing via cancel.');
            this.cancel();
        }
    }

    // OKボタン処理 (元のコード)
    ok() {
        console.log('[MultiModal] OK button clicked.');
        let shouldClose = true;
        if (typeof this.options.onOk === 'function') {
            try {
                // ★ 元のコードでは false を返しても閉じない機能はなかったので削除
                this.options.onOk();
            } catch (e) {
                console.error('Error in onOk:', e);
            }
        }
        // if (shouldClose) this.close(); // ★ 元のコードでは onOk 後に必ず close
        this.close(); // onOk の後に必ず閉じる
    }

    // キャンセルボタン処理 (元のコード)
    cancel() {
        console.log('[MultiModal] Cancel logic triggered.');
        if (typeof this.options.onCancel === 'function') {
            try {
                this.options.onCancel();
            } catch (e) {
                console.error('Error in onCancel:', e);
            }
        }
        this.close(); // キャンセル時は必ず閉じる
    }

    // モーダルを閉じる処理 (元のコード + リスナー解除)
    close() {
        if (!this.isOpen) return;
        console.log('[MultiModal] Closing modal.');
        this.isOpen = false;

        // ★ 元のコードのリスナー解除処理
        if (this.options.closeOnOutsideClick && this.modalBackdrop) {
            this.modalBackdrop.removeEventListener('click', this.onBackdropClick);
        }
        // 他にリスナーがあればここで解除

        // ★ 元のコードの DOM 除去処理
        if (this.modalBackdrop && this.modalBackdrop.parentNode) {
            this.modalBackdrop.parentNode.removeChild(this.modalBackdrop);
            this.modalBackdrop = null; // 参照解除
            this.modalContainer = null;
            console.log('[MultiModal] Modal DOM removed immediately.');
        }
        // 管理用リストから除去 (元のコード)
        removeFromGlobalModalList(this); // 下で定義
        console.log(`[MultiModal] Modal closed. Total open: ${getOpenedModalCount()}`);

        // onClose コールバック (★ 元のコードにはなかったが、追加しても良い)
        if (typeof this.options.onClose === 'function') {
            try {
                this.options.onClose(this);
            } catch (e) {
                console.error('Error in onClose:', e);
            }
        }
    }
} // End of ModalInstance class

// --- グローバル管理用ヘルパー (元のコード) ---
const globalModalList = [];
function addToGlobalModalList(modalInstance) {
    globalModalList.push(modalInstance);
}
function removeFromGlobalModalList(modalInstance) {
    const i = globalModalList.indexOf(modalInstance);
    if (i >= 0) {
        globalModalList.splice(i, 1);
    }
}
function getOpenedModalCount() {
    return globalModalList.length;
}

// --- ★ 公開する関数 (元の window.multiModal.open と同じ機能) ---
/**
 * 新しいモーダルを開きます。
 * @param {object} options モーダルの設定オプション (ModalInstance の constructor 参照)
 * @returns {ModalInstance} 生成されたモーダルインスタンス
 */
export function open(options) {
    // ★ export する
    const modalInstance = new ModalInstance(options);
    modalInstance.open();
    return modalInstance; // インスタンスを返す
}

// --- window.multiModal への代入は削除 ---
// window.multiModal = { open };

// --- ファイル読み込み完了ログ ---
console.log('[MultiModal] multiModal.js loaded (original style) and open function exported.');
---
indexedDB.js
/* indexedDB.js */
/* ★ deleteScenarioById 内のカーソル処理と非同期管理を修正 */
/* ★ isFavorite インデックス追加済み、DBバージョン 20 */
/* ★ export を使用、省略なし */

let db = null;

export function initIndexedDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('trpgDB', 22); // ★ Version 20

        request.onupgradeneeded = (event) => {
            console.log('[IndexedDB] onupgradeneeded event triggered.');
            db = event.target.result;
            const tx = event.target.transaction;
            // (各ストア定義 - isFavorite インデックス追加済み)
            if (!db.objectStoreNames.contains('characterData')) {
                db.createObjectStore('characterData', { keyPath: 'id' });
            }
            let scenarioStore;
            if (!db.objectStoreNames.contains('scenarios')) {
                scenarioStore = db.createObjectStore('scenarios', {
                    keyPath: 'scenarioId',
                    autoIncrement: true,
                });
                scenarioStore.createIndex('updatedAt', 'updatedAt', { unique: false });
                scenarioStore.createIndex('isFavorite', 'isFavorite', { unique: false });
            } else {
                if (tx) {
                    scenarioStore = tx.objectStore('scenarios');
                    if (!scenarioStore.indexNames.contains('isFavorite'))
                        scenarioStore.createIndex('isFavorite', 'isFavorite', { unique: false });
                    if (!scenarioStore.indexNames.contains('updatedAt'))
                        scenarioStore.createIndex('updatedAt', 'updatedAt', { unique: false });
                }
            }
            if (!db.objectStoreNames.contains('sceneEntries')) {
                const store = db.createObjectStore('sceneEntries', {
                    keyPath: 'entryId',
                    autoIncrement: true,
                });
                store.createIndex('scenarioId', 'scenarioId', { unique: false });
                try {
                    store.createIndex('content_en', 'content_en');
                } catch (e) {}
            }
            if (!db.objectStoreNames.contains('wizardState')) {
                db.createObjectStore('wizardState', { keyPath: 'id' });
            }
            if (!db.objectStoreNames.contains('parties')) {
                const store = db.createObjectStore('parties', {
                    keyPath: 'partyId',
                    autoIncrement: true,
                });
                store.createIndex('updatedAt', 'updatedAt');
            }
            if (!db.objectStoreNames.contains('bgImages')) {
                db.createObjectStore('bgImages', { keyPath: 'id', autoIncrement: true });
            }
            if (!db.objectStoreNames.contains('sceneSummaries')) {
                const store = db.createObjectStore('sceneSummaries', {
                    keyPath: 'summaryId',
                    autoIncrement: true,
                });
                store.createIndex('chunkIndex', 'chunkIndex');
            }
            if (!db.objectStoreNames.contains('endings')) {
                db.createObjectStore('endings', { keyPath: ['scenarioId', 'type'] });
            }
            if (!db.objectStoreNames.contains('avatarData')) {
                db.createObjectStore('avatarData', { keyPath: 'id' });
            }
            if (!db.objectStoreNames.contains('entities')) {
                const store = db.createObjectStore('entities', {
                    keyPath: 'entityId',
                    autoIncrement: true,
                });
                store.createIndex('scenarioId', 'scenarioId');
            }
            if (!db.objectStoreNames.contains('universalSaves')) {
                db.createObjectStore('universalSaves', { keyPath: 'slotIndex' });
            }
            if (!db.objectStoreNames.contains('modelCache')) {
                db.createObjectStore('modelCache', { keyPath: 'id' });
            }
            console.log('[IndexedDB] onupgradeneeded finished.');
        };
        request.onsuccess = (event) => {
            db = event.target.result;
            console.log(`[IndexedDB] DB opened (v${db.version}).`);
            window.db = db;
            resolve();
        };
        request.onerror = (event) => {
            console.error('[IndexedDB] DB error:', event.target.error);
            reject(event.target.error);
        };
        request.onblocked = () => {
            console.warn('[IndexedDB] DB open blocked.');
            alert('DB更新ブロック。他タブ閉じてリロード要。');
            reject(new Error('DB open blocked'));
        };
    });
}

// --- トランザクションヘルパー ---
function getStore(storeName, mode = 'readonly') {
    if (!window.db) throw new Error('DB not initialized.');
    try {
        const tx = window.db.transaction(storeName, mode);
        tx.onerror = (e) => console.error(`[DB] Tx error on ${storeName}:`, e.target.error);
        return tx.objectStore(storeName);
    } catch (e) {
        console.error(`[DB] Error getting store ${storeName}:`, e);
        throw e;
    }
}

// --- 各ストアアクセス関数 (export 付き、省略なし) ---
export function createNewScenario(wizardData, title = '新シナリオ') {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        try {
            const store = getStore('scenarios', 'readwrite');
            const now = new Date().toISOString();
            const record = {
                title: String(title),
                wizardData: wizardData || {},
                createdAt: now,
                updatedAt: now,
                bookShelfFlag: false,
                hideFromHistoryFlag: false,
                isFavorite: false,
            };
            const req = store.add(record);
            req.onsuccess = (e) => resolve(e.target.result);
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function updateScenario(scenario, noUpdateDateTimeFlag = false) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (!scenario?.scenarioId) return reject(new Error('Invalid scenario'));
        try {
            const store = getStore('scenarios', 'readwrite');
            if (!noUpdateDateTimeFlag) scenario.updatedAt = new Date().toISOString();
            scenario.bookShelfFlag = scenario.bookShelfFlag || false;
            scenario.hideFromHistoryFlag = scenario.hideFromHistoryFlag || false;
            scenario.isFavorite = scenario.isFavorite || false;
            if (scenario.bookShelfFlag && typeof scenario.shelfOrder !== 'number')
                scenario.shelfOrder = Date.now();
            const req = store.put(scenario);
            req.onsuccess = resolve;
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function getScenarioById(scenarioId) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (typeof scenarioId !== 'number') return resolve(null);
        try {
            const store = getStore('scenarios');
            const req = store.get(scenarioId);
            req.onsuccess = (e) => resolve(e.target.result || null);
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function listAllScenarios() {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        try {
            const store = getStore('scenarios');
            const req = store.getAll();
            req.onsuccess = (e) => {
                const res = e.target.result || [];
                res.forEach((s) => {
                    s.bookShelfFlag = s.bookShelfFlag || false;
                    s.hideFromHistoryFlag = s.hideFromHistoryFlag || false;
                    s.isFavorite = s.isFavorite || false;
                });
                res.sort((a, b) => (b.updatedAt || '').localeCompare(a.updatedAt || ''));
                resolve(res);
            };
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}

/**
 * シナリオ削除 (関連データも) (★ イベントハンドラベースに修正 v5)
 * @param {number} scenarioId 削除するシナリオのID
 * @returns {Promise<void>} 削除が成功したら解決される Promise
 */
export function deleteScenarioById(scenarioId) {
    return new Promise((resolve, reject) => {
        if (!window.db) return reject(new Error('DB未初期化'));
        if (typeof scenarioId !== 'number' || isNaN(scenarioId)) {
            return reject(new Error(`不正なシナリオID: ${scenarioId}`));
        }

        const storesToAccess = [
            'scenarios',
            'sceneEntries',
            'entities',
            'endings',
            'universalSaves',
        ];
        let tx;
        console.log(`[IndexedDB] Starting deletion transaction for scenario ${scenarioId}...`);

        try {
            tx = window.db.transaction(storesToAccess, 'readwrite');
            let deleteCount = {
                scenarios: 0,
                sceneEntries: 0,
                entities: 0,
                endings: 0,
                universalSaves: 0,
            };

            // トランザクション全体のイベントハンドラ
            tx.oncomplete = () => {
                console.log(
                    `[IndexedDB] Deletion transaction completed for scenario ${scenarioId}. Counts:`,
                    deleteCount
                );
                resolve();
            };
            tx.onerror = (event) => {
                console.error(
                    `[IndexedDB] Deletion transaction error for scenario ${scenarioId}:`,
                    event.target.error
                );
                reject(event.target.error || new Error('トランザクションエラー'));
            };
            tx.onabort = () => {
                console.warn(
                    `[IndexedDB] Deletion transaction aborted for scenario ${scenarioId}.`
                );
                reject(new Error('トランザクションが中断'));
            };

            // 各ストアオブジェクト取得
            const scenarioStore = tx.objectStore('scenarios');
            const sceneEntriesStore = tx.objectStore('sceneEntries');
            const entitiesStore = tx.objectStore('entities');
            const endingsStore = tx.objectStore('endings');
            const universalSavesStore = tx.objectStore('universalSaves');

            // --- 1) シナリオ本体削除 ---
            const scDeleteReq = scenarioStore.delete(scenarioId);
            scDeleteReq.onsuccess = () => {
                deleteCount.scenarios++;
                console.log(`[DB] scenarios delete request issued for ${scenarioId}`);
            };
            // scDeleteReq.onerror は tx.onerror で捕捉

            // --- 2) SceneEntries 削除 ---
            const seIndex = sceneEntriesStore.index('scenarioId');
            const seCursorReq = seIndex.openCursor(IDBKeyRange.only(scenarioId));
            seCursorReq.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                    const key = cursor.primaryKey;
                    const req = sceneEntriesStore.delete(key); // ★ ストアの delete を使う
                    req.onsuccess = () => {
                        deleteCount.sceneEntries++;
                    };
                    cursor.continue(); // ★ 同期的に continue
                } else {
                    console.log(
                        `[DB] sceneEntries delete requests issued (approx ${deleteCount.sceneEntries}).`
                    );
                }
            };
            // seCursorReq.onerror は tx.onerror で捕捉

            // --- 3) Entities 削除 ---
            const enIndex = entitiesStore.index('scenarioId');
            const enCursorReq = enIndex.openCursor(IDBKeyRange.only(scenarioId));
            enCursorReq.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                    const key = cursor.primaryKey;
                    const req = entitiesStore.delete(key); // ★ ストアの delete
                    req.onsuccess = () => {
                        deleteCount.entities++;
                    };
                    cursor.continue();
                } else {
                    console.log(
                        `[DB] entities delete requests issued (approx ${deleteCount.entities}).`
                    );
                }
            };
            // enCursorReq.onerror は tx.onerror で捕捉

            // --- 4) Endings 削除 ---
            const endingRange = IDBKeyRange.bound([scenarioId, ''], [scenarioId, '\uffff']);
            const edCursorReq = endingsStore.openCursor(endingRange);
            edCursorReq.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                    const key = cursor.primaryKey;
                    const req = endingsStore.delete(key); // ★ ストアの delete
                    req.onsuccess = () => {
                        deleteCount.endings++;
                    };
                    cursor.continue();
                } else {
                    console.log(
                        `[DB] endings delete requests issued (approx ${deleteCount.endings}).`
                    );
                }
            };
            // edCursorReq.onerror は tx.onerror で捕捉

            // --- 5) UniversalSaves クリア ---
            const usCursorReq = universalSavesStore.openCursor();
            usCursorReq.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor) {
                    if (cursor.value?.data?.scenarioId === scenarioId) {
                        const updatedSlot = { ...cursor.value, data: null };
                        // ★ update リクエストを発行
                        const req = cursor.update(updatedSlot);
                        req.onsuccess = () => {
                            deleteCount.universalSaves++;
                        };
                    }
                    cursor.continue(); // ★ update の完了を待たずに continue
                } else {
                    console.log(
                        `[DB] universalSaves update requests issued (approx ${deleteCount.universalSaves}).`
                    );
                }
            };
            // usCursorReq.onerror は tx.onerror で捕捉

            // ★ ここで Promise.all は使わない。トランザクションの完了を待つ。
        } catch (err) {
            // トランザクション開始時などの同期エラー
            console.error(
                `[IndexedDB] Error starting deletion transaction for scenario ${scenarioId}:`,
                err
            );
            reject(err);
            // トランザクションが開始されていれば abort を試みる (オプション)
            if (tx && tx.readyState !== 'done' && typeof tx.abort === 'function') {
                try {
                    tx.abort();
                } catch (abortErr) {}
            }
        }
    });
}

/* --- シーン履歴 (sceneEntries) --- */
export function addSceneEntry(entry) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (!entry?.scenarioId || !entry.type) return reject(new Error('Invalid entry'));
        try {
            const store = getStore('sceneEntries', 'readwrite');
            const req = store.add(entry);
            req.onsuccess = (e) => resolve(e.target.result);
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function updateSceneEntry(entry) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (!entry?.entryId) return reject(new Error('Invalid entry or ID'));
        try {
            const store = getStore('sceneEntries', 'readwrite');
            const req = store.put(entry);
            req.onsuccess = resolve;
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function getSceneEntriesByScenarioId(scenarioId) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (typeof scenarioId !== 'number') return resolve([]);
        try {
            const store = getStore('sceneEntries');
            const idx = store.index('scenarioId');
            const req = idx.getAll(IDBKeyRange.only(scenarioId));
            req.onsuccess = (e) => {
                const res = e.target.result || [];
                res.sort((a, b) => (a.entryId || 0) - (b.entryId || 0));
                resolve(res);
            };
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function deleteSceneEntry(entryId) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (typeof entryId !== 'number') return reject(new Error('Invalid ID'));
        try {
            const store = getStore('sceneEntries', 'readwrite');
            const req = store.delete(entryId);
            req.onsuccess = resolve;
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}

/* --- シーン要約 (sceneSummaries) --- */
export function addSceneSummaryRecord(summaryObj) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (!summaryObj || typeof summaryObj.chunkIndex !== 'number')
            return reject(new Error('Invalid summary obj'));
        try {
            const store = getStore('sceneSummaries', 'readwrite');
            const req = store.add(summaryObj);
            req.onsuccess = (e) => resolve(e.target.result);
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function getSceneSummaryByChunkIndex(chunkIndex) {
    /* (省略なし) */ return new Promise(async (resolve, reject) => {
        if (typeof chunkIndex !== 'number') return resolve(null);
        try {
            const store = getStore('sceneSummaries');
            const idx = store.index('chunkIndex');
            const req = idx.getAll(IDBKeyRange.only(chunkIndex));
            req.onsuccess = (e) => resolve(e.target.result?.[0] || null);
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function updateSceneSummaryRecord(summaryObj) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (!summaryObj?.summaryId) return reject(new Error('Invalid summary or ID'));
        try {
            const store = getStore('sceneSummaries', 'readwrite');
            const req = store.put(summaryObj);
            req.onsuccess = resolve;
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function deleteSceneSummaryByChunkIndex(chunkIndex) {
    /* (省略なし) */ return new Promise(async (resolve, reject) => {
        if (!window.db) return reject(new Error('DB init error'));
        if (typeof chunkIndex !== 'number') return reject(new Error('Invalid index'));
        try {
            const store = getStore('sceneSummaries', 'readwrite');
            const idx = store.index('chunkIndex');
            const keysReq = idx.getAllKeys(IDBKeyRange.only(chunkIndex));
            keysReq.onsuccess = async (e) => {
                const keys = e.target.result || [];
                if (keys.length === 0) {
                    resolve();
                    return;
                }
                try {
                    const proms = keys.map(
                        (k) =>
                            new Promise((res, rej) => {
                                store.delete(k).onsuccess = res;
                            })
                    );
                    await Promise.all(proms);
                    resolve();
                } catch (delErr) {
                    reject(delErr);
                }
            };
            keysReq.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}

/* --- キャラデータ (characterData) --- */
export function saveCharacterDataToIndexedDB(characterDataArray) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (!Array.isArray(characterDataArray)) return reject(new Error('Invalid data type'));
        try {
            const store = getStore('characterData', 'readwrite');
            const record = { id: 'characterData', data: characterDataArray };
            const req = store.put(record);
            req.onsuccess = resolve;
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function loadCharacterDataFromIndexedDB() {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        try {
            const store = getStore('characterData');
            const req = store.get('characterData');
            req.onsuccess = (e) => resolve(e.target.result?.data || []);
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}

/* --- ウィザード状態 (wizardState) --- */
export function saveWizardDataToIndexedDB(wizardData) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (typeof wizardData !== 'object' || wizardData === null)
            return reject(new Error('Invalid data type'));
        try {
            const store = getStore('wizardState', 'readwrite');
            const record = { id: 'wizardData', data: wizardData };
            const req = store.put(record);
            req.onsuccess = resolve;
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function loadWizardDataFromIndexedDB() {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        try {
            const store = getStore('wizardState');
            const req = store.get('wizardData');
            req.onsuccess = (e) => resolve(e.target.result?.data || null);
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}

/* --- パーティ (parties) --- */
export function createParty(name = '新パーティ') {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        try {
            const store = getStore('parties', 'readwrite');
            const now = new Date().toISOString();
            const rec = { name: String(name), createdAt: now, updatedAt: now };
            const req = store.add(rec);
            req.onsuccess = (e) => resolve(e.target.result);
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function getPartyById(partyId) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (typeof partyId !== 'number') return resolve(null);
        try {
            const store = getStore('parties');
            const req = store.get(partyId);
            req.onsuccess = (e) => resolve(e.target.result || null);
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function listAllParties() {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        try {
            const store = getStore('parties');
            const req = store.getAll();
            req.onsuccess = (e) => {
                const list = e.target.result || [];
                list.sort((a, b) => (b.updatedAt || '').localeCompare(a.updatedAt || ''));
                resolve(list);
            };
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function updateParty(party) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (!party?.partyId) return reject(new Error('Invalid party or ID'));
        try {
            const store = getStore('parties', 'readwrite');
            party.updatedAt = new Date().toISOString();
            const req = store.put(party);
            req.onsuccess = resolve;
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function deletePartyById(partyId) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (typeof partyId !== 'number') return reject(new Error('Invalid ID'));
        try {
            const store = getStore('parties', 'readwrite');
            const req = store.delete(partyId);
            req.onsuccess = resolve;
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}

/* --- エンディング (endings) --- */
export function getEnding(scenarioId, type) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (typeof scenarioId !== 'number' || !type) return resolve(null);
        try {
            const store = getStore('endings');
            const req = store.get([scenarioId, type]);
            req.onsuccess = (e) => resolve(e.target.result || null);
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function saveEnding(scenarioId, type, story) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (typeof scenarioId !== 'number' || !type || typeof story !== 'string')
            return reject(new Error('Invalid args'));
        try {
            const store = getStore('endings', 'readwrite');
            const rec = { scenarioId, type, story, createdAt: new Date().toISOString() };
            const req = store.put(rec);
            req.onsuccess = resolve;
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function deleteEnding(scenarioId, type) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (typeof scenarioId !== 'number' || !type) return reject(new Error('Invalid args'));
        try {
            const store = getStore('endings', 'readwrite');
            const req = store.delete([scenarioId, type]);
            req.onsuccess = resolve;
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}

/* --- エンティティ (entities) --- */
export function addEntity(entity) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (!entity?.scenarioId || !entity.category || !entity.name)
            return reject(new Error('Invalid entity'));
        try {
            const store = getStore('entities', 'readwrite');
            const req = store.add(entity);
            req.onsuccess = (e) => resolve(e.target.result);
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function updateEntity(entity) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (!entity?.entityId) return reject(new Error('Invalid entity or ID'));
        try {
            const store = getStore('entities', 'readwrite');
            const req = store.put(entity);
            req.onsuccess = resolve;
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function getEntitiesByScenarioId(scenarioId) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (typeof scenarioId !== 'number') return resolve([]);
        try {
            const store = getStore('entities');
            const idx = store.index('scenarioId');
            const req = idx.getAll(IDBKeyRange.only(scenarioId));
            req.onsuccess = (e) => resolve(e.target.result || []);
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function deleteEntity(entityId) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (typeof entityId !== 'number') return reject(new Error('Invalid ID'));
        try {
            const store = getStore('entities', 'readwrite');
            const req = store.delete(entityId);
            req.onsuccess = resolve;
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}

/* --- 背景画像 (bgImages) --- */
export function addBgImage(dataUrl) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (!dataUrl?.startsWith('data:image')) return reject(new Error('Invalid dataURL'));
        try {
            const store = getStore('bgImages', 'readwrite');
            const rec = { dataUrl, createdAt: new Date().toISOString() };
            const req = store.add(rec);
            req.onsuccess = (e) => resolve(e.target.result);
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function getAllBgImages() {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        try {
            const store = getStore('bgImages');
            const req = store.getAll();
            req.onsuccess = (e) => {
                const res = e.target.result || [];
                res.sort((a, b) => (b.createdAt || '').localeCompare(a.createdAt || ''));
                resolve(res);
            };
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function getBgImageById(id) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (typeof id !== 'number') return resolve(null);
        try {
            const store = getStore('bgImages');
            const req = store.get(id);
            req.onsuccess = (e) => resolve(e.target.result || null);
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function deleteBgImage(id) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (typeof id !== 'number') return reject(new Error('Invalid ID'));
        try {
            const store = getStore('bgImages', 'readwrite');
            const req = store.delete(id);
            req.onsuccess = resolve;
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}

/* --- ユニバーサルセーブ (universalSaves) --- */
export function ensureInitialSlots() {
    /* (省略なし) */ return new Promise(async (resolve, reject) => {
        try {
            const all = await dbListAllSlots();
            if (all.length > 0) {
                resolve();
                return;
            }
            console.log('[DB] Creating initial slots...');
            const proms = [];
            for (let i = 1; i <= 5; i++)
                proms.push(
                    dbPutUniversalSave({
                        slotIndex: i,
                        updatedAt: new Date().toISOString(),
                        data: null,
                    })
                );
            await Promise.all(proms);
            resolve();
        } catch (e) {
            reject(e);
        }
    });
}
export function listAllSlots() {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        try {
            const store = getStore('universalSaves');
            const req = store.getAll();
            req.onsuccess = (e) => {
                const res = e.target.result || [];
                res.sort((a, b) => (a.slotIndex || 0) - (b.slotIndex || 0));
                resolve(res);
            };
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function getUniversalSave(slotIndex) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (typeof slotIndex !== 'number') return resolve(null);
        try {
            const store = getStore('universalSaves');
            const req = store.get(slotIndex);
            req.onsuccess = (e) => resolve(e.target.result || null);
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function putUniversalSave(record) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (!record?.slotIndex) return reject(new Error('Invalid record'));
        try {
            const store = getStore('universalSaves', 'readwrite');
            record.updatedAt = new Date().toISOString();
            const req = store.put(record);
            req.onsuccess = resolve;
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function deleteUniversalSlot(slotIndex) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (typeof slotIndex !== 'number') return reject(new Error('Invalid index'));
        try {
            const store = getStore('universalSaves', 'readwrite');
            const req = store.delete(slotIndex);
            req.onsuccess = resolve;
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}

/* --- モデルキャッシュ (modelCache) - 任意追加 --- */
export function saveModels(models) {
    /* (省略なし - Cache disabled) */ console.warn('[DB] saveModels: Cache disabled.');
    return Promise.resolve();
}
export function loadModels() {
    /* (省略なし - Cache disabled) */ console.warn('[DB] loadModels: Cache disabled.');
    return Promise.resolve(null);
}

/* --- アバターデータ (avatarData) --- */
export function saveAvatarData(avatarObj) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (!avatarObj?.id) return reject(new Error('Invalid avatar'));
        try {
            const store = getStore('avatarData', 'readwrite');
            const req = store.put(avatarObj);
            req.onsuccess = resolve;
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}
export function loadAvatarData(id) {
    /* (省略なし) */ return new Promise((resolve, reject) => {
        if (!id) return resolve(null);
        try {
            const store = getStore('avatarData');
            const req = store.get(id);
            req.onsuccess = (e) => resolve(e.target.result || null);
            req.onerror = (e) => reject(e.target.error);
        } catch (e) {
            reject(e);
        }
    });
}

// --- ファイル読み込み完了ログ ---
console.log('[IndexedDB] indexedDB.js loaded and functions exported.');
window.initIndexedDB = initIndexedDB;---
geminiApiClient.js
// geminiApiClient.js
// Gemini API (テキスト生成、モデルリスト) 専用クライアント
// ★ Constructor で localStorage から API キーを読み込む
// ★ ES Modules 形式、クラスを export
// ★ 省略なし

/**
 * Gemini API (generativelanguage.googleapis.com) との通信を行うクライアントクラス
 * 主にテキスト生成 (:generateContent) とモデルリスト取得 (:listModels) を担当
 */
export class GeminiApiClient {
    #geminiApiKey = null; // プライベートプロパティとしてキーを保持
    #textBaseUrl = 'https://generativelanguage.googleapis.com/v1beta/models/';
    conversationHistory = [];
    #stubMode = false;
    #stubResponses = [
        '市場ですね。活気があります。何を探しましょう？',
        '図書館は静かです。どの棚へ？',
        '怪しい店…猫の声がします。入りますか？',
        '吟遊詩人がいますね。話しかけますか？',
    ];
    #isKeyValid = false; // キーが有効そうか (簡易チェック)

    /**
     * @param {object} [options={}] オプション
     * @param {boolean} [options.stubMode=false] スタブモードを有効にするか
     */
    constructor(options = {}) {
        this.#stubMode = options.stubMode || false; // スタブモード設定
        if (this.#stubMode) {
            console.warn('[GeminiClient] Constructor: Initializing in STUB MODE.');
            this.#isKeyValid = true; // スタブならキー不要だが利用可能扱い
        } else {
            // ★ localStorage から API キーを読み込む
            try {
                const storedKey = localStorage.getItem('geminiApiKey'); // menu.js で保存するキー名
                if (storedKey && storedKey !== 'YOUR_API_KEY' && storedKey.startsWith('AIza')) {
                    // 簡単な形式チェック
                    this.#geminiApiKey = storedKey;
                    this.#isKeyValid = true;
                    console.log(
                        '[GeminiClient] Constructor: Gemini API Key loaded and seems valid.'
                    );
                } else {
                    this.#geminiApiKey = null;
                    this.#isKeyValid = false;
                    if (storedKey) {
                        console.warn(
                            '[GeminiClient] Constructor: Invalid Gemini API Key found in localStorage.'
                        );
                    } else {
                        console.warn(
                            '[GeminiClient] Constructor: Gemini API Key not found in localStorage.'
                        );
                    }
                }
            } catch (e) {
                console.error(
                    '[GeminiClient] Constructor: Error accessing localStorage for API Key:',
                    e
                );
                this.#geminiApiKey = null;
                this.#isKeyValid = false;
            }
        }
        console.log(
            `[GeminiClient] Initialized. Stub Mode: ${this.#stubMode}, Key Set: ${!!this
                .#geminiApiKey}`
        );
    }

    /** API キーが設定されているか (スタブモードでなくてもキーが設定されているか) */
    get hasApiKey() {
        return !!this.#geminiApiKey;
    }

    /** API呼び出しが可能か (スタブモードか、キーが有効そうか) */
    get isAvailable() {
        console.log("API確認か？",this.#isKeyValid);
        // スタブモードが true なら常に利用可能
        // 通常モードなら #isKeyValid が true である必要がある
        return this.#stubMode || this.#isKeyValid;
    }

    /** スタブモードか */
    get isStubMode() {
        return this.#stubMode;
    }

    /** 会話履歴初期化 */
    initializeHistory(initialHistory = []) {
        // (中身は変更なし - 省略せず記述)
        if (
            Array.isArray(initialHistory) &&
            initialHistory.every((item) => item.role && item.parts)
        ) {
            this.conversationHistory = [...initialHistory];
            console.log('[GeminiClient] History initialized:', this.conversationHistory);
        } else {
            this.conversationHistory = [];
            if (initialHistory.length > 0) console.warn('[GeminiClient] Invalid initialHistory.');
            else console.log('[GeminiClient] History initialized (empty).');
        }
    }

    /** 現在の会話履歴を取得 */
    getHistory() {
        return [...this.conversationHistory];
    } // (中身は変更なし)

    /** テキスト生成 (generateContent) */
    /**
     * 選択されたモデルを使用して Gemini API (generateContent) でテキストを生成します。
     * 内部の会話履歴を使用・更新します。
     * ★ systemPrompt 引数を追加
     * @param {string} prompt ユーザーからの最新の入力プロンプト
     * @param {string} modelId 使用するモデルのID
     * @param {string | null} [systemPrompt=null] システムプロンプト (オプション)
     * @returns {Promise<string>} 生成されたテキスト
     * @throws {Error} APIキー/モデルIDがない場合、APIエラーの場合
     */
    async generateContent(prompt, modelId, systemPrompt = null) {
        // ★ systemPrompt 引数追加
        if (!prompt?.trim()) throw new Error('プロンプトが空');

        // ★ システムプロンプトとユーザープロンプトを含む会話履歴を作成
        const currentConversation = [...this.conversationHistory]; // 既存履歴コピー
        currentConversation.push({ role: 'user', parts: [{ text: prompt }] });
        console.log(`[GeminiClient][History User] ${prompt.substring(0, 100)}...`);

        // ★ リクエストボディに含めるコンテンツ
        const requestContents = [...currentConversation];

        // ★ リクエストボディ全体
        const requestBody = {
            contents: requestContents,
            // ★ generationConfig や safetySettings は必要なら追加
        };

        // ★ systemPrompt が指定されていれば、リクエストボディに追加
        //    Gemini API の正しいフィールド名は 'system_instruction' の可能性があります (要確認)
        if (systemPrompt && typeof systemPrompt === 'string') {
            requestBody.system_instruction = { parts: [{ text: systemPrompt }] };
            console.log('[GeminiClient] System prompt provided.');
        }

        // スタブモードまたはキー無効チェック
        if (this.#stubMode) {
            console.log('[GeminiClient][Stub] generateContent: Returning dummy response.');
            const stubText =
                this.#stubResponses[Math.floor(Math.random() * this.#stubResponses.length)];
            this.conversationHistory = currentConversation; // ★ ユーザー入力は履歴に残す
            this.conversationHistory.push({ role: 'model', parts: [{ text: stubText }] }); // スタブ応答も履歴へ
            console.log(`[GeminiClient][History Model Stub] ${stubText}`);
            await new Promise((r) => setTimeout(r, 500));
            return stubText;
        }
        if (!this.isAvailable || !this.#geminiApiKey) {
            if (this.conversationHistory.at(-1)?.role === 'user') this.conversationHistory.pop(); // 失敗時はユーザー入力削除
            throw new Error('Gemini APIキー未設定/無効');
        }
        if (!modelId) throw new Error('モデルID未指定');

        const apiUrl = `${this.#textBaseUrl}${modelId}:generateContent?key=${this.#geminiApiKey}`;
        console.log(`[GeminiClient][Text] POST ${apiUrl}`);
        // console.log("[GeminiClient][Text] Request Body:", JSON.stringify(requestBody, null, 2)); // デバッグ用

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody),
            }); // ★ 修正したボディを使用
            const data = await response.json();
            if (!response.ok) {
                const msg = this.#formatApiError(response.status, data, modelId);
                if (this.conversationHistory.at(-1)?.role === 'user')
                    this.conversationHistory.pop();
                throw new Error(msg);
            }
            console.log('[GeminiClient][Text Response]', data);
            let text = '';
            if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
                text = data.candidates[0].content.parts[0].text;
                if (data.candidates[0].finishReason && data.candidates[0].finishReason !== 'STOP')
                    text += ` (End: ${data.candidates[0].finishReason})`;
                // ★ 成功したので会話履歴を更新
                this.conversationHistory = currentConversation;
                this.conversationHistory.push({ role: 'model', parts: [{ text }] });
                console.log(`[GeminiClient][History Model] ${text.substring(0, 100)}...`);
            } else if (data.promptFeedback?.blockReason) {
                text = `ブロック: ${data.promptFeedback.blockReason}`;
                // ★ ブロックされた場合も履歴は更新する（ユーザー入力は残る）
                this.conversationHistory = currentConversation;
                this.conversationHistory.push({ role: 'model', parts: [{ text }] });
                console.log(`[GeminiClient][History Model Blocked]`);
            } else {
                text = `(空応答: ${data.candidates?.[0]?.finishReason || '不明'})`;
                this.conversationHistory = currentConversation; // ユーザー入力は残す
                this.conversationHistory.push({ role: 'model', parts: [{ text }] });
                console.warn(`[GeminiClient][History Added - Model (Empty)]`, data);
            }
            return text;
        } catch (e) {
            console.error('[GeminiClient][Text] Error:', e);
            if (this.conversationHistory.at(-1)?.role === 'user') this.conversationHistory.pop();
            throw e;
        } // エラー時もユーザー入力削除
    }
    
    /**
     * 利用可能なGeminiモデルリスト取得 (静的メソッド)
     * ★ これは静的メソッドなので、APIキーは引数で受け取る必要がある
     */
    static async listAvailableModels(apiKey) {
        // (中身は変更なし - 省略せず記述)
        if (!apiKey || apiKey === 'YOUR_API_KEY') throw new Error('APIキー未設定');
        const url = `https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}`;
        console.log('[GeminiClient] Fetching models:', url);
        try {
            const r = await fetch(url);
            const d = await r.json();
            if (!r.ok) {
                const m = d?.error?.message || r.statusText;
                throw new Error(`モデルリスト取得エラー (${r.status}): ${m}`);
            }
            console.log('[GeminiClient] Raw models:', d);
            const models = [];
            if (d.models?.length) {
                const info = {
                    'gemini-1.5-pro-latest': { tier: '高性能', description: '...' },
                    'gemini-1.5-flash-latest': { tier: '高速', description: '...' },
                    'gemini-pro': { tier: '標準', description: '...' },
                };
                d.models.forEach((m) => {
                    if (m.supportedGenerationMethods?.includes('generateContent')) {
                        const id = m.name.replace('models/', '');
                        if (
                            id.includes('vision') ||
                            id.includes('embedding') ||
                            id.includes('aqa') ||
                            (/\d{3}$/.test(id) && !id.includes('latest'))
                        ) {
                            console.log(`Skipping: ${id}`);
                            return;
                        }
                        const i = info[id];
                        models.push({
                            id,
                            displayName: m.displayName || id,
                            description: m.description || i?.description || '',
                            tier: i?.tier || null,
                        });
                    }
                });
            }
            if (models.length === 0) console.warn('No suitable text models.');
            models.sort((a, b) => {
                const to = { 高性能: 1, 高速: 2, 標準: 3, null: 99 };
                const tc = (to[a.tier] || 99) - (to[b.tier] || 99);
                if (tc !== 0) return tc;
                return (a.displayName || '').localeCompare(b.displayName || '', 'ja');
            });
            console.log('[GeminiClient] Filtered text models:', models);
            return models;
        } catch (e) {
            console.error('[GeminiClient] モデルリスト読込エラー:', e);
            throw e;
        }
    }

    /** APIエラー整形 */
    #formatApiError(status, errorData, modelId = '') {
        // (中身は変更なし - 省略せず記述)
        const detail = errorData?.error?.message || '不明';
        let msg = `APIエラー (${status})`;
        if (modelId) msg += ` [${modelId}]`;
        msg += `: ${detail}`;
        if (status === 400) {
            if (detail.includes('API key not valid'))
                msg = `APIエラー(${status}): APIキー無効/権限不足`;
            else if (detail.includes('prompt was blocked'))
                msg = `APIエラー(${status}): プロンプトブロック`;
            else if (detail.includes('User location is not supported'))
                msg = `APIエラー(${status}): 地域非対応`;
            else msg = `APIエラー(${status}): リクエスト/入力不正 (${detail})`;
        } else if (status === 403) msg = `APIエラー(${status}): 権限不足 or API無効`;
        else if (status === 404) msg = `APIエラー(${status}): モデル '${modelId}' 未発見/利用不可`;
        else if (status === 429) msg = `APIエラー(${status}): Quota超過`;
        else if (status >= 500) msg = `APIエラー(${status}): Googleサーバーエラー`;
        return msg;
    }
} // End of GeminiApiClient class

console.log('[GeminiClient] geminiApiClient.js loaded (Constructor reads API key).');
---
stabilityApiClient.js
// stabilityApiClient.js
// Stability AI Platform API との通信を行うクライアントクラス
// ★ Constructor で localStorage から API キーを読み込む
// ★ generateImage メソッドから apiKey 引数を削除
// ★ ES Modules 形式、クラスを export
// ★ 省略なし

export class StabilityApiClient {
    #stabilityApiKey = null; // ★ プライベートプロパティでキーを保持
    #baseUrl = 'https://api.stability.ai/v1/generation/';
    #stubMode = false;
    #stubImageResponse =
        'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
    #isKeyValid = false; // ★ キーが有効そうか

    /**
     * @param {object} [options={}] オプション
     * @param {boolean} [options.stubMode=false] スタブモード
     */
    constructor(options = {}) {
        this.#stubMode = options.stubMode || false;
        if (this.#stubMode) {
            console.warn('[StabilityClient] Constructor: Initializing in STUB MODE.');
            this.#isKeyValid = true; // スタブならキー不要だが有効扱い
        } else {
            // ★ localStorage から API キーを読み込む
            try {
                const storedKey = localStorage.getItem('stabilityApiKey'); // menu.js で保存するキー名
                // ★ Stability AI キーの形式チェック (例: 'sk-' で始まるか)
                if (storedKey && storedKey.startsWith('sk-')) {
                    this.#stabilityApiKey = storedKey;
                    this.#isKeyValid = true;
                    console.log(
                        '[StabilityClient] Constructor: Stability AI Key loaded and seems valid.'
                    );
                } else {
                    this.#stabilityApiKey = null;
                    this.#isKeyValid = false;
                    if (storedKey) {
                        console.warn(
                            '[StabilityClient] Constructor: Invalid Stability AI Key found in localStorage.'
                        );
                    } else {
                        console.warn(
                            '[StabilityClient] Constructor: Stability AI Key not found in localStorage.'
                        );
                    }
                }
            } catch (e) {
                console.error(
                    '[StabilityClient] Constructor: Error accessing localStorage for API Key:',
                    e
                );
                this.#stabilityApiKey = null;
                this.#isKeyValid = false;
            }
        }
        console.log(
            `[StabilityClient] Initialized. Stub Mode: ${this.#stubMode}, Key Set: ${!!this
                .#stabilityApiKey}`
        );
    }

    /** API キーが設定されているか */
    get hasApiKey() {
        return !!this.#stabilityApiKey;
    }

    /** API呼び出しが可能か */
    get isAvailable() {
        return this.#stubMode || this.#isKeyValid;
    }

    /** スタブモードか */
    get isStubMode() {
        return this.#stubMode;
    }

    /**
     * Stability AI API を使用してテキストから画像を生成します。
     * ★ apiKey 引数を削除し、内部キーを使用
     * @param {string} prompt 画像生成の指示 (英語)
     * @param {object} [options={}] API オプション
     * @returns {Promise<Array<{imageDataB64: string}>>} 生成画像のBase64データ配列
     * @throws {Error} プロンプトがない場合、APIキーがない/無効な場合、APIエラーの場合
     */
    async generateImage(prompt, options = {}) {
        // ★ apiKey 引数を削除
        if (!prompt?.trim()) throw new Error('[StabilityClient] プロンプトが空');

        // ★ スタブモード or キー無効チェック
        if (this.#stubMode) {
            console.log('[StabilityClient][Stub] Returning dummy image array.');
            await new Promise((resolve) => setTimeout(resolve, 1000));
            return Array(options.samples || 1).fill({ imageDataB64: this.#stubImageResponse });
        }
        if (!this.isAvailable || !this.#stabilityApiKey) {
            // ★ isAvailable と内部キーでチェック
            console.error(
                '[StabilityClient] Cannot generate image: API Key is not valid or not set.'
            );
            throw new Error('Stability AI APIキーが設定されていないか無効です。');
        }

        const engineId = options.engineId || 'stable-diffusion-xl-1024-v1-0';
        const apiUrl = `${this.#baseUrl}${engineId}/text-to-image`;
        console.log(`[StabilityClient] POST ${apiUrl}`);
        console.log(`[StabilityClient] Prompt (EN): "${prompt.substring(0, 100)}..."`, options);

        try {
            // リクエストボディ (変更なし)
            const requestBody = {
                text_prompts: [{ text: prompt, weight: 1.0 }],
                cfg_scale: options.cfg_scale ?? 7,
                height: options.height ?? 1024,
                width: options.width ?? 1024,
                samples: Math.max(1, Math.min(10, options.samples || 1)),
                steps: options.steps ?? 30,
            };
            if (options.style_preset) requestBody.style_preset = options.style_preset;
            if (options.negative_prompt)
                requestBody.text_prompts.push({ text: options.negative_prompt, weight: -1.0 });
            if (options.seed != null) requestBody.seed = options.seed;
            if (options.sampler) requestBody.sampler = options.sampler;

            // API 呼び出し (★ 内部の #stabilityApiKey を使用)
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    Accept: 'application/json',
                    Authorization: `Bearer ${this.#stabilityApiKey}`, // ★ 内部キー使用
                },
                body: JSON.stringify(requestBody),
            });

            const data = await response.json();

            // エラーハンドリング (変更なし)
            if (!response.ok) {
                console.error(`[StabilityClient Error] Status: ${response.status}`, data);
                const id = data?.id || '?';
                const name = data?.name || 'API Error';
                const errs = (data?.errors || ['Unknown']).join(', ');
                if (response.status === 403 && errs.includes('language'))
                    throw new Error(`Stability AI Error (Lang): ${errs}. 要英語プロンプト`);
                if (response.status === 401)
                    throw new Error(`Stability AI Error (401): APIキー無効/認証失敗`);
                throw new Error(`Stability AI Error (${response.status} ${name}/${id}): ${errs}`);
            }

            console.log('[StabilityClient Response]', data);

            // レスポンス処理 (変更なし)
            const generatedImages = [];
            if (data.artifacts?.length) {
                data.artifacts.forEach((a) => {
                    if (a.base64 && a.finishReason === 'SUCCESS')
                        generatedImages.push({ imageDataB64: a.base64 });
                    else {
                        console.warn('Artifact !SUCCESS:', a.finishReason);
                        if (a.finishReason === 'CONTENT_FILTERED')
                            throw new Error('画像生成がコンテンツフィルターによりブロック');
                    }
                });
            }
            if (generatedImages.length === 0) {
                console.error('No successful image artifacts:', data);
                throw new Error('API応答に有効な画像データなし');
            }
            console.log(`[StabilityClient] Generated ${generatedImages.length} image(s).`);
            return generatedImages;
        } catch (error) {
            console.error('[StabilityClient] 画像生成API呼出エラー:', error);
            throw error;
        }
    }
} // End of StabilityApiClient class

console.log('[StabilityClient] stabilityApiClient.js loaded (Constructor reads API key).');
---
background.js
// background.js
// 背景画像の生成と管理
// ★ 画像生成を stabilityClient.generateImage に変更
// ★ プロンプト英語化処理を追加
// ★ ES Modules 形式、依存関数を import
// ★ 省略なし

// --- モジュールインポート ---
import { getBgImageById, getAllBgImages, addBgImage, deleteBgImage } from './indexedDB.js';
import { open as multiModalOpen } from './multiModal.js';
import { showToast } from './common.js';
import { StabilityApiClient } from './stabilityApiClient.js';
import { GeminiApiClient } from './geminiApiClient.js';

// --- モジュールスコープ変数 ---
let currentAvatarData = null;
const PREFERRED_GEMINI_MODEL_LS_KEY = 'preferredGeminiModel';
const gemini = new GeminiApiClient(); // new
const modelId = localStorage.getItem(PREFERRED_GEMINI_MODEL_LS_KEY) || 'gemini-1.5-flash-latest';
const stability = new StabilityApiClient(); // new


// --- モジュールスコープ変数 ---
let currentPageName = 'index';

// --- 関数定義 ---

/**
 * 初期化処理
 */
export async function initBackground(pageName = 'index') {
    currentPageName = pageName;
    console.log(`[Background] Initializing background for page: ${currentPageName}`);
    // (中身は変更なし - 省略せず記述)
    let selectedId = localStorage.getItem('selectedBgId_' + pageName);
    console.log(`[BG] Initial ID: ${selectedId}`);
    if (!selectedId || selectedId === 'null' || selectedId === 'undefined') {
        const fallbackId = localStorage.getItem('selectedBgId_index');
        console.log(`[BG] Fallback ID: ${fallbackId}`);
        if (
            fallbackId &&
            fallbackId !== 'none' &&
            fallbackId !== 'null' &&
            fallbackId !== 'undefined'
        ) {
            selectedId = fallbackId;
        } else {
            selectedId = null;
        }
    }
    if (selectedId) {
        if (selectedId === 'none') {
            console.log('[BG] Applying none');
            document.body.style.backgroundImage = 'none';
        } else {
            const imgId = parseInt(selectedId, 10);
            if (!isNaN(imgId)) {
                console.log(`[BG] Loading ID: ${imgId}`);
                try {
                    const img = await getBgImageById(imgId);
                    if (img?.dataUrl) {
                        console.log(`[BG] Applying ID: ${imgId}`);
                        document.body.style.backgroundImage = `url(${img.dataUrl})`;
                        document.body.style.backgroundSize = 'cover';
                        document.body.style.backgroundAttachment = 'fixed';
                        document.body.style.backgroundPositionX = 'center';
                    } else {
                        console.warn(`[BG] Image ${imgId} not found/invalid.`);
                        localStorage.removeItem('selectedBgId_' + pageName);
                        document.body.style.backgroundImage = '';
                    }
                } catch (e) {
                    console.error(`[BG] Error loading ${imgId}:`, e);
                    showToast(`背景読込失敗 ${imgId}`);
                    document.body.style.backgroundImage = '';
                }
            } else {
                console.warn(`[BG] Invalid ID: ${selectedId}`);
                localStorage.removeItem('selectedBgId_' + pageName);
                document.body.style.backgroundImage = '';
            }
        }
    } else {
        console.log('[BG] No background selected.');
        document.body.style.backgroundImage = '';
    }
    const changeBgBtn = document.getElementById('change-bg-button');
    if (changeBgBtn && !changeBgBtn.hasAttribute('data-bg-listener-added')) {
        changeBgBtn.addEventListener('click', onChangeBgButtonClick);
        changeBgBtn.setAttribute('data-bg-listener-added', 'true');
        console.log('[BG] Listener added.');
    } else if (!changeBgBtn) {
        console.warn('[BG] Button not found.');
    }
}

/**
 * 背景変更ボタンクリック時の処理
 */
export async function onChangeBgButtonClick() {
    console.log('[Background] Change background button clicked.');
    try {
        const all = await getAllBgImages(); // import
        if (all.length === 0) {
            console.log('[Background] No stock. Generating...');
            await generateNewBackground(); // 生成開始 (内部で成功時にモーダル表示)
        } else {
            console.log(`[Background] ${all.length} found. Opening modal.`);
            openBgModal(); // 選択モーダル表示
        }
    } catch (error) {
        console.error('[Background] Error in onChangeBgButtonClick:', error);
        showToast(`エラー: ${error.message}`); // import
    }
}

/**
 * 新規背景画像を Stability AI で生成
 */
export async function generateNewBackground() {
    console.log('[Background] Generating new background using Stability AI...');
    let generatingModal = multiModalOpen({
        // import
        id: 'bg-generating-modal',
        title: '背景画像を生成中',
        contentHtml: `<p>Stability AI API で画像を生成しています...</p><div class="loading"></div>`,
        showCloseButton: false,
        closeOnOutsideClick: false,
    });
    let generationSuccess = false;

    try {
        // ★ クライアントとキーのチェック
        if (!stability) throw new Error('画像生成クライアント未初期化');
        if (!gemini) throw new Error('翻訳用Geminiクライアント未初期化');
        const stabilityApiKey = localStorage.getItem('stabilityApiKey') || '';
        if (!stabilityApiKey) throw new Error('Stability AI APIキー未設定');
        if (stability.isStubMode || gemini.isStubMode) {
            console.warn('[Background] Running generation in STUB MODE.');
            // スタブ処理 (例: ダミー画像URLを返す)
            const dataUrl =
                'data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%22160%22 height=%2290%22><rect width=%22160%22 height=%2290%22 fill=%22%23555%22/><text x=%2280%22 y=%2245%22 font-size=%2210%22 text-anchor=%22middle%22 fill=%22%23fff%22 dy=%22.3em%22>BG STUB</text></svg>';
            const newId = await addBgImage(dataUrl); // import
            document.body.style.backgroundImage = `url(${dataUrl})`; /* ... */
            localStorage.setItem('selectedBgId_' + currentPageName, newId.toString());
            if (currentPageName === 'index') removeAllNoneSettingsExceptIndex();
            showToast('スタブ背景生成'); // import
            generationSuccess = true; // スタブでも成功扱い
            // finally でモーダルを開く
            return; // スタブ処理終了
        }

        // プロンプト準備 (日本語)
        let promptJa = '';
        try {
            if (typeof window.fetchLatestScenarioPrompt === 'function') {
                promptJa = await window.fetchLatestScenarioPrompt(); // グローバル想定
            } else {
                console.warn('fetchLatestScenarioPrompt not found.');
            }
        } catch (e) {
            console.error('Failed fetch prompt:', e);
        }
        if (!promptJa?.trim()) {
            promptJa =
                '美しくて詳細な風景または建築物、ウェブサイトの背景に適した、鮮やかな色、写実的またはアニメスタイル。'; // 日本語デフォルト例
            promptJa =
                '美しくて詳細な風景または建築物、ウェブサイトの背景に適した、鮮やかな色、写実的またはアニメスタイル。'; // 日本語デフォルト例
        }
        console.log(`[Background] Original prompt (JA): "${promptJa}"`);
        let promptEn = ''; // 英語プロンプト用

        // --- プロンプト英語翻訳 (Gemini利用) ---
        if (!modelId) throw new Error('翻訳用Geminiモデル未選択');
        try {
            console.log('[Background] Translating prompt to English...');
            const transPrompt = `Translate the following Japanese scene description into English suitable for an image generation prompt. Focus on visual keywords and atmosphere.\n---\n${promptJa}\n---\nEnglish Prompt:`;
            gemini.initializeHistory([]);
            promptEn = await gemini.generateContent(transPrompt, modelId);
            console.log(`[Background] Translated prompt (EN): "${promptEn}"`);
            if (!promptEn?.trim()) throw new Error('翻訳結果が空');
        } catch (translateError) {
            throw new Error(`プロンプト英語翻訳失敗: ${translateError.message}`);
        }

        // --- Stability AI 呼び出し ---
        const imageOptions = {
            samples: 1,
            // ★ 背景なので横長 (16:9) に近い解像度を指定
            width: 1024,
            height: 1024, // SDXL 1.0 サポート解像度例
            // width: 1536, height: 640, // 別の横長解像度例
            style_preset: 'anime', // 背景に適したスタイル例 (他にも 'photographic', 'fantasy-art' など)
            // negative_prompt: "text, words, people, characters, signature, watermark, blurry" // 不要要素除去
        };
        console.log('[Background] Calling stabilityClient.generateImage:', imageOptions);
        // ★ stabilityClient のメソッド呼び出し
        const imageResults = await stability.generateImage(
            promptEn,
            stabilityApiKey,
            imageOptions
        );
        const base64ImageData = imageResults?.[0]?.imageDataB64;

        if (!base64ImageData) throw new Error('API画像データ取得失敗');
        const dataUrl = 'data:image/png;base64,' + base64ImageData; // PNGと仮定

        // DB保存・適用・localStorage保存
        const newId = await addBgImage(dataUrl); // import
        console.log(`[Background] New background saved (ID: ${newId}). Applying...`);
        document.body.style.backgroundImage = `url(${dataUrl})`;
        document.body.style.backgroundSize = 'cover';
        document.body.style.backgroundAttachment = 'fixed';
        document.body.style.backgroundPositionX = 'center';
        localStorage.setItem('selectedBgId_' + currentPageName, newId.toString());
        if (currentPageName === 'index') removeAllNoneSettingsExceptIndex();
        showToast('新しい背景を生成しました。'); // import
        generationSuccess = true;
    } catch (err) {
        console.error('[Background] 背景生成失敗:', err);
        multiModalOpen({
            // import
            title: '背景生成失敗',
            contentHtml: `<p>画像の生成中にエラー:<br><small>${DOMPurify.sanitize(
                err.message
            )}</small></p>`,
            cancelLabel: '閉じる',
        });
    } finally {
        if (generatingModal && typeof generatingModal.close === 'function') {
            generatingModal.close();
        }
        // ★ 成功した場合のみ選択モーダルを開く
        if (generationSuccess) {
            console.log('[Background] Generation successful. Opening selection modal.');
        } else {
            console.log('[Background] Generation failed. Not opening selection modal.');
        }
    }
}

/**
 * 背景選択モーダルを開く
 */
async function openBgModal() {
    // (中身は変更なし - 省略せず記述)
    console.log('[Background] Opening background selection modal.');
    let allImages = [];
    try {
        allImages = await getAllBgImages();
    } catch (dbError) {
        showToast('背景リスト読込失敗');
    }
    multiModalOpen({
        id: 'bg-select-modal',
        title: '背景選択',
        contentHtml: `<div id="bg-stock-container" class="bg-stock-grid" style="margin-bottom:10px; max-height: 60vh; overflow-y: auto;">${
            allImages.length === 0 ? '<p style="color:#aaa; text-align:center;">ストック空</p>' : ''
        }</div><div class="c-flexbox" style="margin-bottom:10px;"><button id="bg-none-button">背景無し</button><button id="bg-generate-button">新規生成</button></div>`,
        showCloseButton: true,
        appearanceType: 'center',
        closeOnOutsideClick: true,
        cancelLabel: '閉じる',
        onOpen: (modalInstance) => {
            console.log('[BG Modal] Opened. Setting up...');
            const cont = document.getElementById('bg-stock-container'),
                nBtn = document.getElementById('bg-none-button'),
                gBtn = document.getElementById('bg-generate-button');
            if (!cont || !nBtn || !gBtn) {
                console.error('BG Modal elements missing.');
                return;
            }
            nBtn.removeEventListener('click', handleNoneButtonClick);
            nBtn.addEventListener('click', () => handleNoneButtonClick(modalInstance));
            gBtn.removeEventListener('click', handleGenerateButtonClick);
            gBtn.addEventListener('click', handleGenerateButtonClick);
            refreshBgStock(cont, allImages, modalInstance);
            console.log('[BG Modal] Stock rendered.');
        },
    });
}

/** モーダル内の「生成」ボタンハンドラ */
async function handleGenerateButtonClick() {
    // (中身は変更なし - 省略せず記述)
    console.log('[Background] Generate button inside modal clicked.');
    const selectModal = window.multiModal?.getInstanceById?.('bg-select-modal');
    if (selectModal) selectModal.close();
    await generateNewBackground();
}

/** モーダル内の「背景無し」ボタンハンドラ */
function handleNoneButtonClick(modalInstance) {
    // (中身は変更なし - 省略せず記述)
    onBgNoneButton();
    if (modalInstance?.close) modalInstance.close();
    else window.multiModal?.getInstanceById?.('bg-select-modal')?.close();
}

/** 背景一覧を container に再描画 */
async function refreshBgStock(containerEl, imageList = null, modalInstance = null) {
    // (中身は変更なし - 省略せず記述)
    if (!containerEl) return;
    console.log('[BG] Refreshing stock...');
    containerEl.innerHTML = '';
    let all = imageList;
    if (!all) {
        try {
            all = await getAllBgImages();
        } catch (e) {
            showToast('背景再読込失敗');
            all = [];
        }
    }
    if (!all?.length) {
        containerEl.innerHTML = '<p>ストック空</p>';
        return;
    }
    all.forEach((img) => {
        if (!img?.dataUrl) return;
        const wrap = document.createElement('div');
        wrap.className = 'bg-thumb';
        const thumb = document.createElement('img');
        thumb.src = img.dataUrl;
        Object.assign(thumb.style, {
            width: '100%',
            height: '100%',
            objectFit: 'cover',
            display: 'block',
            cursor: 'pointer',
            borderRadius: '4px',
        });
        thumb.alt = `背景 ${img.id}`;
        thumb.loading = 'lazy';
        thumb.addEventListener('click', () => {
            console.log(`Applying BG ${img.id}`);
            document.body.style.backgroundImage = `url(${img.dataUrl})`;
            Object.assign(document.body.style, {
                backgroundSize: 'cover',
                backgroundAttachment: 'fixed',
                backgroundPositionX: 'center',
            });
            localStorage.setItem('selectedBgId_' + currentPageName, String(img.id));
            if (currentPageName === 'index') removeAllNoneSettingsExceptIndex();
            if (modalInstance) modalInstance.close();
        });
        wrap.appendChild(thumb);
        const delBtn = document.createElement('button');
        delBtn.className = 'bg-thumb-delete';
        delBtn.innerHTML = '&times;';
        delBtn.title = '削除';
        delBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            multiModalOpen({
                title: '背景削除確認',
                contentHtml: `<p>削除しますか？<br><img src="${img.dataUrl}" style="max-width:100px;"/></p>`,
                okLabel: '削除',
                okButtonColor: '#f44336',
                onOk: async () => {
                    try {
                        await deleteBgImage(img.id);
                        for (const k of Object.keys(localStorage)) {
                            if (
                                k.startsWith('selectedBgId_') &&
                                localStorage.getItem(k) === String(img.id)
                            )
                                localStorage.removeItem(k);
                        }
                        showToast('背景削除');
                        await refreshBgStock(containerEl, null, modalInstance);
                    } catch (e) {
                        showToast(`削除失敗: ${e.message}`);
                    }
                },
            });
        });
        wrap.appendChild(delBtn);
        containerEl.appendChild(wrap);
    });
    console.log(`Rendered ${all.length} BG images.`);
}

/** 背景無しボタンの処理 */
function onBgNoneButton() {
    // (中身は変更なし - 省略せず記述)
    console.log("[BG] 'None' button clicked.");
    document.body.style.backgroundImage = 'none';
    localStorage.setItem('selectedBgId_' + currentPageName, 'none');
    showToast('背景なし設定');
}

/** indexページで背景設定時、他ページのnone設定削除 */
function removeAllNoneSettingsExceptIndex() {
    // (中身は変更なし - 省略せず記述)
    let removed = 0;
    for (const key of Object.keys(localStorage)) {
        if (key.startsWith('selectedBgId_') && key !== 'selectedBgId_index') {
            if (localStorage.getItem(key) === 'none') {
                localStorage.removeItem(key);
                removed++;
            }
        }
    }
    if (removed > 0) console.log(`Removed ${removed} 'none' settings.`);
}

// --- fetchLatestScenarioPrompt 関数 (仮定義 or import/window) ---
// ★ 実際のコードに合わせてください
async function fetchLatestScenarioPrompt() {
    console.warn('[Background] fetchLatestScenarioPrompt using placeholder implementation.');
    if (typeof window.fetchLatestScenarioPrompt === 'function') {
        return await window.fetchLatestScenarioPrompt();
    }
    return ''; // デフォルト空文字
}

// --- ファイル読み込み完了ログ ---
console.log('[Background] background.js loaded and functions exported.');
---
tutorialData.js
// tutorialData.js

window.tutorialGroups = [
    { id: 'basic', name: '基本編' },
    { id: 'advanced', name: '応用編' },
];

window.tutorials = [
    {
        id: 'apiKeySetup', // IDはそのまま
        title: '各種APIキーを設定しよう', // タイトル変更
        description: 'Gemini APIキーとStability AI APIキーの入手と設定手順を解説します。', // 説明変更
        groupId: 'basic',
        steps: [
            {
                type: 'page',
                match: 'index.html', // index.htmlで実行
                message: 'テキスト生成と画像生成に必要なAPIキーの設定を行いましょう。', // 開始メッセージ
                subSteps: [
                    {
                        // step1: APIキー設定モーダルを開く
                        message: 'まずは「APIキー設定」ボタンを押してください。',
                        highlightSelector: '#set-api-key-button', // 既存のボタンID
                        removeOkButton: true,
                        waitForClickOn: '#set-api-key-button', // このボタンのクリックを待つ
                    },
                    {
                        // step2: Geminiキー取得リンクへ誘導
                        message:
                            'モーダルが開きました。まず、Gemini APIキーを設定します。「Gemini キー取得」リンクをクリックして、キーの取得方法を確認し、キー（AIzaから始まる文字列）をコピーしてください。',
                        // menu.js の href を元にセレクタを指定
                        highlightSelector: 'a[href*="aistudio.google.com/app/apikey"]',
                        // removeOkButton: true, // リンククリックだけなのでOKボタンは表示したままにするか、非表示にするか選択。ここでは表示したままにする
                        // waitForClickOn は設定せず、「次へ」で進める形にする（別タブで開く可能性があるため）
                    },
                    {
                        // step3: Geminiキー入力欄へ誘導
                        message:
                            'Gemini APIキーを取得できたら、下の入力欄に貼り付けてください。',
                        highlightSelector: '#temp-gemini-api-key-input', // menu.js で定義されているID
                    },
                    {
                        // step4: Stabilityキー取得リンクへ誘導
                        message:
                            '次に、Stability AI APIキーを設定します。「Stability AI キー取得」リンクをクリックして、キーの取得方法を確認し、キー（sk-から始まる文字列）をコピーしてください。',
                        // menu.js の href を元にセレクタを指定
                        highlightSelector: 'a[href*="platform.stability.ai/account/keys"]',
                        // removeOkButton: true, // ここも「次へ」で進める
                    },
                    {
                        // step5: Stabilityキー入力欄へ誘導
                        message:
                            'Stability AI APIキーを取得できたら、下の入力欄に貼り付けてください。',
                        highlightSelector: '#temp-stability-api-key-input', // menu.js で定義されているID
                    },
                    {
                        // step6: 保存ボタン（モーダルのOKボタン）へ誘導
                        message: '両方のキーを入力したら、「保存」ボタンを押してください。',
                        // multiModal.js の実装に依存するが、既存のwaitForClickOn の ID を踏襲
                        highlightSelector: '#api-key-save-button', // multiModalの汎用OKボタンIDを想定（要確認）
                        removeOkButton: true, // モーダルのOKボタンを押させるため、チュートリアルの「次へ」は非表示
                        waitForClickOn: '#api-key-save-button', // モーダルのOKボタンのクリックを待つ（要確認）
                    },
                    {
                        // step7: 完了
                        message: '以上で、APIキーの設定は完了です。',
                        complete: true, // チュートリアル完了フラグ
                    },
                ],
            },
        ],
    },
    {
        id: 'story1',
        title: 'メインページのボタン説明',
        description: 'indexページにあるボタンの使い方を順番に説明します。',
        groupId: 'basic',
        steps: [
            {
                type: 'page',
                match: 'index.html',
                message: 'indexページの取説開始',
                subSteps: [
                    {
                        message: '生成ボタン: エレメント生成画面へ移動します。', // ボタン名変更
                        highlightSelector: '#character-create',
                    },
                    {
                        message: 'パーティボタン: 作成したキャラを編成・管理します。',
                        highlightSelector: '#party-list',
                    },
                    {
                        message: '倉庫: 生成したエレメントが収納されています。', // ボタン名変更
                        highlightSelector: '#show-warehouse-btn',
                    },
                    {
                        message: '以上で、ボタン説明を終わります。',
                        complete: true,
                    },
                ],
            },
        ],
    },
    {
        id: 'gachaFlow', // IDはそのまま。実態に合わせて 'elementCreationFlow' などに変更しても良い
        title: 'エレメント生成の流れ', // タイトル変更
        description:
            'トップ画面 から エレメント生成画面 へ進み、生成して倉庫で確認するまでの流れを解説します。', // 説明変更
        groupId: 'basic',
        steps: [
            // 1) index.html
            {
                type: 'page',
                match: 'index.html',
                message: 'エレメント生成の流れを説明します。', // メッセージ変更
                subSteps: [
                    {
                        message: 'まずは「生成」ボタンを押してください。', // メッセージ変更
                        highlightSelector: '#character-create',
                        removeOkButton: true,
                        waitForClickOn: '#character-create',
                    },
                ],
            },
            // 2) characterCreate.html
            {
                type: 'page',
                match: 'characterCreate.html', // このページ名は実際のものに合わせる
                message: 'エレメント生成画面での操作を行いましょう。', // メッセージ変更
                subSteps: [
                    {
                        message: '「エレメント生成」ボタンを押してください。', // ボタン名変更。実際のボタンIDに合わせる必要あり
                        highlightSelector: '#gacha-btn', // このIDは仮。実際の生成ボタンIDに合わせる
                        removeOkButton: true,
                        waitForClickOn: '#gacha-btn', // このIDは仮。実際の生成ボタンIDに合わせる
                    },
                    {
                        message: 'OKボタンを押してください。（生成開始）', // ジャンル設定がない場合はこのステップは不要かも
                        highlightSelector: '#genre-setting-ok-btn', // このIDは仮。
                        removeOkButton: true,
                        waitForClickOn: '#genre-setting-ok-btn', // このIDは仮。
                    },
                    {
                        message:
                            '生成が完了するまでしばらくお待ちください。完了したら次へ進みます。',
                        // 完了待ち。特定の要素が表示されるのを待つなどの処理が必要な場合もある
                    },
                    {
                        message:
                            '生成が確認できたら、戻るボタンを押してindexページへ戻りましょう。',
                        highlightSelector: '#back-to-menu', // 戻るボタンのID
                        removeOkButton: true,
                        waitForClickOn: '#back-to-menu', // 戻るボタンのID
                    },
                ],
            },
            // 3) 再び index.html に戻って倉庫へ
            {
                type: 'page',
                match: 'index.html',
                message: '生成したエレメントを倉庫で確認しましょう。', // メッセージ変更
                subSteps: [
                    {
                        message: '「倉庫」ボタンを押して、今生成したエレメントを確認してください。', // メッセージ変更
                        highlightSelector: '#show-warehouse-btn',
                        removeOkButton: true,
                        waitForClickOn: '#show-warehouse-btn',
                    },
                    {
                        message:
                            '倉庫の説明は後ほどするとして、生成したエレメントが表示されていると思います。', // メッセージ変更
                    },
                    {
                        message: '最後に「×」ボタンを押して倉庫を閉じましょう。',
                        highlightSelector: '#close-warehouse-btn', // 倉庫を閉じるボタンのID (要確認)
                        removeOkButton: true,
                        waitForClickOn: '#close-warehouse-btn', // 倉庫を閉じるボタンのID (要確認)
                    },
                    {
                        message: 'これでエレメント生成の説明は以上です。', // メッセージ変更
                        complete: true,
                    },
                ],
            },
        ],
    },
    {
        id: 'story3',
        title: '高度な倉庫管理',
        description: '倉庫画面でのソートやフィルタリング、選択モードなど高度な機能を紹介します。',
        groupId: 'advanced',
        steps: [
            {
                type: 'page',
                match: 'index.html',
                message: '倉庫管理の使い方を説明します。',
                subSteps: [
                    {
                        message: 'まずは「倉庫」ボタンを押して、倉庫画面を開きましょう。',
                        highlightSelector: '#show-warehouse-btn',
                        removeOkButton: true,
                        waitForClickOn: '#show-warehouse-btn',
                    },
                    {
                        message: 'これが倉庫画面です。',
                    },
                    {
                        message:
                            '画面上のタブをクリックすると、種類ごとにエレメントを絞り込めます。試しに切り替えてみましょう。', // 文言修正
                        highlightSelector: '.warehouse-tabs', // タブ全体のクラスを想定 (要確認)
                    },
                    {
                        message: '右上のドロップダウンから、名前順や日時順などのソートを選べます。',
                        highlightSelector: '#warehouse-sort-dropdown', // ソートドロップダウンのID (要確認)
                    },
                    {
                        message: 'ソート方向ボタンを押すと、昇順/降順を切り替えられます。',
                        highlightSelector: '#warehouse-sort-direction-btn', // ソート方向ボタンのID (要確認)
                    },
                    {
                        message:
                            '複数のエレメントを一括操作したい場合は「選択モード」を使いましょう。選択モードをオンにするとエレメントを複数同時選択ができます。まとめて削除できます。', // 文言修正
                        highlightSelector: '#toggle-warehouse-selection-mode-btn', // 選択モード切替ボタンのID (要確認)
                    },
                    {
                        message:
                            'エレメントをクリックすると、赤い枠が付きます。左上の選択したエレメントを削除ボタンを押すことで、削除が可能になります。', // 文言修正
                        // highlightSelector は特定のボタンを指すIDに変更した方が良いかもしれない (#delete-selected-warehouse-items-btn など)
                    },
                    {
                        message:
                            '最後に、右上の「×」(倉庫を閉じるボタン)を押して倉庫を閉じましょう。',
                        highlightSelector: '#close-warehouse-btn', // 閉じるボタンID (要確認)
                        removeOkButton: true,
                        waitForClickOn: '#close-warehouse-btn', // 閉じるボタンID (要確認)
                    },
                    {
                        message: '以上で、倉庫画面の高度な管理機能の説明は終わりです。',
                        complete: true,
                    },
                ],
            },
        ],
    },
    {
        id: 'createAvatar',
        title: 'あなたの分身を作成しよう',
        description: '自分だけのアバターを作成するチュートリアルです。',
        groupId: 'basic',
        steps: [
            {
                type: 'page',
                match: 'index.html',
                message: '「あなたの分身」機能の使い方を学びましょう。',
                subSteps: [
                    {
                        message: 'まずは「あなたの分身」ボタンを押してください。',
                        highlightSelector: '#you-avatar-btn',
                        removeOkButton: true,
                        waitForClickOn: '#you-avatar-btn',
                    },
                    {
                        message: '入力画面が開きました。まずは名前を入力しましょう。',
                        highlightSelector: '#avatar-name', // アバター名入力欄ID (要確認)
                    },
                    {
                        message: '性別を選択してください。',
                        highlightSelector: '#avatar-gender-chips', // 性別選択UIのID (要確認)
                    },
                    {
                        message: '特技を入力しましょう。',
                        highlightSelector: '#avatar-skill', // 特技入力欄ID (要確認)
                    },
                    {
                        message: '続いてカードのセリフを入力してください。',
                        highlightSelector: '#avatar-serif', // セリフ入力欄ID (要確認)
                    },
                    {
                        message: 'レア度を選択しましょう。',
                        highlightSelector: '#avatar-rarity-chips', // レア度選択UIのID (要確認)
                    },
                    {
                        message:
                            '画像生成ボタンを押してみましょう。（押下後は完了までしばらくお待ちください）',
                        highlightSelector: '.gen-image-btn', // 画像生成ボタンのクラスまたはID (要確認)
                        // removeOkButton: true, // 押下後に待機させるならtrue
                        // waitForClickOn: '.gen-image-btn' // 押下後に待機させるなら設定
                    },
                    {
                        message: '画像生成が完了するまで待ちます。', // 生成待ちステップ
                        // ここで特定の要素の出現や状態変化を待つロジックが必要な場合がある
                    },
                    {
                        message: '最後に、保存ボタンを押しましょう。',
                        highlightSelector: '#avatar-save-btn', // 保存ボタンID (要確認)
                        removeOkButton: true, // 保存ボタンを押させる
                        waitForClickOn: '#avatar-save-btn', // 保存ボタンのクリックを待つ
                    },
                    {
                        message: '以上でアバターが完成です！',
                        complete: true,
                    },
                ],
            },
        ],
    },
    {
        id: 'scenarioCreation',
        title: 'シナリオの作成と進行',
        description:
            'トップ画面 → シナリオウィザード → シナリオ画面 の流れで新しいシナリオを作成・進行します。',
        groupId: 'basic',
        steps: [
            // ---------- index.html ----------
            {
                type: 'page',
                match: 'index.html',
                message: 'シナリオの作成と進行：まずは index.html での操作です。',
                subSteps: [
                    {
                        message: '「新しいシナリオを始める」ボタンを押してください。',
                        highlightSelector: '#start-new-scenario-button',
                        removeOkButton: true,
                        waitForClickOn: '#start-new-scenario-button',
                    },
                ],
            },
            // ---------- scenarioWizard.html ----------
            {
                type: 'page',
                match: 'scenarioWizard.html', // ページ名確認
                message: '次にウィザード画面で操作を行います。',
                subSteps: [
                    {
                        message: 'あなたの分身（パーティ）を選んでください。',
                        highlightSelector: '#wizard-party-list', // パーティ選択UIのID (要確認)
                    },
                    {
                        message: '選び終えたら「次へ」ボタンを押しましょう。',
                        highlightSelector: '#go-wizard-step1-btn', // 次へボタンID (要確認)
                        removeOkButton: true,
                        waitForClickOn: '#go-wizard-step1-btn', // 次へボタンID (要確認)
                    },
                    {
                        message: 'ジャンル選択チップで「自由入力」を選択してください。',
                        highlightSelector: '#choice-free', // 自由入力選択肢ID (要確認)
                    },
                    {
                        message:
                            '自由入力ジャンルテキストボックスに「ミステリー」と入力しましょう。',
                        highlightSelector: '#free-genre-input', // 自由入力欄ID (要確認)
                    },
                    {
                        message: '「次へ」ボタンを押します。',
                        highlightSelector: '#go-step2-btn', // 次へボタンID (要確認)
                        removeOkButton: true,
                        waitForClickOn: '#go-step2-btn', // 次へボタンID (要確認)
                    },
                    {
                        message: '「目標達成型（目的達成型）」ボタンを押しましょう。',
                        highlightSelector: '#type-objective-btn', // 目標達成型ボタンID (要確認)
                    },
                    {
                        message: 'OKを押下し、キャンセルは押さずにしばらく待ちます。',
                        highlightSelector: '#confirm-scenario-ok', // 確認モーダルのOKボタンID (要確認)
                        removeOkButton: true,
                        waitForClickOn: '#confirm-scenario-ok', // 確認モーダルのOKボタンID (要確認)
                    },
                    {
                        message: '処理が終わり、シナリオ要約が表示されたら次へ進みます。',
                        // 特定要素の表示待ちなどが必要な場合がある
                    },
                    {
                        message: '「このシナリオで始める」ボタンを押してください。',
                        highlightSelector: '#start-scenario-button', // シナリオ開始ボタンID (要確認)
                        removeOkButton: true,
                        waitForClickOn: '#start-scenario-button', // シナリオ開始ボタンID (要確認)
                    },
                ],
            },
            // ---------- scenario.html ----------
            {
                type: 'page',
                match: 'scenario.html', // ページ名確認
                message: '新しく作成されたシナリオを進行させてみましょう。',
                subSteps: [
                    {
                        message:
                            '画面最下部までスクロールし、行動テキストボックスで「自己紹介」と入力してください。',
                        highlightSelector: '#player-input', // プレイヤー入力欄ID (要確認)
                    },
                    {
                        message:
                            '次のシーンボタンを押してください。キャンセルは押さず、完了を待ちます。',
                        highlightSelector: '#next-scene', // 次のシーンボタンID (要確認)
                        removeOkButton: true,
                        waitForClickOn: '#next-scene', // 次のシーンボタンID (要確認)
                    },
                    {
                        message: '次のシーンが表示されたら次へ進みます。',
                        // シーン表示待ち
                    },
                    {
                        message:
                            'これでシナリオの進行例は完了です。左上のホームボタンからトップページに戻れます。', // メッセージ変更
                        highlightSelector: '#back-to-menu', // ホームボタンID (要確認)
                    },
                    // { // このステップは index.html に戻った後の話なので、ここでは不要
                    //     message:
                    //         '進行中のシナリオ一覧の一番上の「続きへ」ボタンから、先ほど作成したシナリオにアクセスできます。',
                    // },
                    {
                        message: '以上がシナリオの作成と進行でした。ホームボタンを押してトップに戻ってください。', // メッセージ変更
                        complete: true,
                    },
                ],
            },
        ],
    },
];---
tutorialManager.js
// tutorialManager.js
(function () {
    // -------------------------------------------
    // A) スコープ内変数
    // -------------------------------------------
    let overlayEl = null;
    let dialogEl = null;
    let modalCheckInterval = null;

    // -------------------------------------------
    // B) DOMContentLoaded 後に開始
    // -------------------------------------------
    document.addEventListener('DOMContentLoaded', async () => {
        createBaseElements(); // オーバーレイ & ダイアログを生成 or 再利用
        await runTutorials(); // チュートリアル全体の開始
    });

    // -------------------------------------------
    // C) ベース要素生成
    // -------------------------------------------
    function createBaseElements() {
        // 既に存在すれば使い回し
        overlayEl = document.getElementById('tutorial-overlay');
        dialogEl = document.getElementById('tutorial-dialog');
        if (overlayEl && dialogEl) return;

        // (1) オーバーレイ
        overlayEl = document.createElement('div');
        overlayEl.id = 'tutorial-overlay';
        overlayEl.classList.add('tutorial-overlay');
        // pointer-events: none; にして、下の要素操作を許可
        overlayEl.style.pointerEvents = 'none';
        document.body.appendChild(overlayEl);

        // (2) ダイアログ
        dialogEl = document.createElement('div');
        dialogEl.id = 'tutorial-dialog';
        dialogEl.classList.add('tutorial-dialog');
        // ダイアログ上は pointer-events: auto; でクリック可
        dialogEl.style.pointerEvents = 'auto';
        document.body.appendChild(dialogEl);
    }

    // -------------------------------------------
    // D) チュートリアル全体の起動
    // -------------------------------------------
    async function runTutorials() {
        if (!window.tutorials || !Array.isArray(window.tutorials)) {
            console.warn('No tutorials found.');
            return;
        }

        // URLパラメータに forceTutorial があれば強制実行
        const forcedTutorialId = getQueryParam('forceTutorial');
        if (forcedTutorialId) {
            const target = window.tutorials.find((t) => t.id === forcedTutorialId);
            if (target) {
                // 強制実行時は、ページマッチングは runTutorialIfMatchPage 内で行われる
                await runTutorialIfMatchPage(target);
            } else {
                console.warn(`Forced tutorial with id "${forcedTutorialId}" not found.`);
            }
            return; // 強制実行時はここで処理終了
        }

        // 通常実行: tutorialData.js の定義順に未完了のチュートリアルを探す
        // window.tutorials を定義順にそのままループする
        for (const story of window.tutorials) {
            const isCompleted = localStorage.getItem('completeStory_' + story.id) === 'true';
            if (!isCompleted) {
                // 未完了のチュートリアルが見つかった
                // このチュートリアルが現在のページにマッチするステップを持っているか確認し、持っていれば実行
                await runTutorialIfMatchPage(story);
                // 1つ実行したらループを抜ける（一度に複数のチュートリアルを開始しない）
                break;
            }
        }
    }

    // runTutorialIfMatchPage は、渡された story が現在のページにマッチするかどうかを
    // チェックする役割なので、変更は不要です。
    async function runTutorialIfMatchPage(story) {
        const currentPage = getCurrentPageName();
        // このストーリーに現在ページ用の step があるか？
        const hasStepForPage = story.steps.some(
            (step) => step.type === 'page' && step.match === currentPage
        );
        if (hasStepForPage) {
            // 現在のページにマッチするステップがあればチュートリアルを開始
            await startTutorialSteps(story);
        }
        // マッチしない場合は何もしない（次のチュートリアルに進むか、ループが終了する）
    }

    // -------------------------------------------
    // E) チュートリアルステップ開始
    // -------------------------------------------
    async function startTutorialSteps(story) {
        const currentPage = getCurrentPageName();

        // 1) このページに該当する step 一覧を抽出 (複数あり得る)
        const allPageSteps = story.steps.filter(
            (s) => s.type === 'page' && s.match === currentPage
        );
        if (!allPageSteps.length) return;

        // 2) story 全体の "page" step の順序リスト
        const pageSteps = story.steps.filter((s) => s.type === 'page');

        // 3) 今のページ上にある step を「前ステップが完了しているか/自分が未完了か」を確認しながら順に実行
        for (const st of allPageSteps) {
            // (a) すでにこの step が完了済みならスキップ
            if (isPageStepDone(story.id, st)) {
                console.log(`[Tutorial] This page-step is already done:`, st);
                continue;
            }

            // (b) 前のpage-stepがある場合、その完了フラグをチェック
            const idx = pageSteps.indexOf(st);
            if (idx > 0) {
                const prevStep = pageSteps[idx - 1];
                if (!isPageStepDone(story.id, prevStep)) {
                    // 前stepがまだ終わっていない → このstepは実行不可
                    console.log(
                        `[Tutorial] The previous page-step (index:${idx - 1
                        }) is not done yet. Stop here.`
                    );
                    return; // ここで終了（後続stepも実行しない）
                }
            }

            // (c) subSteps実行
            console.log(`[Tutorial] start subSteps for page-step index:${idx}`);
            const subSteps = st.subSteps || [];
            if (!subSteps.length) {
                // 単発表示
                const r = await showDialog(story.title, st.message, null, '1/1');
                if (r.skipCheck || r.ok) {
                    markPageStepDone(story, st);
                }
            } else {
                // 複数 subSteps
                let subStepCanceled = false;
                let stepCounter;

                for (let i = 0; i < subSteps.length; i++) {
                    const sub = subSteps[i];
                    // i番目のサブステップなので (i+1)/(全サブステップ数) を渡す
                    stepCounter = `${i + 1}/${subSteps.length}`;

                    const r = await showDialog(story.title, sub.message, sub, stepCounter);
                    if (r.skipCheck) {
                        // 「次は表示しない」→ チュートリアル全体完了に
                        localStorage.setItem('completeStory_' + story.id, 'true');
                        return;
                    }
                    if (!r.ok) {
                        // キャンセル → 中断
                        subStepCanceled = true;
                        break;
                    }
                }
                if (!subStepCanceled) {
                    // subSteps全部クリア → page-step完了
                    markPageStepDone(story, st);
                }
            }
        }
    }

    // -------------------------------------------
    // F) page-stepの完了フラグ管理
    // -------------------------------------------
    function isPageStepDone(storyId, step) {
        const stepIndex = getPageStepIndex(storyId, step);
        if (stepIndex < 0) return false; // stepが見つからない
        const key = `pageStepDone_${storyId}_${stepIndex}`;
        return localStorage.getItem(key) === 'true';
    }

    function markPageStepDone(story, step) {
        const stepIndex = getPageStepIndex(story.id, step);
        if (stepIndex < 0) return;
        // 今のpage-step完了
        localStorage.setItem(`pageStepDone_${story.id}_${stepIndex}`, 'true');

        // もしこれが story.steps のうち最後のtype===page だったら → 全体完了
        const pageSteps = story.steps.filter((s) => s.type === 'page');
        const currentIdx = pageSteps.indexOf(step);
        if (currentIdx === pageSteps.length - 1) {
            localStorage.setItem(`completeStory_${story.id}`, 'true');
            console.log(`[Tutorial] story ${story.id} fully completed.`);
        } else {
            console.log(`[Tutorial] page-step index=${currentIdx} done. More steps remain.`);
        }
    }

    function getPageStepIndex(storyId, step) {
        const pageSteps =
            (window.tutorials.find((t) => t.id === storyId) || {}).steps?.filter(
                (s) => s.type === 'page'
            ) || [];
        return pageSteps.indexOf(step);
    }

    // -------------------------------------------
    // G) ダイアログ表示 (Promise で完了を返す)
    // -------------------------------------------
    function showDialog(title, message, subStep, stepCounter = '') {
        return new Promise((resolve) => {
            // ダイアログ HTML を組み立て
            dialogEl.innerHTML = buildDialogHTML(title, message, subStep, stepCounter);

            // 表示開始
            overlayEl.style.display = 'block';
            dialogEl.style.display = 'block';
            dialogEl.style.opacity = '0';

            // ボタン類
            const nextBtn = dialogEl.querySelector('#tutorial-next-btn');
            const cancelBtn = dialogEl.querySelector('#tutorial-cancel-btn');
            const skipCheck = dialogEl.querySelector('#tutorial-skip-checkbox');

            // 「完了ボタン」要素 (completeステップ用)
            const completeBtn = dialogEl.querySelector('#tutorial-complete-btn');

            // 「OKボタン非表示」指定なら
            if (subStep?.removeOkButton && nextBtn) {
                nextBtn.style.display = 'none';
            }

            // もし「完了ボタン」(complete)があるなら、そのクリック時に resolve({ok:true}) して終わる
            if (completeBtn) {
                completeBtn.addEventListener('click', () =>
                    closeDialog({
                        ok: true,
                        cancel: false,
                        skipCheck: false,
                    })
                );
            }

            // イベント
            if (nextBtn) {
                nextBtn.addEventListener('click', () =>
                    closeDialog({
                        ok: true,
                        cancel: false,
                        skipCheck: !!skipCheck?.checked,
                    })
                );
            }
            if (cancelBtn) {
                cancelBtn.addEventListener('click', () => {
                    // ▼ ここで forceTutorial パラメータを削除
                    removeForceTutorialParam();
                    closeDialog({
                        ok: false,
                        cancel: true,
                        skipCheck: !!skipCheck?.checked,
                    });
                });
            }

            /** forceTutorialパラメータだけを削除してURLを上書き */
            function removeForceTutorialParam() {
                const currentUrl = new URL(window.location.href);
                currentUrl.searchParams.delete('forceTutorial');
                // 同じページでURLだけ書き換え(リロードせず)
                window.history.replaceState({}, '', currentUrl);
            }

            // ハイライト関連
            let highlightEl = null;
            if (subStep?.highlightSelector) {
                highlightEl = document.querySelector(subStep.highlightSelector);
                if (highlightEl) {
                    highlightEl.classList.add('tutorial-highlight');
                    highlightEl.scrollIntoView({
                        block: 'center',
                        inline: 'center',
                        behavior: 'smooth',
                    });
                    waitForScrollEnd(highlightEl, () => {
                        positionDialog(dialogEl, highlightEl);
                        fadeInDialog();
                    });
                } else {
                    centerDialog(dialogEl);
                    fadeInDialog();
                }
            } else {
                centerDialog(dialogEl);
                fadeInDialog();
            }

            // 特定要素クリック待ち
            let clickHandler = null;
            if (subStep?.waitForClickOn) {
                const targetEl = document.querySelector(subStep.waitForClickOn);
                if (targetEl) {
                    clickHandler = () => {
                        closeDialog({
                            ok: true,
                            cancel: false,
                            skipCheck: !!skipCheck?.checked,
                        });
                    };
                    targetEl.addEventListener('click', clickHandler);
                }
            }

            // ここではモーダル監視はオフにした例
            //startModalCheck();

            function closeDialog(action) {
                // ハイライト解除
                if (highlightEl) {
                    highlightEl.classList.remove('tutorial-highlight');
                }
                // クリック待ち解除
                if (clickHandler && subStep?.waitForClickOn) {
                    const tEl = document.querySelector(subStep.waitForClickOn);
                    tEl?.removeEventListener('click', clickHandler);
                }

                // 非表示
                dialogEl.style.display = 'none';
                dialogEl.style.opacity = '0';
                overlayEl.style.display = 'none';
                stopModalCheck();

                resolve(action);
            }

            function fadeInDialog() {
                requestAnimationFrame(() => {
                    dialogEl.style.opacity = '1';
                });
            }
        });
    }

    function buildDialogHTML(title, message, subStep, stepCounter = '') {
        // もし subStep?.complete が true なら、完了ボタンのみ表示のレイアウトにする
        if (subStep?.complete) {
            return `
      <div class="step-title">
        ${escapeHtml(title)}${escapeHtml(stepCounter)}
      </div>
      <div class="step-message">${escapeHtml(message)}</div>
      <div style="display:flex; justify-content:right; gap:10px;">
        <button id="tutorial-complete-btn" style="min-width:6rem;">完了</button>
      </div>
    `;
        }
        return `
      <div class="step-title">
        ${escapeHtml(title)}${escapeHtml(stepCounter)}
      </div>
      <div class="step-message">${escapeHtml(message)}</div>
      <div style="display:flex; justify-content:right; gap:10px;">
        <button id="tutorial-next-btn">次へ</button>
        <button id="tutorial-cancel-btn">キャンセル</button>
      </div>
      <div class="step-skip-container">
        <input type="checkbox" id="tutorial-skip-checkbox" />
        <label for="tutorial-skip-checkbox">次は表示しない</label>
      </div>
    `;
    }

    // -------------------------------------------
    // H) モーダル監視 (任意)
    // -------------------------------------------
    function startModalCheck() {
        stopModalCheck();
        modalCheckInterval = setInterval(() => {
            const isModalOpen = !!document.querySelector('.modal.active');
            // tutorualOverlayは常にクリック透過にしたい場合は "none" で固定
            overlayEl.style.pointerEvents = isModalOpen ? 'none' : 'none';
        }, 300);
    }

    function stopModalCheck() {
        if (modalCheckInterval) {
            clearInterval(modalCheckInterval);
            modalCheckInterval = null;
        }
    }

    // -------------------------------------------
    // I) 位置調整・ユーティリティ
    // -------------------------------------------
    function positionDialog(dialog, highlightEl) {
        const hlRect = highlightEl.getBoundingClientRect();
        const dw = dialog.offsetWidth;
        const dh = dialog.offsetHeight;

        // 下に配置できるか判定
        const spaceBelow = window.innerHeight - hlRect.bottom;
        let topPos;
        if (spaceBelow > dh + 10) {
            topPos = hlRect.bottom + 10;
        } else {
            topPos = hlRect.top - dh - 10;
        }
        if (topPos < 0) topPos = 0;

        let leftPos = hlRect.left;
        if (leftPos + dw > window.innerWidth) {
            leftPos = window.innerWidth - dw - 10;
        }
        if (leftPos < 0) leftPos = 0;

        dialog.style.top = topPos + 'px';
        dialog.style.left = leftPos + 'px';

        // 被りがあれば横ずらし
        const boxRect = dialog.getBoundingClientRect();
        if (checkOverlap(hlRect, boxRect)) {
            shiftHorizontally(dialog, hlRect, boxRect);
            clipToViewport(dialog);
        } else {
            clipToViewport(dialog);
        }
    }

    function checkOverlap(r1, r2) {
        const overlapX = r1.left < r2.right && r1.right > r2.left;
        const overlapY = r1.top < r2.bottom && r1.bottom > r2.top;
        return overlapX && overlapY;
    }

    function shiftHorizontally(dialog, hlRect, boxRect) {
        const highlightCenterX = (hlRect.left + hlRect.right) / 2;
        const screenCenterX = window.innerWidth / 2;
        const dw = boxRect.width;
        let newLeft;
        if (highlightCenterX < screenCenterX) {
            newLeft = hlRect.right + 10;
        } else {
            newLeft = hlRect.left - dw - 10;
        }
        if (newLeft < 0) newLeft = 0;
        if (newLeft + dw > window.innerWidth) {
            newLeft = window.innerWidth - dw - 10;
        }
        dialog.style.left = newLeft + 'px';
    }

    function clipToViewport(dialog) {
        const boxRect = dialog.getBoundingClientRect();
        let topPos = boxRect.top;
        let leftPos = boxRect.left;
        const dw = boxRect.width;
        const dh = boxRect.height;

        if (topPos < 0) topPos = 0;
        if (topPos + dh > window.innerHeight) {
            topPos = window.innerHeight - dh - 10;
            if (topPos < 0) topPos = 0;
        }
        if (leftPos < 0) leftPos = 0;
        if (leftPos + dw > window.innerWidth) {
            leftPos = window.innerWidth - dw - 10;
            if (leftPos < 0) leftPos = 0;
        }
        dialog.style.top = topPos + 'px';
        dialog.style.left = leftPos + 'px';
    }

    function centerDialog(dialog) {
        const dw = dialog.offsetWidth;
        const dh = dialog.offsetHeight;
        let topPos = (window.innerHeight - dh) / 2;
        let leftPos = (window.innerWidth - dw) / 2;
        if (topPos < 0) topPos = 0;
        if (leftPos < 0) leftPos = 0;
        dialog.style.top = topPos + 'px';
        dialog.style.left = leftPos + 'px';
    }

    function waitForScrollEnd(el, callback) {
        let stableCount = 0;
        let lastTop = null;
        function step() {
            const rect = el.getBoundingClientRect();
            const currentTop = rect.top;
            if (lastTop !== null && Math.abs(currentTop - lastTop) < 0.5) {
                stableCount++;
            } else {
                stableCount = 0;
            }
            lastTop = currentTop;
            if (stableCount > 5) {
                callback();
            } else {
                requestAnimationFrame(step);
            }
        }
        requestAnimationFrame(step);
    }

    // -------------------------------------------
    // J) 細かいユーティリティ
    // -------------------------------------------
    function getCurrentPageName() {
        let page = location.pathname.split('/').pop() || '';
        if (!page || page === '') {
            page = 'index.html';
        }
        return page;
    }
    function getQueryParam(name) {
        const params = new URLSearchParams(window.location.search);
        return params.get(name);
    }
    function escapeHtml(str) {
        if (!str) return '';
        return str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;');
    }
})();---
universalSaveLoad.js
/************************************************************
 * universalSaveLoad.js
 * 全体共通のセーブスロット管理
 * ★ onOpen コールバック内の要素取得方法を修正
 * ★ ES Modules 形式、必要な関数を export
 * ★ 依存関数を import
 * ★ 省略なし
 ************************************************************/

// --- モジュールインポート ---
import { open as multiModalOpen } from './multiModal.js';
import { getScenarioById, updateScenario, getSceneEntriesByScenarioId, deleteSceneEntry, addSceneEntry, listAllSlots as dbListAllSlots, getUniversalSave as dbGetUniversalSave, putUniversalSave as dbPutUniversalSave, deleteUniversalSlot as dbDeleteUniversalSlot } from './indexedDB.js';
import { showToast } from './common.js';
import { loadScenarioData } from './sceneManager.js'; 
// DOMPurify はグローバルにある想定

import { StabilityApiClient } from './stabilityApiClient.js';
import { GeminiApiClient } from './geminiApiClient.js';

// --- モジュールスコープ変数 ---
const PREFERRED_GEMINI_MODEL_LS_KEY = 'preferredGeminiModel';
const gemini = new GeminiApiClient(); // new
const modelId = localStorage.getItem(PREFERRED_GEMINI_MODEL_LS_KEY) || 'gemini-1.5-flash-latest';
const stability = new StabilityApiClient(); // new

// --- セーブ/ロード モーダル関連 ---

document.addEventListener('DOMContentLoaded', () => {
  console.log('[UniversalSaveLoad] DOMContentLoaded fired.'); // (1) リスナー実行確認

  const saveLoadButton = document.getElementById('save-load-button');
  console.log('[UniversalSaveLoad] saveLoadButton element:', saveLoadButton); // (2) ボタン要素を取得できたか確認

  if (saveLoadButton) {
    console.log('[UniversalSaveLoad] Adding click listener to #save-load-button'); // (3) リスナー追加処理が実行されるか確認

    // クリックされた時の処理を無名関数で囲み、その中でログ出力と関数呼び出しを行う
    saveLoadButton.addEventListener('click', () => {
      console.log('[UniversalSaveLoad] #save-load-button clicked!'); // (4) ボタンクリックが検知されたか確認

      // openSaveLoadModal が関数として存在するか確認してから呼び出す
      if (typeof openSaveLoadModal === 'function') {
        console.log('[UniversalSaveLoad] Calling openSaveLoadModal...'); // (5) 関数呼び出しが試みられるか確認
        openSaveLoadModal(); // 実際の関数呼び出し
      } else {
        console.error('[UniversalSaveLoad] openSaveLoadModal function is not defined!'); // (5') 関数が見つからない場合のエラーログ
        alert('エラー: モーダルを開く関数が見つかりません。');
      }
    });
  } else {
    // もしボタン要素が見つからない場合
    console.warn('[UniversalSaveLoad] #save-load-button element not found!');
  }
});

/**
 * セーブ／ロード用モーダルを multiModal で開く。
 */
export async function openSaveLoadModal() {
  console.log('[SaveLoad] Opening save/load modal...');
  multiModalOpen({
    // import
    id: 'save-load-modal',
    title: 'セーブ / ロード',
    contentHtml: `
            <div id="slot-container" style="margin: 0 auto; max-width: 400px; margin-bottom: 20px;">
                <div id="slot-items-container" style="background-color: rgba(0,0,0,0.4); margin-bottom: 10px; min-height: 100px;">
                    <div class="loading" style="padding: 20px; text-align: center;">スロット読込中...</div>
                </div>
                <button id="add-slot-button" title="新しいセーブスロットを追加" style="width: 100%; border: none; background-color: rgba(255,255,255,0.08); padding: 8px;">＋ スロット追加</button>
            </div>
            <div class="c-flexbox" style="margin-bottom:20px;">
                <button id="do-save-button" style="display:none;" title="現在のシナリオ進行状況を選択スロットに保存">現在の状況を保存</button>
                <button id="do-load-button" title="選択したスロットの状況からシナリオを開始/再開">選択したスロットから始める</button>
            </div>
            <div class="c-flexbox" style="margin-top:15px;">
                <button id="clear-all-slots-button" style="background-color:#b71c1c; border-color:#b71c1c;" title="全てのセーブデータを削除して初期化します">全スロット初期化</button>
            </div>
        `,
    showCloseButton: true,
    appearanceType: 'center',
    closeOnOutsideClick: true,
    cancelLabel: '閉じる',
    // ★★★ onOpen コールバックの修正 ★★★
    onOpen: async () => {
      // ★ 引数 modalInstance を削除
      console.log('[SaveLoad] Modal opened. Initializing slots...');
      try {
        await ensureInitialSlots(); // スロット初期化

        // ★ 引数を使わず document.getElementById で要素を取得
        const addSlotBtn = document.getElementById('add-slot-button');
        const doSaveBtn = document.getElementById('do-save-button');
        const doLoadBtn = document.getElementById('do-load-button');
        const clearAllBtn = document.getElementById('clear-all-slots-button');

        // イベント紐付け (null チェック追加)
        if (addSlotBtn) addSlotBtn.addEventListener('click', onAddSlot);
        else console.warn('Add slot button not found');
        if (doSaveBtn) doSaveBtn.addEventListener('click', onClickSave);
        else console.warn('Save button not found');
        // ★ onClickLoad から modalInstance 引数を削除 (閉じる処理は別途検討)
        if (doLoadBtn) doLoadBtn.addEventListener('click', () => onClickLoad());
        else console.warn('Load button not found');
        if (clearAllBtn) clearAllBtn.addEventListener('click', onClearAllSlots);
        else console.warn('Clear all button not found');

        await renderSlotList(); // スロットリスト表示
        console.log('[SaveLoad] Slots rendered.');
      } catch (error) {
        console.error('[SaveLoad] Error during modal open setup:', error);
        showToast(`スロット初期化エラー: ${error.message}`); // import
        const container = document.getElementById('slot-items-container');
        if (container) container.innerHTML = `<p class="error">スロット情報読込失敗</p>`;
      }
    },
    // ★★★ ここまで修正 ★★★
  });
}

/**
 * スロット一覧を描画
 */
export async function renderSlotList() {
  // (中身は変更なし - 省略せず記述)
  const container = document.getElementById('slot-items-container');
  if (!container) {
    console.error('Slot container not found.');
    return;
  }
  container.innerHTML = `<div class="loading">読込中...</div>`;
  try {
    const allSlots = await listAllSlots();
    container.innerHTML = '';
    if (allSlots.length === 0) {
      container.innerHTML = `<p>スロットなし</p>`;
      return;
    }
    allSlots.forEach((slot) => {
      const rowC = document.createElement('div');
      rowC.className = 'save-slot-row-container';
      const delBtn = document.createElement('button');
      delBtn.className = 'save-slot-delete';
      delBtn.innerHTML = `<span class="iconmoon icon-cross"></span>`;
      delBtn.title = `スロット${slot.slotIndex}削除`;
      delBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        await onDeleteSlot(slot.slotIndex);
      });
      const row = document.createElement('div');
      row.className = 'save-slot-row';
      const rb = document.createElement('input');
      rb.type = 'radio';
      rb.name = 'slotRadio';
      rb.value = slot.slotIndex;
      rb.id = `slotRadio_${slot.slotIndex}`;
      const label = document.createElement('label');
      label.setAttribute('for', rb.id);
      if (!slot.data) {
        label.innerHTML = `<span style="color: #aaa;">${slot.slotIndex}: (空き)</span>`;
      } else {
        let date = slot.updatedAt;
        try {
          date = new Date(slot.updatedAt).toLocaleString('ja-JP');
        } catch {}
        const title = slot.data.scenarioTitle || '(不明)';
        const scenes = slot.data.scenes?.length || 0;
        label.innerHTML = `<b>${slot.slotIndex}:</b> ${DOMPurify.sanitize(title)} <small style="color:#bbb;">(${scenes}シーン, ${date})</small>`;
      }
      row.appendChild(rb);
      row.appendChild(label);
      rowC.appendChild(row);
      rowC.appendChild(delBtn);
      container.appendChild(rowC);
    });
    const saveBtn = document.getElementById('do-save-button');
    if (saveBtn) {
      if (window.currentScenarioId) {
        saveBtn.style.display = 'inline-block';
        saveBtn.disabled = false;
      } else {
        saveBtn.style.display = 'none';
        saveBtn.disabled = true;
      }
    }
  } catch (e) {
    console.error('Error rendering slots:', e);
    container.innerHTML = `<p class="error">リスト表示失敗</p>`;
    showToast(`リストエラー: ${e.message}`);
  }
}
/**
 * 個別スロットを削除またはクリアする処理
 * ★ スロット番号に応じて挙動を変更
 * @param {number} slotIndex 対象のスロット番号
 */
export async function onDeleteSlot(slotIndex) {
  console.log(`[SaveLoad] Delete/Clear slot ${slotIndex} initiated.`);

  // 削除かクリアかの判定
  const isDefaultSlot = slotIndex <= 5;
  const actionText = isDefaultSlot ? 'クリア' : '完全に削除';
  const confirmationTitle = isDefaultSlot ? 'スロットクリア確認' : 'スロット削除確認';
  const confirmationMessage = isDefaultSlot ? `<p>スロット ${slotIndex} のデータをクリアして空きスロットに戻しますか？<br>(スロット番号 ${slotIndex} は残ります)</p>` : `<p style="color: #ffcccc;"><strong>警告:</strong> スロット ${slotIndex} を完全に削除します。<br>このスロット番号は再利用されにくくなります。よろしいですか？</p>`;
  const okButtonLabel = isDefaultSlot ? 'データをクリア' : '完全に削除する';
  const okButtonColor = isDefaultSlot ? '#ffc107' : '#f44336'; // クリアは黄色、削除は赤

  // 確認モーダル (multiModalOpenを使用)
  multiModalOpen({
    // import
    title: confirmationTitle,
    contentHtml: confirmationMessage,
    showCloseButton: true,
    appearanceType: 'center',
    closeOnOutsideClick: true,
    okLabel: okButtonLabel,
    okButtonColor: okButtonColor,
    cancelLabel: 'キャンセル',
    onOk: async () => {
      console.log(`[SaveLoad] Executing ${actionText} for slot ${slotIndex}...`);
      try {
        if (isDefaultSlot) {
          // --- データクリア処理 ---
          const slot = await dbGetUniversalSave(slotIndex); // import DB関数
          if (slot) {
            if (slot.data === null) {
              // 既に空の場合
              showToast(`スロット ${slotIndex} は既に空です。`); // import
            } else {
              slot.data = null; // データ部分を null に
              await dbPutUniversalSave(slot); // import DB関数 (更新)
              console.log(`[SaveLoad] Slot ${slotIndex} data cleared.`);
              showToast(`スロット ${slotIndex} をクリアしました。`); // import
            }
            await renderSlotList(); // スロットリスト再描画
          } else {
            // このケースは通常起こらないはずだが念のため
            console.warn(`[SaveLoad] Slot ${slotIndex} not found for clearing.`);
            showToast('指定されたスロットが見つかりません。'); // import
          }
        } else {
          // --- レコード削除処理 ---
          await dbDeleteUniversalSlot(slotIndex); // import DB関数 (レコード削除)
          console.log(`[SaveLoad] Slot ${slotIndex} record deleted.`);
          showToast(`スロット ${slotIndex} を削除しました。`); // import
          await renderSlotList(); // スロットリスト再描画
        }
      } catch (error) {
        console.error(`[SaveLoad] Failed to ${actionText} slot ${slotIndex}:`, error);
        showToast(`スロット${actionText}中にエラー: ${error.message}`); // import
      }
    },
  });
}
/**
 * スロット追加ボタン処理
 */
export async function onAddSlot() {
  // (中身は変更なし - 省略せず記述)
  console.log('Add slot clicked.');
  try {
    const slots = await listAllSlots();
    let max = 0;
    slots.forEach((s) => {
      if (s.slotIndex > max) max = s.slotIndex;
    });
    const newIdx = max + 1;
    const rec = {
      slotIndex: newIdx,
      updatedAt: new Date().toISOString(),
      data: null,
    };
    await dbPutUniversalSave(rec);
    console.log(`Added slot ${newIdx}.`);
    showToast(`スロット ${newIdx} を追加`);
    await renderSlotList();
  } catch (e) {
    console.error('Failed add slot:', e);
    showToast(`追加エラー: ${e.message}`);
  }
}

/**
 * 保存ボタン処理
 */
export async function onClickSave() {
  // (中身は変更なし - 省略せず記述)
  console.log('Save clicked.');
  const radio = document.querySelector('input[name="slotRadio"]:checked');
  if (!radio) {
    multiModalOpen({
      title: 'エラー',
      contentHtml: '<p>保存先スロット選択</p>',
      cancelLabel: '閉',
    });
    return;
  }
  const slotIdx = parseInt(radio.value, 10);
  const scenId = window.currentScenarioId;
  if (!scenId) {
    multiModalOpen({
      title: 'エラー',
      contentHtml: '<p>保存対象シナリオなし</p>',
      cancelLabel: '閉',
    });
    return;
  }
  try {
    const slot = await dbGetUniversalSave(slotIdx);
    if (slot?.data) {
      multiModalOpen({
        title: '上書き確認',
        contentHtml: `<p>スロット ${slotIdx} 使用中。上書き？</p>`,
        okLabel: '上書き',
        okButtonColor: '#ffc107',
        onOk: async () => {
          await doSaveToSlot(slotIdx);
        },
      });
    } else {
      await doSaveToSlot(slotIdx);
    }
  } catch (e) {
    console.error(`Save prep error ${slotIdx}:`, e);
    showToast(`保存準備エラー: ${e.message}`);
  }
}

/** 指定スロットに現在シナリオデータを保存 */
async function doSaveToSlot(slotIndex) {
  // (中身は変更なし - 省略せず記述)
  console.log(`Executing save to slot ${slotIndex}...`);
  const scenId = window.currentScenarioId;
  if (!scenId) return;
  try {
    const scenObj = window.currentScenario;
    const scenes = window.scenes || [];
    if (!scenObj) throw new Error(`メモリにシナリオ(ID: ${scenId})なし`);
    const data = {
      scenarioId: scenId,
      scenarioTitle: scenObj.title || '(無題)',
      scenarioWizardData: scenObj.wizardData || {},
      scenes: scenes,
    };
    const record = {
      slotIndex: slotIndex,
      updatedAt: new Date().toISOString(),
      data: data,
    };
    await dbPutUniversalSave(record);
    console.log(`Scenario ${scenId} saved to slot ${slotIndex}.`);
    showToast(`スロット ${slotIndex} に保存`);
    await renderSlotList();
  } catch (e) {
    console.error(`Failed save to slot ${slotIndex}:`, e);
    showToast(`保存失敗: ${e.message}`);
  }
}

/**
 * ロードボタン処理 (★ modalInstance 引数削除)
 */
export async function onClickLoad(/* modalInstance */) {
  // ← 引数削除
  console.log('[SaveLoad] Load button clicked.');
  const selectedRadio = document.querySelector('input[name="slotRadio"]:checked');
  if (!selectedRadio) {
    multiModalOpen({
      title: 'エラー',
      contentHtml: '<p>ロードスロット選択</p>',
      cancelLabel: '閉',
    });
    return;
  }
  const slotIndex = parseInt(selectedRadio.value, 10);

  try {
    const slotToLoad = await dbGetUniversalSave(slotIndex); // import
    if (!slotToLoad?.data) {
      multiModalOpen({
        title: 'エラー',
        contentHtml: `<p>スロット ${slotIndex} 空/不正</p>`,
        cancelLabel: '閉',
      });
      return;
    }
    const targetScenarioId = slotToLoad.data.scenarioId;
    if (!targetScenarioId) {
      multiModalOpen({
        title: 'エラー',
        contentHtml: `<p>スロット ${slotIndex} シナリオ情報なし</p>`,
        cancelLabel: '閉',
      });
      return;
    }

    // ★ モーダルを閉じる処理 (ID指定で試みる)
    const currentModal = window.multiModal?.getInstanceById?.('save-load-modal'); // 仮
    if (currentModal) currentModal.close();
    else console.warn('[SaveLoad] Could not find modal instance to close before load/redirect.');

    if (window.currentScenarioId && targetScenarioId === window.currentScenarioId) {
      // 同じシナリオ -> 上書き確認
      console.log(`Loading slot ${slotIndex} into current scenario ${targetScenarioId}...`);
      multiModalOpen({
        title: 'データ上書き確認',
        contentHtml: `<p>現在シナリオ(ID:${targetScenarioId})をスロット${slotIndex}データで上書き？</p>`,
        okLabel: '上書きロード',
        okButtonColor: '#ffc107',
        cancelLabel: 'キャンセル',
        onOk: async () => {
          // 上書き確認モーダルも閉じる必要があるかもしれない
          const confirmModal = window.multiModal?.getInstanceById?.('data-overwrite-confirm'); // 仮ID
          if (confirmModal) confirmModal.close();

          await doLoadScenarioFromSlot(slotToLoad.data); // ロード実行
          showToast(`スロット ${slotIndex} ロード完了`);
        },
      });
    } else {
      // 違うシナリオ -> scenario.html へ遷移
      console.log(`Redirecting to scenario.html?slotIndex=${slotIndex}...`);
      const url = `scenario.html?slotIndex=${slotIndex}&action=load`;
      window.location.href = url;
    }
  } catch (error) {
    console.error(`Load prep error for slot ${slotIndex}:`, error);
    showToast(`ロード準備エラー: ${error.message}`);
  }
}

/**
 * スロットデータからシナリオ情報をDB反映＆UI更新 (scenario.html 側想定)
 */
export async function doLoadScenarioFromSlot(slotData) {
  // (中身は変更なし - 省略せず記述)
  if (!slotData?.scenarioId) throw new Error('無効スロットデータ');
  const sId = slotData.scenarioId;
  console.log(`Executing load from slot for scenario ${sId}...`);
  if (typeof window.showLoadingModal === 'function') window.showLoadingModal(true);
  try {
    let scenObj = await getScenarioById(sId);
    if (!scenObj) throw new Error(`DBシナリオ ${sId} 不在`);
    scenObj.title = slotData.scenarioTitle || scenObj.title || '(無題)';
    scenObj.wizardData = slotData.scenarioWizardData || scenObj.wizardData || {};
    await updateScenario(scenObj, true);
    console.log(`Scenario ${sId} updated.`);
    const existing = await getSceneEntriesByScenarioId(sId);
    const delProms = existing.map((e) => deleteSceneEntry(e.entryId));
    await Promise.all(delProms);
    console.log(`Deleted ${existing.length} entries.`);
    const scenes = slotData.scenes || [];
    const addProms = [];
    for (const sc of scenes) {
      const rec = {
        scenarioId: sId,
        type: 'scene',
        sceneId: sc.sceneId || `scene_${Date.now()}_${Math.random().toString(16).substring(2, 8)}`,
        content: sc.content || '',
        content_en: sc.content_en || '',
        actionContent: sc.action?.content || '',
        actionContent_en: sc.action?.content_en || '',
        prompt: '',
      };
      addProms.push(
        addSceneEntry(rec).then(async (newId) => {
          rec.entryId = newId;
          if (rec.content && typeof window.generateImagePromptFromScene === 'function' && gemini) {
            try {
              const p = await window.generateImagePromptFromScene(rec.content);
              if (p) {
                rec.prompt = p;
                await updateSceneEntry(rec);
              }
            } catch (e) {
              console.error('Err gen img prompt:', e);
            }
          }
          const imgProms = (sc.images || []).map((img) =>
            addSceneEntry({
              scenarioId: sId,
              type: 'image',
              sceneId: rec.sceneId,
              dataUrl: img.dataUrl || '',
              prompt: img.prompt || '',
            })
          );
          return Promise.all(imgProms);
        })
      );
    }
    await Promise.all(addProms);
    console.log(`Added ${scenes.length} scenes.`);
    // ★ 修正箇所: window を使わず、import した関数を直接呼び出す
    if (typeof loadScenarioData === 'function') {
      // import した関数があるか確認
      await loadScenarioData(sId); // 直接呼び出し (window. を削除)
      console.log(`Scenario ${sId} reloaded.`);
    } else {
      // この else は import が正しければ通常通りません
      console.error('loadScenarioData function is not imported or not found!');
      showToast('エラー: シナリオ再読込関数の呼び出しに失敗しました');
    }
  } catch (e) {
    console.error(`Failed load from slot ${sId}:`, e);
    showToast(`ロードエラー: ${e.message}`);
    throw e;
  } finally {
    if (typeof window.showLoadingModal === 'function') window.showLoadingModal(false);
  }
}

/**
 * 「全スロット初期化」ボタン処理
 */
export async function onClearAllSlots() {
  // (中身は変更なし - 省略せず記述)
  console.log('Clear all slots initiated.');
  multiModalOpen({
    title: '全スロット初期化',
    contentHtml: "<p style='color: #ffcccc;'><strong>警告:</strong> 全セーブデータ削除？</p>",
    okLabel: '全て初期化',
    okButtonColor: '#b71c1c',
    cancelLabel: 'キャンセル',
    onOk: async () => {
      console.log('Clearing all slots...');
      try {
        const slots = await listAllSlots();
        const delProms = slots.map((s) => dbDeleteUniversalSlot(s.slotIndex));
        await Promise.all(delProms);
        console.log(`Deleted ${slots.length} slots.`);
        await ensureInitialSlots();
        await renderSlotList();
        showToast('全スロット初期化完了');
      } catch (e) {
        console.error('Failed clear all:', e);
        showToast(`初期化エラー: ${e.message}`);
      }
    },
  });
}

// --- DB操作関数 (indexedDB.js から import した関数を使う) ---

/** スロットがなければ初期スロット5つを作成 */
async function ensureInitialSlots() {
  // (中身は変更なし - 省略せず記述)
  try {
    const all = await dbListAllSlots();
    if (all.length > 0) return;
    console.log('[SaveLoad/DB] Creating initial 5 slots...');
    const promises = [];
    for (let i = 1; i <= 5; i++) {
      const rec = {
        slotIndex: i,
        updatedAt: new Date().toISOString(),
        data: null,
      };
      promises.push(dbPutUniversalSave(rec));
    }
    await Promise.all(promises);
    console.log('[SaveLoad/DB] Initial slots created.');
  } catch (e) {
    console.error('Error ensuring initial slots:', e);
    throw e;
  }
}

/** 全スロットデータをDBから取得 */
async function listAllSlots() {
  // (中身は変更なし - 省略せず記述)
  try {
    const result = await dbListAllSlots();
    return result;
  } catch (e) {
    console.error('Error listing slots:', e);
    throw e;
  }
}

// --- ファイル読み込み完了ログ ---
console.log('[SaveLoad] universalSaveLoad.js loaded and functions exported.');
---
sceneGlobals.js
/********************************
 * sceneGlobals.js
 * グローバル変数や共通定数などを集めたファイル
 * ★ 不要になった API キー、クライアントインスタンス、キャンセル関連を削除
 * ★ シナリオタイプなども currentScenario から参照するため削除
 * ★ ES Modules として読み込まれる前提 (中身は window への登録)
 * ★ 省略なし
 ********************************/

console.log('[Globals] Loading sceneGlobals.js...');

// -------------------------------
// ▼ グローバル変数定義 (window オブジェクトを使用)
// -------------------------------

// --- 削除される変数 ---
// window.apiKey = ''; // 削除: 各クライアントが内部管理 or localStorage 参照
// window.geminiClient = null; // 削除: 利用側で new する
// window.stabilityClient = null; // 削除: 利用側で new する
// window.currentRequestController = null; // 削除: キャンセル機能変更のため
// window.cancelRequested = false; // 削除: キャンセル機能変更のため
// window.scenarioType = null; // 削除: window.currentScenario.wizardData を参照
// window.clearCondition = null; // 削除: window.currentScenario.wizardData を参照
// window.sections = []; // 削除: window.currentScenario.wizardData を参照

// --- 維持される変数 ---

/** 現在表示・操作中のシナリオID (例: menu.js や sceneMain.js で設定) */
window.currentScenarioId = null;

/** 現在表示・操作中のシナリオオブジェクト全体 (例: sceneManager.js で設定)
 * これには wizardData (scenarioType, clearCondition, sections を含む) も含まれる想定
 */
window.currentScenario = null;

/** 現在のシナリオのシーン履歴 (メモリキャッシュ) (例: sceneManager.js で更新) */
window.scenes = [];

/** シーン要約のメモリキャッシュ (例: sceneManager.js で更新) */
window.sceneSummaries = []; // sceneSummaries[chunkIndex] = { en: '...', ja: '...' }

/** 選択されたアイテム (アイテム使用機能用) (例: sceneUI.js で更新) */
window.selectedItem = null;

/** IndexedDB データベース接続オブジェクト (indexedDB.js で設定) */
window.db = null;

/** DOMPurify の設定 (固定値) */
window.DOMPURIFY_CONFIG = {
  ALLOWED_TAGS: ['p', 'br', 'hr', 'h3', 'h4', 'h5', 'span', 'div', 'strong', 'em'],
  ALLOWED_ATTR: ['style'],
};

// --- グローバル変数ではないが、便宜上ここに置いている可能性のあるもの ---
// (特になし)

// --- ファイル読み込み完了ログ ---
console.log('[Globals] sceneGlobals.js loaded and global variables initialized (or set to null).');

// ★ このファイル自体は他のファイルから import する必要はありません。
//    HTML で <script type="module" src="js/sceneGlobals.js"></script> のように
//    他のスクリプトより先に読み込ませて、window オブジェクトに必要な変数を定義します。
---
carousel.js
export function initCarousel() {
  const track = document.querySelector(".carousel-track");
  if (!track) return;

  let cells = Array.from(track.querySelectorAll(".carousel-cell"));
  if (cells.length < 1) return;

  const tabBtns = Array.from(document.querySelectorAll(".carousel-tab"));

  // 1) 先頭と末尾のクローンを作る（is-clonedクラス付与）
  const firstClone = cells[0].cloneNode(true);
  firstClone.classList.add("is-cloned");
  const lastClone = cells[cells.length - 1].cloneNode(true);
  lastClone.innerHTML = "";
  lastClone.classList.add("is-cloned");
  track.appendChild(firstClone);
  track.insertBefore(lastClone, track.firstElementChild);

  // 2) クローンを含む全セルを再取得
  let allCells = Array.from(track.querySelectorAll(".carousel-cell"));

  let currentIndex = 1; // 初期は「先頭クローンの直後」＝1
  let cellWidth = 0;
  let currentTranslate = 0;
  let prevTranslate = 0;
  let isDragging = false;
  let startX = 0;
  let animationId = 0;

  // MutationObserver でセルのサイズ変化を検知し、自動で再計算する ---
  let mutationTimer = null;
  const observer = new MutationObserver(() => {
    // 連続で変化が起きても対応できるようdebounce
    if (mutationTimer) {
      clearTimeout(mutationTimer);
    }
    mutationTimer = setTimeout(() => {
      // 内容が変わったあと、しばらくしてサイズ再計算
      updateCellWidth();
    }, 500);
  });
  observer.observe(track, {
    childList: true,
    subtree: true,
    characterData: true,
    attributes: true
  });
  // -----------------------------------------------------------------------

  // --- (追加) フォーカスを拾ってそのセルをアクティブ表示にする ---
  track.addEventListener("focusin", (e) => {
    // フォーカスされた要素がどの.cellに属するかを探す
    const targetCell = e.target.closest(".carousel-cell");
    if (!targetCell) return;

    // allCells配列上のインデックスを取得
    const idx = allCells.indexOf(targetCell);
    if (idx === -1) return;

    // クローン込みの currentIndex に設定して移動
    currentIndex = idx;
    setPositionByIndex(true);
  });
  // -----------------------------------------------------------------------

  // 3) タブボタンクリックで移動
  tabBtns.forEach((btn, i) => {
    btn.addEventListener("click", () => {
      currentIndex = i + 1; // クローンが先頭に1枚あるので+1
      setPositionByIndex(true);
      updateActiveTab(i);
    });
  });

  function updateActiveTab(realIndex) {
    tabBtns.forEach(t => t.classList.remove("active"));
    if (tabBtns[realIndex]) {
      tabBtns[realIndex].classList.add("active");
    }
  }

  // 4) ウィンドウリサイズや初期表示時にセル幅を計測
  function updateCellWidth() {
    const anyCell = allCells[0];
    if (!anyCell) return;
    cellWidth = anyCell.offsetWidth;
    if (!cellWidth) {
      requestAnimationFrame(updateCellWidth);
      return;
    }
    setPositionByIndex(false);
  }

  window.addEventListener("resize", updateCellWidth);
  updateCellWidth();

  // 5) ドラッグ / スワイプ関連
  track.addEventListener("pointerdown", dragStart);
  track.addEventListener("pointermove", dragAction);
  track.addEventListener("pointerup", dragEnd);
  track.addEventListener("pointercancel", dragEnd);
  track.addEventListener("pointerleave", dragEnd);

  function dragStart(e) {
    if (!cellWidth) return;

    const tag = e.target.tagName.toLowerCase();
    // テキストエリアやボタンなどはドラッグでスワイプしないように
    if (["textarea", "input", "button", "select"].includes(tag)) {
      return;
    }

    isDragging = true;
    track.style.transition = "none";
    startX = e.clientX;
    prevTranslate = currentTranslate;
    animationId = requestAnimationFrame(animation);
  }

  function dragAction(e) {
    if (!isDragging) return;
    const currentX = e.clientX;
    const diff = currentX - startX;
    currentTranslate = prevTranslate + diff;

    // クローンを含む全体範囲で強制クリップ
    const maxTranslate = 0;
    const minTranslate = -cellWidth * (allCells.length - 1);
    if (currentTranslate > maxTranslate) {
      currentTranslate = maxTranslate;
    } else if (currentTranslate < minTranslate) {
      currentTranslate = minTranslate;
    }

    e.preventDefault(); // 横スワイプを優先
  }

  function dragEnd() {
    if (!isDragging) return;
    isDragging = false;
    cancelAnimationFrame(animationId);

    const movedBy = currentTranslate - prevTranslate;
    const threshold = cellWidth * 0.1;
    if (movedBy < -threshold) {
      currentIndex++;
    } else if (movedBy > threshold) {
      currentIndex--;
    }

    setPositionByIndex(true);
  }

  function animation() {
    track.style.transform = `translateX(${currentTranslate}px)`;
    if (isDragging) {
      requestAnimationFrame(animation);
    }
  }

  // 6) インデックスに応じた位置へ移動
  function setPositionByIndex(smooth) {
    const oldTransform = track.style.transform; // 変更前のtransform

    if (smooth) {
      track.style.transition = "transform 0.3s";
    } else {
      track.style.transition = "none";
    }
    currentTranslate = -cellWidth * currentIndex;
    const newTransform = `translateX(${currentTranslate}px)`;
    track.style.transform = newTransform;

    // トランジションが発火しない場合もあるので、一応フォールバック
    if (smooth && oldTransform === newTransform) {
      handleTransitionEndManually();
    }
  }

  // 7) transitionend でクローンセル位置を調整
  track.addEventListener("transitionend", () => {
    handleTransitionEndManually();
  });

  // 8) 実処理
  function handleTransitionEndManually() {
    if (!cellWidth) return;

    // 先頭クローン(index=0)にいる → 最後の本物セルへ
    if (currentIndex === 0) {
      track.style.transition = "none";
      currentIndex = cells.length; // 本物の末尾
      currentTranslate = -cellWidth * currentIndex;
      track.style.transform = `translateX(${currentTranslate}px)`;
    }
    // 末尾クローン(index=allCells.length-1) → 先頭の本物セルへ
    else if (currentIndex === allCells.length - 1) {
      track.style.transition = "none";
      currentIndex = 1; // 本物の先頭
      currentTranslate = -cellWidth * currentIndex;
      track.style.transform = `translateX(${currentTranslate}px)`;
    }

    // タブのactive表示を更新
    let realIndex = currentIndex - 1;
    if (realIndex < 0) realIndex = 0;
    if (realIndex >= cells.length) realIndex = cells.length - 1;
    updateActiveTab(realIndex);
  }
}

// 複製セルに含まれるIDを削除
export function removeDuplicateIDs() {
  // クローンセル（.is-cloned）を探す
  const clonedCells = document.querySelectorAll(".carousel-cell.is-cloned");
  // 配下にある id を削除
  clonedCells.forEach(cell => {
    const elemsWithId = cell.querySelectorAll("[id]");
    elemsWithId.forEach(el => {
      el.removeAttribute("id");
    });
  });
}
---
sceneManager.js
/********************************
 * sceneManager.js
 * シーン関連の主要ロジック (API呼び出し含む)
 * ★ API 呼び出しを Gemini API (geminiClient) に変更
 * ★ ES Modules 形式、依存関係を import
 * ★ 省略なし
 ********************************/

// --- モジュールインポート ---
import { GeminiApiClient } from './geminiApiClient.js'; // ★ Gemini クラス
import {
  getScenarioById,
  updateScenario,
  addSceneEntry,
  updateSceneEntry,
  getSceneEntriesByScenarioId,
  deleteSceneEntry,
  addSceneSummaryRecord,
  getSceneSummaryByChunkIndex, // ★ 要約関連も import
  saveCharacterDataToIndexedDB,
  loadCharacterDataFromIndexedDB, // ゲットカード用
  getEntitiesByScenarioId, // ★ 必要なら追加
} from './indexedDB.js';

import { showToast } from './common.js';
// ★ sceneUI.js から UI 更新関数を import する想定 (またはグローバル window.* 参照)
import {
  showLoadingModal,
  showLastScene,
  renderItemChips,
  onGenerateActionCandidates,
  openImagePromptModal, // ★ 仮: sceneUI.js で export されている想定
  // 他に必要な UI 関数があれば追加
} from './sceneUI.js'; // ★ パス確認

// pako, DOMPurify はグローバル想定

// --- localStorage キー ---
const PREFERRED_GEMINI_MODEL_LS_KEY = 'preferredGeminiModel';

// --- シナリオ読み込み ---

/**
 * 指定されたシナリオIDのデータをDBから読み込み、メモリ (window変数) に展開し、UIを初期化する
 * @param {number} scenarioId
 */
// ★ export する (sceneMain.js や universalSaveLoad.js から呼ばれるため)
export async function loadScenarioData(scenarioId) {
  console.log(`[SceneManager] Loading scenario data for ID: ${scenarioId}...`);
  try {
    const sc = await getScenarioById(scenarioId); // import
    if (!sc) {
      throw new Error(`シナリオID ${scenarioId} が見つかりません。`);
    }

    // グローバル変数に格納 (sceneGlobals.js で定義されている想定)
    window.currentScenario = sc;
    window.currentScenarioId = scenarioId;

    const wd = sc.wizardData || {};
    // ★ window.scenarioType などは廃止したので、wizardData から直接参照する
    // window.scenarioType = wd.scenarioType;
    // window.clearCondition = wd.clearCondition || "";
    // window.sections = wd.sections || [];

    // シーン一覧をDBから取得してメモリに整形
    await loadAllScenesForScenario(scenarioId); // このファイル内で定義

    // 要約を読み込む
    window.sceneSummaries = []; // 初期化
    for (let i = 0; i < 100; i++) {
      // 最大100チャンクと仮定
      const sumRec = await getSceneSummaryByChunkIndex(i); // import
      if (!sumRec) break; // 見つからなくなったら終了
      window.sceneSummaries[i] = { en: sumRec.content_en, ja: sumRec.content_ja };
    }

    // 履歴エリアの初期表示状態をDBの値に合わせて設定
    const hist = document.getElementById('scene-history');
    const historyBtn = document.getElementById('toggle-history-button'); // ボタン要素も取得
    if (hist && window.currentScenario) {
      // DBから読み込んだ showHistory の値 (未定義なら false 扱い) を反映
      const show = window.currentScenario.showHistory || false;
      hist.style.display = show ? 'flex' : 'none'; // toggleHistory内の設定に合わせる ('flex' or 'block')
      console.log(`[SceneManager] Initial history display set to: ${hist.style.display}`);

      // 履歴ボタンの見た目も初期状態に合わせる (任意)
      if (historyBtn) {
        historyBtn.style.backgroundColor = show ? '#777' : ''; // toggleHistory内のスタイルに合わせる
      }
    } else if (!hist) {
      console.warn('[SceneManager] #scene-history element not found for initial setup.');
    }

    console.log(`[SceneManager] Loaded ${window.sceneSummaries.length} summary chunks.`);

    // UI再描画 (sceneUI.js の関数を import して使用)
    if (typeof updateSceneHistory === 'function') updateSceneHistory();
    else console.warn('updateSceneHistory not imported/found.');
    if (typeof showLastScene === 'function') showLastScene();
    else console.warn('showLastScene not imported/found.');
    if (typeof refreshEndingButtons === 'function') refreshEndingButtons();
    else console.warn('refreshEndingButtons not imported/found.'); // import (sceneExtras?)
    if (typeof renderItemChips === 'function') await renderItemChips();
    else console.warn('renderItemChips not imported/found.'); // import (sceneUI?)

    // ネタバレボタンの表示制御 (wizardData を直接参照)
    const spoilerButton = document.getElementById('spoiler-button');
    if (spoilerButton) spoilerButton.style.display = wd.scenarioType === 'objective' ? 'inline-block' : 'none';

    console.log(`[SceneManager] Scenario ${scenarioId} loaded successfully.`);
  } catch (err) {
    console.error('[SceneManager] シナリオ読み込み失敗:', err);
    alert('シナリオの読み込みに失敗しました:\n' + err.message);
    // エラーが発生したらメニューに戻るなどの処理
    // window.location.href = "index.html";
  }
}

/**
 * DB の sceneEntries からデータを取得し、window.scenes に整形格納
 * @param {number} scenarioId
 */
async function loadAllScenesForScenario(scenarioId) {
  console.log(`[SceneManager] Loading all scene entries for scenario ${scenarioId}...`);
  window.scenes = []; // 初期化
  const allEntries = await getSceneEntriesByScenarioId(scenarioId); // import

  const sceneRecords = allEntries.filter((e) => e.type === 'scene');
  const imageRecords = allEntries.filter((e) => e.type === 'image');
  sceneRecords.sort((a, b) => (a.entryId || 0) - (b.entryId || 0)); // entryId でソート
  imageRecords.sort((a, b) => (a.entryId || 0) - (b.entryId || 0));

  for (const sRec of sceneRecords) {
    const sceneImages = imageRecords
      .filter((imgRec) => imgRec.sceneId === sRec.sceneId)
      .map((img) => ({
        entryId: img.entryId,
        dataUrl: img.dataUrl,
        prompt: img.prompt || '',
      }));

    window.scenes.push({
      sceneId: sRec.sceneId,
      scenarioId: sRec.scenarioId,
      content: sRec.content || '',
      content_en: sRec.content_en || '',
      action: { content: sRec.actionContent || '', content_en: sRec.actionContent_en || '' },
      images: sceneImages, // 紐づく画像を設定
    });
  }
  console.log(`[SceneManager] Formatted ${window.scenes.length} scenes with images.`);
}

// --- 次のシーン取得 (★ Gemini API 使用) ---

/**
 * 次のシーンを生成して表示・保存する
 * @param {boolean} [useItem=false] アイテム使用フラグ
 */
// ★ export する (sceneMain.js や sceneUI.js から呼ばれるため)
export async function getNextScene(useItem = false) {
  console.log(`[SceneManager] getNextScene called (useItem: ${useItem})`);
  // ★ Gemini クライアントを new して使用
  const gemini = new GeminiApiClient(); // import
  if (!gemini.isAvailable) {
    showToast('Gemini APIキー未設定/無効');
    return;
  } // import
  if (gemini.isStubMode) {
    /* ... スタブ処理 ... */ return;
  }

  const modelId = localStorage.getItem(PREFERRED_GEMINI_MODEL_LS_KEY) || 'gemini-1.5-flash-latest';
  let playerInputJa = ''; // 日本語のプレイヤー入力

  if (!useItem) {
    playerInputJa = document.getElementById('player-input')?.value?.trim() || '';
    if (!playerInputJa) {
      alert('プレイヤー行動を入力してください');
      return;
    }
  } else if (window.selectedItem) {
    // グローバル参照
    const item = window.selectedItem;
    playerInputJa = `[アイテム使用] ${item.name || '?'}: ${item.description || '?'}`;
    window.selectedItem = null; // 使用したら解除
    // アイテムチップの選択状態も解除 (sceneUI.js の責務かも)
    document.querySelectorAll('#item-chips-container .chip.selected').forEach((c) => c.classList.remove('selected'));
  } else {
    alert('使用するアイテムが選択されていません。');
    return;
  }

  // ★ キャンセル処理は削除 (AbortController使わない)
  // window.cancelRequested = false;
  showLoadingModal(true); // import/このファイル内?
  try {
    // 1) プレイヤー行動の英語翻訳 (翻訳ヘルパー使用)
    let playerInputEn = '';
    if (playerInputJa) {
      console.log('[SceneManager] Translating player action to English...');
      try {
        playerInputEn = await generateEnglishTranslation(playerInputJa); // このファイル内 (Gemini使用)
        console.log(`[SceneManager] Translated action (EN): ${playerInputEn}`);
      } catch (transError) {
        console.error('Action translation failed:', transError);
        showToast('行動の英訳に失敗しました。日本語のまま処理します。'); // import
        playerInputEn = playerInputJa; // 失敗時は日本語のまま
      }
    }

    // 2) システムプロンプト + 会話履歴の準備
    const wd = window.currentScenario?.wizardData || {}; // global
    const sections = wd.sections || [];
    let systemText = `あなたは経験豊富なTRPGゲームマスター(GM)です。以下のルールに従い、プレイヤーの行動に対する次のシーンを生成してください。
ルール:
- 背景黒が前提の、読みやすい文字のHTML的な装飾をする。style直書きで良い。
- 出力は必ず日本語。
- シナリオ設定と過去の展開との整合性を保つ。
- プレイヤーの行動の結果を具体的に描写する。
- 新たな状況や登場人物、選択肢を提示し、物語を進展させる。
- 時々パーティメンバーの短い会話や反応を含める。
- メタ的な発言(GMとしての説明など)はしない。
- 最後の文節はプレイヤーに次の行動を促す問いかけで終わることが望ましいが、選択肢は不要。
- 必要に応じて【セクション目標】の達成に繋がるヒントを自然に含める。
======
`;
    if (sections.length > 0) {
      systemText += '【現在のセクション目標】\n';
      sections.forEach((s) => {
        const status = s.cleared ? '(達成済)' : '(未達成)';
        const condition = decompressCondition(s.conditionZipped || '') || '?'; // import/このファイル内?
        systemText += `- セクション${s.number}${status}: ${condition}\n`;
      });
      systemText += '======\n';
    }
    // ★ Gemini は messages 形式より、履歴を単純結合した方が良い場合もある
    //    ここでは履歴を getHistory で取得し、プロンプトに組み込む
    const historyForPrompt = gemini.getHistory(); // 現在のクライアント内部履歴を取得
    // 必要なら過去の履歴を要約に置き換えるなどの処理
    // const messages = [{role: "system", content: systemText}, ...]; // 旧OpenAI形式

    // ★ 過去のやり取りをプロンプトに含める形式 (Gemini推奨の一つ)
    let promptForGemini = systemText + '\n--- シナリオ情報 ---\n';
    if (window.currentScenario) {
      const summ = wd.scenarioSummaryEn?.trim() ? wd.scenarioSummaryEn : wd.scenarioSummary || '';
      promptForGemini += `概要(Summary): ${summ}\n`;
      if (wd.party?.length > 0) {
        // パーティ情報は英語の方が良いかもしれない
        const partyTxtEn = await buildPartyInsertionTextEn(wd.party); // このファイル内
        promptForGemini += partyTxtEn + '\n';
      }
    }
    promptForGemini += '--- これまでの展開 ---\n';
    // 履歴を追加 (要約考慮は別途必要)
    window.scenes.forEach((scn) => {
      // global scenes を参照
      if (scn.action?.content) promptForGemini += `プレイヤー: ${scn.action.content}\n`;
      promptForGemini += `GM: ${scn.content}\n`;
    });
    promptForGemini += '--- 今回の行動 ---\n';
    promptForGemini += `プレイヤー: ${playerInputJa}\n`; // 今回の行動は日本語
    promptForGemini += '--- 次のシーン ---\nGM:'; // GMの応答を促す

    // 3) Gemini API 呼び出し
    gemini.initializeHistory([]); // 履歴はプロンプトに含めたのでリセット
    console.log('[SceneManager] Calling Gemini for next scene...');
    const rawSceneJa = await gemini.generateContent(promptForGemini, modelId); // ★ インスタンスメソッド呼び出し
    if (!rawSceneJa?.trim()) throw new Error('APIから空の応答がありました。');

    // 4) 応答 (日本語シーン) の英語翻訳
    console.log('[SceneManager] Translating generated scene to English...');
    const sceneEn = await generateEnglishTranslation(rawSceneJa); // このファイル内 (Gemini使用)

    // 5) 新しいシーンデータをメモリとDBに保存
    const sceneId = `scene_${Date.now()}_${Math.random().toString(16).substring(2, 8)}`;
    const newSceneEntry = {
      scenarioId: window.currentScenarioId,
      type: 'scene',
      sceneId: sceneId,
      content: rawSceneJa,
      content_en: sceneEn,
      actionContent: playerInputJa,
      actionContent_en: playerInputEn,
      prompt: '', // 画像プロンプトは後で生成
    };
    const newEntryId = await addSceneEntry(newSceneEntry); // import
    newSceneEntry.entryId = newEntryId; // IDを付与
    console.log(`[SceneManager] New scene entry saved to DB (ID: ${newEntryId})`);

    const newSceneObj = {
      sceneId: sceneId,
      scenarioId: window.currentScenarioId,
      content: rawSceneJa,
      content_en: sceneEn,
      action: { content: playerInputJa, content_en: playerInputEn },
      images: [], // 画像はまだない
    };
    window.scenes.push(newSceneObj); // メモリに追加 (global)

    // 6) 画像プロンプト生成 (非同期で実行、完了を待たない)
    if (typeof generateImagePromptFromScene === 'function') {
      // import
      generateImagePromptFromScene(rawSceneJa)
        .then(async (imgPrompt) => {
          // ★ 非同期処理
          if (imgPrompt && newSceneEntry.entryId) {
            newSceneEntry.prompt = imgPrompt;
            await updateSceneEntry(newSceneEntry); // import
            console.log(`[SceneManager] Image prompt generated and saved for scene ${sceneId}`);
          }
        })
        .catch((e) => console.error('Error generating/saving image prompt:', e));
    } else {
      console.warn('generateImagePromptFromScene function not found.');
    }

    // 7) シナリオ更新日時を更新
    if (window.currentScenario && typeof updateScenario === 'function') {
      // import
      await updateScenario(window.currentScenario); // updatedAt は自動更新されるはず
      console.log('[SceneManager] Scenario updatedAt timestamp updated.');
    } else {
      console.error('Cannot update scenario timestamp.');
    }

    // 8) セクション達成チェック (非同期で実行、完了を待たない)
    if (typeof checkSectionClear === 'function') {
      // ★ checkSectionClearViaChatGPT から改名想定
      checkSectionClear(playerInputJa, rawSceneJa)
        .then(() => {
          // ★ 非同期処理
          if (typeof refreshEndingButtons === 'function') refreshEndingButtons(); // import
        })
        .catch((e) => console.error('Error during section clear check:', e));
    } else {
      console.warn('checkSectionClear function not found.');
    }

    // 9) シーン要約処理 (非同期で実行、完了を待たない)
    if (typeof handleSceneSummaries === 'function') {
      // このファイル内? import?
      handleSceneSummaries().catch((e) => console.error('Error handling summaries:', e)); // ★ 非同期処理
    } else {
      console.warn('handleSceneSummaries function not found.');
    }

    // 10) UI更新
    const playerInputEl = document.getElementById('player-input');
    if (!useItem && playerInputEl) playerInputEl.value = ''; // 入力欄クリア
    if (typeof updateSceneHistory === 'function') updateSceneHistory(); // import
    if (typeof showLastScene === 'function') showLastScene(); // import
    if (typeof renderItemChips === 'function') await renderItemChips(); // アイテムリスト更新 (import)

    // 11) 回答候補コンテナクリア＆自動生成
    const candidatesContainer = document.getElementById('action-candidates-container');
    if (candidatesContainer) candidatesContainer.innerHTML = '';
    const autoGenCbx = document.getElementById('auto-generate-candidates-checkbox');
    if (autoGenCbx?.checked && typeof onGenerateActionCandidates === 'function') {
      onGenerateActionCandidates();
    }
  } catch (e) {
    console.error('[SceneManager] シーン取得失敗:', e);
    showToast(`シーン取得失敗: ${e.message}`); // import
    // 必要ならエラー時の処理（例：プレイヤー入力欄を元に戻すなど）
  } finally {
    showLoadingModal(false); // このファイル内? import?
  }
}

// --- 翻訳系 (★ Gemini API 使用) ---

/** 英語パーティ情報文章化 (Gemini 翻訳) */
async function buildPartyInsertionTextEn(party) {
  if (!party?.length) return 'Party: None';
  let txtEn = 'Party Members:\n';
  const modelId = localStorage.getItem(PREFERRED_GEMINI_MODEL_LS_KEY) || 'gemini-1.5-flash-latest';
  const gemini = new GeminiApiClient();
  if (!gemini.isAvailable) return '(Translation API Error)';
  try {
    for (const p of party) {
      let nameEn = p.name || 'Unknown',
        typeEn = p.type || 'Unknown',
        detailJa = p.special || p.caption || '(No details)',
        detailEn = detailJa;
      if (containsJapanese(detailJa)) {
        try {
          const prompt = `Translate Japanese details to English:\nJA: ${detailJa}\nEN:`;
          gemini.initializeHistory([]);
          detailEn = await gemini.generateContent(prompt, modelId);
        } catch (e) {
          console.error('Party detail trans failed:', e);
          detailEn = detailJa + ' (trans-fail)';
        }
      }
      txtEn += `- Name: ${nameEn} (${typeEn})`;
      if (p.role === 'avatar') txtEn += ' [Avatar]';
      if (p.role === 'partner') txtEn += ' [Partner]';
      txtEn += `\n  Details: ${detailEn}\n`;
    }
  } catch (e) {
    console.error('Party EN text gen error:', e);
    txtEn += '(Error translating)';
  }
  return txtEn;
}

/** 英語翻訳 */
// ★ export する (sceneUI.js などから呼ばれるため)
export async function generateEnglishTranslation(japaneseText) {
  if (!japaneseText?.trim()) return '';
  console.log('[SceneManager] Translating to English...');
  const gemini = new GeminiApiClient(); // import
  if (!gemini.isAvailable) throw new Error('翻訳用APIキー未設定/無効');
  if (gemini.isStubMode) return '(Stub EN)';
  const modelId = localStorage.getItem(PREFERRED_GEMINI_MODEL_LS_KEY) || 'gemini-1.5-flash-latest';
  const prompt = `Translate Japanese to English. Output only the translation.\nJA:\n${japaneseText}\nEN:`;
  try {
    gemini.initializeHistory([]);
    return (await gemini.generateContent(prompt, modelId)).trim();
  } catch (e) {
    console.error('EN Trans fail:', e);
    throw e;
  }
}

/** 日本語翻訳 */
// ★ export する (もし他から使うなら)
export async function generateJapaneseTranslation(englishText) {
  if (!englishText?.trim()) return '';
  console.log('[SceneManager] Translating to Japanese...');
  const gemini = new GeminiApiClient(); // import
  if (!gemini.isAvailable) throw new Error('翻訳用APIキー未設定/無効');
  if (gemini.isStubMode) return '(Stub JA)';
  const modelId = localStorage.getItem(PREFERRED_GEMINI_MODEL_LS_KEY) || 'gemini-1.5-flash-latest';
  const prompt = `Translate English to Japanese. Output only the translation.\nEN:\n${englishText}\nJA:`;
  try {
    gemini.initializeHistory([]);
    return (await gemini.generateContent(prompt, modelId)).trim();
  } catch (e) {
    console.error('JA Trans fail:', e);
    throw e;
  }
}

// --- セクション達成チェック (★ Gemini API 使用) ---

/** セクションクリア判定 */
// ★ export する (もし他から使うなら)
// async function checkSectionClearViaChatGPT(latestAction, latestScene) { // 旧名
export async function checkSectionClear(latestActionJa, latestSceneJa) {
  console.log('[SceneManager] Checking section clear status...');
  const wd = window.currentScenario?.wizardData; // global
  if (!wd?.sections) return;
  const sorted = [...wd.sections].sort((a, b) => (a.number || 0) - (b.number || 0));
  const firstUncleared = sorted.find((s) => !s.cleared);
  if (!firstUncleared) return; // 全クリア済み

  const gemini = new GeminiApiClient(); // import
  if (!gemini.isAvailable) {
    console.warn('Cannot check section clear: Gemini API key missing/invalid.');
    return;
  }
  if (gemini.isStubMode) {
    console.warn('STUB MODE: Skipping section clear check.');
    return;
  }

  const modelId = localStorage.getItem(PREFERRED_GEMINI_MODEL_LS_KEY) || 'gemini-1.5-flash-latest';
  const conditionTextJa = decompressCondition(firstUncleared.conditionZipped || '') || '?'; // import/このファイル内?
  const scenarioSummary = wd.scenarioSummary || '(概要なし)';

  // ★ Gemini に YES/NO で答えさせるプロンプト
  const prompt = `あなたはTRPGの審判AIです。以下の情報に基づき、提示された「達成条件」がプレイヤーの行動や状況によって満たされたかどうかを判断し、**YESかNOのみ**で答えてください。\n\nシナリオ概要:\n${scenarioSummary}\n\n達成条件(セクション${firstUncleared.number}):\n「${conditionTextJa}」\n\n最新のプレイヤー行動:\n${latestActionJa || '(行動なし)'}\n\n最新のシーン状況:\n${latestSceneJa || '(シーンなし)'}\n\n質問: この達成条件は満たされましたか？ (YES/NO)`;

  try {
    gemini.initializeHistory([]);
    console.log('[SceneManager] Calling Gemini for section clear check...');
    const answer = (await gemini.generateContent(prompt, modelId)).trim().toUpperCase();
    console.log(`[SceneManager] Section clear check result: ${answer}`);

    if (answer.startsWith('YES')) {
      console.log(`[SceneManager] Section ${firstUncleared.number} cleared!`);
      firstUncleared.cleared = true;
      // ★ currentScenario はグローバルなので直接更新して良いか？ 不変性を保つ方が安全
      // window.currentScenario.wizardData.sections = wd.sections; // 直接変更は避ける
      // 代わりに wizardData 全体を更新
      const updatedWizardData = { ...wd, sections: sorted }; // ソート済みを反映
      const scenarioToUpdate = { ...window.currentScenario, wizardData: updatedWizardData };
      window.currentScenario = scenarioToUpdate; // メモリ更新

      await updateScenario(scenarioToUpdate); // import (DB更新)
      showToast(`セクション${firstUncleared.number} クリア！`); // import

      if (typeof refreshEndingButtons === 'function') refreshEndingButtons(); // エンディングボタン更新 (import)
    } else {
      console.log(`[SceneManager] Section ${firstUncleared.number} not cleared yet.`);
    }
  } catch (err) {
    console.error('[SceneManager] セクション判定API失敗:', err);
    showToast(`目標達成判定エラー: ${err.message}`); // import
  }
}

// --- 要約作成 (★ Gemini API 使用) ---

/** シーン要約処理 */
// ★ export する (もし他から使うなら)
export async function handleSceneSummaries() {
  console.log('[SceneManager] Handling scene summaries...');
  // ★ window.scenes を参照 (global)
  const actionCount = window.scenes.filter((s) => s.action?.content?.trim()).length;
  if (actionCount < 15) return; // 15シーン未満はまだ要約しない

  const chunkIndex = Math.floor((actionCount - 15) / 10); // 10シーンごとのチャンク
  // ★ window.sceneSummaries を参照 (global)
  if (chunkIndex >= 0 && !window.sceneSummaries[chunkIndex]) {
    console.log(`[SceneManager] Generating summary for chunk ${chunkIndex}...`);
    const startAction = chunkIndex * 10 + 1;
    const endAction = (chunkIndex + 1) * 10;

    let gatheredTextJa = '';
    let gatheredTextEn = '';
    let aCounter = 0;
    for (const scn of window.scenes) {
      if (scn.action?.content?.trim()) aCounter++;
      if (aCounter >= startAction && aCounter <= endAction) {
        if (scn.action?.content?.trim()) gatheredTextJa += `\nP:${scn.action.content}`;
        gatheredTextJa += `\nS:${scn.content}`;
        // 英語データもあれば結合 (なければ日本語のみ)
        if (scn.action?.content_en?.trim()) gatheredTextEn += `\nP:${scn.action.content_en}`;
        else if (scn.action?.content?.trim()) gatheredTextEn += `\nP:${scn.action.content}`; // JA fallback
        if (scn.content_en?.trim()) gatheredTextEn += `\nS:${scn.content_en}`;
        else gatheredTextEn += `\nS:${scn.content}`; // JA fallback
      }
    }

    try {
      // ★ Gemini で要約生成 (英語と日本語)
      const enSummary = await generateSummaryWithLimit(gatheredTextEn, 5, 'en'); // 下で定義
      await sleep(1000); // 待機
      const jaSummary = await generateSummaryWithLimit(gatheredTextJa, 5, 'ja'); // 下で定義

      // 要約をDBとメモリに保存
      const sumRec = { chunkIndex, content_en: enSummary, content_ja: jaSummary };
      await addSceneSummaryRecord(sumRec); // import
      window.sceneSummaries[chunkIndex] = { en: enSummary, ja: jaSummary }; // global
      console.log(`[SceneManager] Summary for chunk ${chunkIndex} generated and saved.`);
    } catch (e) {
      console.error(`Failed to generate/save summary for chunk ${chunkIndex}:`, e);
      showToast(`要約生成エラー (Chunk ${chunkIndex})`); // import
    }
  } else if (chunkIndex >= 0) {
    console.log(`[SceneManager] Summary for chunk ${chunkIndex} already exists.`);
  }
}

/** 指定行数でテキスト要約 (★ Gemini API 使用) */
async function generateSummaryWithLimit(text, lines = 5, lang = 'en') {
  if (!text?.trim()) return '';
  console.log(`[SceneManager] Generating ${lang} summary (${lines} lines)...`);
  const gemini = new GeminiApiClient(); // import
  if (!gemini.isAvailable) throw new Error('要約APIキー未設定/無効');
  if (gemini.isStubMode) return `(Stub ${lang} summary ${lines} lines)`;

  const modelId = localStorage.getItem(PREFERRED_GEMINI_MODEL_LS_KEY) || 'gemini-1.5-flash-latest';
  let systemPrompt = `You are a summarizer. Output language must be English. Summarize in about ${lines} lines.`;
  let userPrompt = `Summarize the following game progress text concisely in about ${lines} lines of English. Focus on key events and outcomes:\n---\n${text}\n---\nSummary:`;
  if (lang === 'ja') {
    systemPrompt = `あなたは優秀な要約者です。必ず日本語で回答してください。${lines}行程度で要約してください。`;
    userPrompt = `以下のゲーム進行テキストを日本語で${lines}行程度に要約してください。重要な出来事や結果に焦点を当ててください:\n---\n${text}\n---\n要約:`;
  }

  try {
    gemini.initializeHistory([]);
    const summary = await gemini.generateContent(userPrompt, modelId, systemPrompt); // ★ systemPrompt も渡せるように Client 側も修正が必要かも
    return summary.trim();
  } catch (err) {
    console.error(`要約(${lang})失敗:`, err);
    throw err;
  } // エラー再スロー
}

// --- 画像プロンプト生成 (★ Gemini API 使用) ---

/** シーンテキストから画像生成用プロンプト作成 */
// ★ export (sceneUI.js などから使うため)
export async function generateImagePromptFromScene(sceneTextJa) {
  if (!sceneTextJa?.trim()) return '';
  console.log('[SceneManager] Generating image prompt from scene text...');
  const gemini = new GeminiApiClient(); // import
  if (!gemini.isAvailable) {
    console.warn('Cannot generate image prompt: Gemini key missing/invalid');
    return '';
  } // エラーにせず空を返す
  if (gemini.isStubMode) {
    return 'anime style, stub scene';
  }

  const modelId = localStorage.getItem(PREFERRED_GEMINI_MODEL_LS_KEY) || 'gemini-1.5-flash-latest';
  // ★ プロンプトを改善 (よりキーワード抽出を意識)
  const prompt = `以下の日本語のシーン描写から、画像生成に適した英語のキーワードを抽出してください。情景、登場人物の外見や感情、重要なオブジェクトなどをカンマ区切りで列挙してください。\nシーン:\n${sceneTextJa}\n\nImage Generation Keywords (English):`;

  try {
    gemini.initializeHistory([]);
    const keywords = await gemini.generateContent(prompt, modelId);
    // カンマ区切りにする処理を改善
    return keywords
      .split(/[\n,、。]/) // 改行、カンマ、句読点で区切る
      .map((k) => k.trim()) // 前後の空白削除
      .filter((k) => k) // 空要素削除
      .join(', '); // カンマとスペースで結合
  } catch (e) {
    console.error('Img prompt gen fail:', e);
    showToast(`画像プロンプト生成エラー: ${e.message}`);
    return '';
  } // import
}

// --- カード情報抽出 (★ Gemini API 使用) ---

/** 最新シーンからカード情報を抽出 */
// ★ export (sceneUI.js の「カード取得」ボタンなどで使う想定)
export async function getLastSceneSummary() {
  // 関数名は Summary だが実質カード情報抽出
  console.log('[SceneManager] Extracting card info from last scene...');
  // ★ window.scenes を参照 (global)
  const lastSceneEntry = window.scenes?.[window.scenes.length - 1];
  if (!lastSceneEntry?.content) {
    showToast('最新シーンなし');
    return '(抽出対象シーンなし)';
  } // import

  const gemini = new GeminiApiClient(); // import
  if (!gemini.isAvailable) {
    showToast('Gemini APIキー未設定/無効');
    return '(APIキーエラー)';
  } // import
  if (gemini.isStubMode) {
    return '【名前】スタブカード\n【タイプ】スタブ\n【外見】ダミーデータ';
  }

  const modelId = localStorage.getItem(PREFERRED_GEMINI_MODEL_LS_KEY) || 'gemini-1.5-flash-latest';
  const text = lastSceneEntry.content;
  // ★ Gemini にJSON風の出力をさせるプロンプト
  const prompt = `あなたはTRPGの情報を整理するAIです。以下のシーンテキストから、ゲーム内で「エレメントカード」として登録できそうな重要な【アイテム】または【キャラクター】（人物・モンスター）を**1つだけ**選び出し、以下の形式で情報を抽出・記述してください。対象が見つからない場合は「抽出対象なし」とだけ答えてください。\n\n【名前】: （抽出した名前）\n【タイプ】: （アイテム or キャラクター or モンスター のいずれか）\n【外見・説明】: （2,3行程度の簡潔な説明）\n\nシーンテキスト:\n---\n${text}\n---\n\n抽出結果:`;

  try {
    gemini.initializeHistory([]);
    const result = await gemini.generateContent(prompt, modelId);
    console.log('[SceneManager] Card info extraction result:', result);
    if (result.includes('抽出対象なし')) return '(対象なし)';
    return result.trim(); // そのまま返す (UI側でパース・表示)
  } catch (e) {
    console.error('カード情報抽出失敗:', e);
    showToast(`カード情報抽出エラー: ${e.message}`); // import
    return '(抽出エラー)';
  }
}

// --- ヘルパー関数 ---
/** 指定ミリ秒待機 */
const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
/** 日本語を含むかチェック */
export function containsJapanese(text) {
  if (!text) return false;
  return /[ぁ-んァ-ン一-龯]/.test(text);
}
/** 条件展開 (pako使用) */
export function decompressCondition(zippedBase64) {
  if (!zippedBase64) return '(不明)';
  try {
    const bin = atob(zippedBase64);
    const uint8 = new Uint8Array([...bin].map((c) => c.charCodeAt(0)));
    const inf = pako.inflate(uint8);
    return new TextDecoder().decode(inf);
  } catch (e) {
    console.error('decompress失敗:', e);
    return '(解凍エラー)';
  }
}

/** 全セクションがクリア済みかどうか */
export function areAllSectionsCleared() {
  const wd = window.currentScenario?.wizardData || {}; // global
  const sections = wd.sections || [];

  if (!sections || !sections.length) return false;
  return sections.every((s) => s.cleared);
}

/** エンディングボタン表示切り替え */
export function refreshEndingButtons() {
  const endingBtn = document.getElementById('ending-button');
  const clearEndingBtn = document.getElementById('clear-ending-button');
  const wd = window.currentScenario?.wizardData || {}; // global
  const sections = wd.sections || [];
  console.log(sections);

  if (!endingBtn || !clearEndingBtn) return;

  if (!sections || sections.length === 0) {
    endingBtn.style.display = 'none';
    clearEndingBtn.style.display = 'none';
    return;
  }

  // いずれか1つでもクリア済みか？
  const anyCleared = sections.some((sec) => sec.cleared);
  // 全クリアか？
  const allCleared = areAllSectionsCleared();

  if (!anyCleared) {
    endingBtn.style.display = 'none';
    clearEndingBtn.style.display = 'none';
    return;
  }
  if (allCleared) {
    endingBtn.style.display = 'none';
    clearEndingBtn.style.display = 'inline-block';
  } else {
    endingBtn.style.display = 'inline-block';
    clearEndingBtn.style.display = 'none';
  }
}

// --- ファイル読み込み完了ログ ---
console.log('[SceneManager] sceneManager.js loaded.');

// ★ このファイル内の関数で、他のファイルから呼び出されるものは export する
// 例: export { loadScenarioData, getNextScene, checkSectionClear, handleSceneSummaries, ... };
---
sceneMain.js
/********************************
 * sceneMain.js
 *  - ページ全体の初期化・イベント登録
 *  - 複数シナリオ対応
 *  - ユニークスロット方式ロード対応
 ********************************/
import { loadScenarioData, getNextScene } from './sceneManager.js';
import { onCancelFetch, intUI } from './sceneUI.js';
import { initBackground } from './background.js';
import { getUniversalSave, getScenarioById } from './indexedDB.js';
import { doLoadScenarioFromSlot } from './universalSaveLoad.js';

window.addEventListener('DOMContentLoaded', () => {
  intUI();
  const autoCbx = document.getElementById('auto-generate-candidates-checkbox');
  if (autoCbx) {
    // 初期状態読み込み
    autoCbx.checked = localStorage.getItem('autoGenerateCandidates') === 'true';

    // 変更時に保存
    autoCbx.addEventListener('change', () => {
      localStorage.setItem('autoGenerateCandidates', autoCbx.checked);
    });
  }

  // シーン生成ボタン
  const nextSceneBtn = document.getElementById('next-scene');
  if (nextSceneBtn) {
    nextSceneBtn.addEventListener('click', () => {
      getNextScene();
    });
  }

  // 戻るボタン（暫定で history.back()）
  const backToMenuBtn = document.getElementById('back-to-menu');
  if (backToMenuBtn) {
    backToMenuBtn.addEventListener('click', () => {
      history.back();
    });
  }
});

window.onload = async () => {
  // 1) IndexedDB初期化
  await initIndexedDB();

  // 3) URLパラメータを解析
  const urlParams = new URLSearchParams(window.location.search);

  // ▼ まず「slotIndex=.. & action=load」があれば、ユニークスロットからロード
  const slotIndexStr = urlParams.get('slotIndex');
  const action = urlParams.get('action');

  if (slotIndexStr && action === 'load') {
    // ユニークスロットロード: universalSaves ストアから取得
    const sIdx = parseInt(slotIndexStr, 10);
    const slotRec = await getUniversalSave(sIdx);
    if (!slotRec || !slotRec.data) {
      alert('指定されたスロットが存在しない、または空です。ロードできません。');
      return;
    }
    const scenarioIdToLoad = slotRec.data.scenarioId;
    if (!scenarioIdToLoad) {
      alert('スロットにシナリオ情報がありません。ロードできません。');
      return;
    }

    // DBにシナリオがあるか確認
    const scObj = await getScenarioById(scenarioIdToLoad);
    if (!scObj) {
      alert('スロット内のシナリオがDBに存在しません。ロード不可。');
      return;
    }

    // シナリオIDを切り替え
    window.currentScenarioId = scenarioIdToLoad;

    // doLoadScenarioFromSlot() でDBのシーン履歴を上書きし、画面を更新
    await doLoadScenarioFromSlot(slotRec.data);

    // UI切り替え: inputセクション非表示、ゲーム画面表示
    const inputSec = document.querySelector('.input-section');
    if (inputSec) inputSec.style.display = 'none';
    const gameSec = document.querySelector('.game-section');
    if (gameSec) gameSec.style.display = 'block'; // ★★★ URL書き換え処理を追加 ★★★

    try {
      const newUrl = new URL(window.location.href);
      newUrl.searchParams.delete('slotIndex'); // slotIndex パラメータを削除
      newUrl.searchParams.delete('action'); // action パラメータを削除
      newUrl.searchParams.set('scenarioId', scenarioIdToLoad.toString()); // scenarioId パラメータを追加
      history.replaceState(null, '', newUrl.toString()); // URLを書き換え (リロードなし)
      console.log(`[SceneMain] URL rewritten to: ${newUrl.toString()}`);
    } catch (e) {
      console.error('[SceneMain] Failed to rewrite URL:', e);
      // URL書き換えに失敗しても処理は続行する
    }
    alert(`スロット${sIdx}をロードし、シナリオID ${scenarioIdToLoad} を表示しました。`);
  } else {
    // ▼ それ以外は、従来の「?scenarioId=」をチェック
    const scenarioIdStr = urlParams.get('scenarioId');
    const scenarioId = scenarioIdStr ? parseInt(scenarioIdStr, 10) : null;
    window.currentScenarioId = scenarioId || null;

    // 4) シナリオIDがあれば、DBから読み込んで画面を構築
    if (window.currentScenarioId) {
      // 旧の「入力セクション」は非表示、ゲーム画面のみ表示
      const inputSec = document.querySelector('.input-section');
      if (inputSec) inputSec.style.display = 'none';

      const gameSec = document.querySelector('.game-section');
      if (gameSec) gameSec.style.display = 'block';

      // sceneManager.js 側の loadScenarioData() でシナリオ＆履歴を取得して表示
      await loadScenarioData(window.currentScenarioId);
      // updateSceneHistory(); // 必要なら
    }
  }
  // -------- ネタバレ関連 --------
  const spoilerModal = document.getElementById('spoiler-modal');
  const spoilerButton = document.getElementById('spoiler-button');
  const closeSpoilerModalBtn = document.getElementById('close-spoiler-modal');
  if (spoilerButton) {
    spoilerButton.addEventListener('click', () => {
      spoilerModal.style.display = 'flex';
    });
  }
  if (closeSpoilerModalBtn) {
    closeSpoilerModalBtn.addEventListener('click', () => {
      spoilerModal.style.display = 'none';
    });
  }

  // 画像生成 (自動)
  const autoGenBtn = document.getElementById('image-auto-generate-button');
  if (autoGenBtn) {
    autoGenBtn.addEventListener('click', () => {
      generateImageFromCurrentScene();
    });
  }

  // 画像生成 (カスタム)
  const promptModalBtn = document.getElementById('image-prompt-modal-button');
  if (promptModalBtn) {
    promptModalBtn.addEventListener('click', () => {
      openImagePromptModal();
    });
  }

  // カスタム画像生成 決定
  const customGenBtn = document.getElementById('image-custom-generate-button');
  if (customGenBtn) {
    customGenBtn.addEventListener('click', () => {
      onCustomImageGenerate();
    });
  }

  // カスタム画像生成 キャンセル
  const customCancelBtn = document.getElementById('image-custom-cancel-button');
  if (customCancelBtn) {
    customCancelBtn.addEventListener('click', () => {
      closeImagePromptModal();
    });
  }

  // リクエストキャンセル
  const cancelRequestBtn = document.getElementById('cancel-request-button');
  if (cancelRequestBtn) {
    cancelRequestBtn.addEventListener('click', onCancelFetch);
  }

  // メニューに戻るボタン
  const backMenuBtn = document.getElementById('back-to-menu');
  if (backMenuBtn) {
    backMenuBtn.addEventListener('click', () => {
      window.location.href = 'index.html';
    });
  }

  // ▼ 全クリアボタン
  const clearAllSlotsBtn = document.getElementById('clear-all-slots-button');
  if (clearAllSlotsBtn) {
    clearAllSlotsBtn.addEventListener('click', onClearAllSlots);
  }
  // 背景の初期化
  await initBackground('scenario');
};
---
sceneExtras.js
/********************************
 * sceneExtras.js
 * エンディング、エンティティ、パーティ表示など補助機能
 * ★ API 呼び出しを Gemini Text / Stability Image に変更
 * ★ ES Modules 形式、依存関係を import、関数を export
 * ★ 省略なし
 ********************************/

// --- モジュールインポート ---
import { GeminiApiClient } from './geminiApiClient.js';
import { StabilityApiClient } from './stabilityApiClient.js';
import { open as multiModalOpen } from './multiModal.js';
import { showToast } from './common.js';
import {
    getEnding,
    saveEnding,
    deleteEnding, // エンディング DB
    getEntitiesByScenarioId,
    addEntity,
    updateEntity,
    deleteEntity, // エンティティ DB
    updateScenario, // セクション状態更新で必要
    // loadCharacterDataFromIndexedDB, // 不要？
} from './indexedDB.js';
// ★ sceneManager.js などから import する想定の関数 (要確認・修正)
import {
    decompressCondition, // common.js? sceneManager.js?
    generateEnglishTranslation, // sceneManager.js? (or このファイル内で定義)
    containsJapanese, // sceneManager.js? (or このファイル内で定義)
    // updateSceneHistory, showLastScene // refreshEntitiesAndChips 内で必要なら
} from './sceneManager.js'; // ★仮パス
import {
    showLoadingModal,
    renderItemChips
} from './sceneUI.js';

// DOMPurify はグローバルにある想定

// --- localStorage キー ---
const GEMINI_API_KEY_LS_KEY = 'geminiApiKey';
const STABILITY_API_KEY_LS_KEY = 'stabilityApiKey';
const PREFERRED_GEMINI_MODEL_LS_KEY = 'preferredGeminiModel';

/* =============================
 * エンディング関連
============================= */

/**
 * エンディングモーダルを開く (既存データがあれば表示、なければ生成)
 * @param {'clear' | 'bad'} type エンディング種別
 * ★ export する (sceneUI.js などから呼び出すため)
 */
export async function showEndingModal(type) {
    // ★ グローバル変数 window.currentScenario を参照
    const scenarioId = window.currentScenario?.scenarioId;
    if (!scenarioId) {
        alert('シナリオ未選択');
        return;
    }

    console.log(`[Extras] Showing ending modal (type: ${type}) for scenario ${scenarioId}`);
    showLoadingModal(true); // ローディング開始
    try {
        const existing = await getEnding(scenarioId, type); // import DB関数
        if (existing) {
            console.log('[Extras] Existing ending found.');
            openEndingModal(type, existing.story); // このファイル内で定義
        } else {
            console.log('[Extras] No existing ending found, generating new one...');
            const newStory = await generateEndingStory(type); // このファイル内で定義 (Gemini使用)
            if (!newStory || newStory.startsWith('(')) {
                // エラーメッセージでないかチェック
                showToast('エンディングの生成に失敗しました。'); // import
                return;
            }
            await saveEnding(scenarioId, type, newStory); // import DB関数
            console.log('[Extras] New ending generated and saved.');
            openEndingModal(type, newStory);
        }
    } catch (error) {
        console.error(`[Extras] Error showing/generating ending (type: ${type}):`, error);
        showToast(`エンディング処理エラー: ${error.message}`); // import
    } finally {
        showLoadingModal(false); // ローディング終了
    }
}

/**
 * multiModal を使ってエンディングモーダルを表示
 * @param {'clear' | 'bad'} type
 * @param {string} story
 */
function openEndingModal(type, story) {
    console.log(`[Extras] Opening multiModal for ending (type: ${type})`);
    const titleText = type === 'clear' ? 'クリアエンディング' : 'エンディング';
    // ★ import した multiModalOpen を使用
    multiModalOpen({
        id: `ending-modal-${type}`, // IDにタイプを含める
        title: titleText,
        contentHtml: `<pre id="ending-modal-story-${type}" style="white-space:pre-wrap; max-height: 70vh; overflow-y: auto; text-align: left; padding: 10px; background: rgba(0,0,0,0.2); border-radius: 3px;">${DOMPurify.sanitize(
            story
        )}</pre>`, // global DOMPurify
        showCloseButton: true,
        closeOnOutsideClick: true,
        appearanceType: 'center',
        additionalButtons: [{ label: '再生成', onClick: () => onClickRegenerateEndingMulti(type) }], // このファイル内で定義
        cancelLabel: '閉じる',
    });
}

/**
 * エンディング再生成ボタンの処理
 * @param {'clear' | 'bad'} type
 */
async function onClickRegenerateEndingMulti(type) {
    // ★ グローバル変数 window.currentScenario を参照
    const scenarioId = window.currentScenario?.scenarioId;
    if (!scenarioId) {
        alert('シナリオ未選択');
        return;
    }
    console.log(`[Extras] Regenerating ending (type: ${type}) for scenario ${scenarioId}`);

    // 現在開いているモーダルを閉じる (閉じないと再生成後に2つ開く)
    const currentModal = window.multiModal?.getInstanceById?.(`ending-modal-${type}`); // multiModal側の実装依存
    if (currentModal) currentModal.close();

    showLoadingModal(true);
    try {
        await deleteEnding(scenarioId, type); // 既存を削除 (import DB関数)
        const newStory = await generateEndingStory(type); // 再生成 (Gemini使用)
        if (!newStory || newStory.startsWith('(')) {
            showToast('エンディングの再生成失敗');
            return;
        } // import
        await saveEnding(scenarioId, type, newStory); // 保存 (import DB関数)
        console.log('[Extras] Ending regenerated and saved.');
        openEndingModal(type, newStory); // 新しい内容でモーダルを開く
    } catch (error) {
        console.error(`[Extras] Error regenerating ending (type: ${type}):`, error);
        showToast(`再生成エラー: ${error.message}`); // import
    } finally {
        showLoadingModal(false);
    }
}

/**
 * エンディングストーリーを生成 (★ Gemini API 使用)
 * @param {'clear' | 'bad'} type
 * @returns {Promise<string>} 生成されたストーリー or エラー時は空文字/エラーメッセージ
 */
async function generateEndingStory(type) {
    console.log(`[Extras] Generating ending story (type: ${type})...`);
    const gemini = new GeminiApiClient(); // import
    if (!gemini.isAvailable) {
        alert('Gemini APIキー未設定/無効');
        return '(APIキーエラー)';
    } // import alert?
    if (gemini.isStubMode) {
        return `スタブの${type === 'clear' ? 'クリア' : 'バッド'}エンディングです。`;
    }

    const scenario = window.currentScenario; // global
    if (!scenario) {
        alert('シナリオデータなし');
        return '(シナリオエラー)';
    }
    const wd = scenario.wizardData || {};
    const scenarioSummary = wd.scenarioSummary || '(概要なし)';
    const party = wd.party || [];
    const lastScenes = [...window.scenes].slice(-10); // global
    const combinedSceneText = lastScenes
        .map((s) => `P: ${s.action?.content || '(行動なし)'}\nGM: ${s.content || '(描写なし)'}`)
        .join('\n---\n');
    let sectionText = '(セクション情報なし)';
    if (wd.sections && typeof decompressCondition === 'function') {
        // import
        sectionText = wd.sections
            .map(
                (s) =>
                    `・S${s.number}(${s.cleared ? '済' : '未'}): ${decompressCondition(
                        s.conditionZipped || ''
                    )}`
            )
            .join('\n');
    }
    const endTypePrompt =
        type === 'clear' ? '感動的でハッピーな結末' : '後味の悪い、または悲劇的なバッドエンド';

    // ★ Gemini 向けプロンプト (構造化を指示)
    const prompt = `あなたはTRPGのエンディングを作成するAIです。以下の情報に基づき、指定された結末を迎えるエンディングストーリーを日本語で生成してください。
出力は以下の5部構成で記述してください:
1.【シナリオ概要の再確認】: 提供された概要を簡潔に。
2.【パーティメンバーの結末】: 各メンバーがどうなったか、個別に描写。
3.【物語の結末(${endTypePrompt})】: 指定された結末に至る経緯と最終的な状況を描写。
4.【セクション達成状況】: 提供されたセクション情報への言及（任意）。
5.【エピローグ】: 物語全体の締めくくりや、その後の世界について一言。

---
シナリオ概要: ${scenarioSummary}
パーティ情報: ${buildPartyInsertionText(party)}
直近の展開(最大10シーン):
${combinedSceneText || '(なし)'}
セクション情報:
${sectionText}
---

エンディングストーリー(${endTypePrompt}):`;

    const modelId =
        localStorage.getItem(PREFERRED_GEMINI_MODEL_LS_KEY) || 'gemini-1.5-flash-latest'; // localStorage参照

    try {
        showLoadingModal(true); // import/このファイル内?
        gemini.initializeHistory([]);
        const story = await gemini.generateContent(prompt, modelId);
        console.log('[Extras] Ending story generated.');
        return story.trim() || '(エンディング生成失敗)';
    } catch (err) {
        console.error('エンディング生成失敗:', err);
        showToast(`エンディング生成エラー: ${err.message}`); // import
        return '(エンディング生成エラー)';
    } finally {
        showLoadingModal(false);
    }
}

/** 全セクションクリア済みか判定 */
// ★ sceneManager.js に移設して import する方が良い
// function areAllSectionsCleared() { /* ... */ }

/** エンディングボタン表示切り替え */
// ★ export する (sceneUI.js or sceneMain.js から呼ばれる想定)
export function refreshEndingButtons() {
    const endingBtn = document.getElementById('ending-button');
    const clearEndingBtn = document.getElementById('clear-ending-button');
    if (!endingBtn || !clearEndingBtn) {
        console.warn('Ending buttons not found.');
        return;
    }

    // ★ window.currentScenario.wizardData を参照
    const sections = window.currentScenario?.wizardData?.sections || [];
    if (!sections.length) {
        endingBtn.style.display = 'none';
        clearEndingBtn.style.display = 'none';
        return;
    }

    // ★ areAllSectionsCleared は sceneManager.js から import する想定
    if (typeof areAllSectionsCleared === 'function') {
        const allCleared = areAllSectionsCleared(); // import
        if (allCleared) {
            endingBtn.style.display = 'none';
            clearEndingBtn.style.display = 'inline-block';
        } else {
            endingBtn.style.display = 'inline-block';
            clearEndingBtn.style.display = 'none';
        }
        // ★ セクションが一つもクリアされていない場合も Bad End ボタンを表示する？ 仕様による
        // const anyCleared = sections.some(sec => sec.cleared);
        // if (!anyCleared) endingBtn.style.display = "none";
    } else {
        console.warn('areAllSectionsCleared function not found.');
    }
}

/* =============================
 * エンティティ(アイテム/キャラ)関連
============================= */

/** 情報モーダルを開いて一覧表示 */
// ★ export する (sceneUI.js などから呼び出すため)
export async function openEntitiesModal() {
    console.log('[Extras] Opening entities modal...');
    multiModalOpen({
        // import
        id: 'entities-info-modal',
        title: '情報 (アイテム / 登場人物)',
        contentHtml: `
            <div style="margin-bottom:15px; padding-bottom: 10px; border-bottom: 1px dashed #666;">
                 <button id="entity-update-button" title="現在のシナリオ全体からアイテムや登場人物をAIが抽出・更新します"><span class="iconmoon icon-search"></span> シナリオから抽出(AI)</button>
                 <p id="entity-candidate-list" style="font-size:0.9em; color:#ccc; min-height: 1em; margin-top: 5px;"></p>
            </div>
            <div id="entity-list-container" style="max-height: 60vh; overflow-y: auto; text-align: left;">
                 <div class="loading">読込中...</div>
            </div>`,
        showCloseButton: true,
        appearanceType: 'center',
        closeOnOutsideClick: true,
        cancelLabel: '閉じる',
        onOpen: async () => {
            console.log('[Extras] Entities modal opened. Rendering list...');
            await renderEntitiesList(); // このファイル内で定義
            const updateBtn = document.getElementById('entity-update-button');
            if (updateBtn) {
                updateBtn.addEventListener('click', onUpdateEntitiesFromAllScenes); // このファイル内で定義 (Gemini使用)
            }
        },
    });
}

/** エンティティリストを再描画 */
// ★ export する (openEntitiesModal や削除/生成後に呼ばれるため)
export async function renderEntitiesList() {
    const listDiv = document.getElementById('entity-list-container');
    if (!listDiv) {
        console.error('Entity list container not found.');
        return;
    }
    listDiv.innerHTML = `<div class="loading">読込中...</div>`;

    const scenarioId = window.currentScenarioId; // global
    if (!scenarioId) {
        listDiv.textContent = 'シナリオ未選択';
        return;
    }

    try {
        const allEnts = await getEntitiesByScenarioId(scenarioId); // import DB関数
        const items = allEnts
            .filter((e) => e.category === 'item')
            .sort((a, b) => (a.name || '').localeCompare(b.name || ''));
        const chars = allEnts
            .filter((e) => e.category === 'character')
            .sort((a, b) => (a.name || '').localeCompare(b.name || ''));
        listDiv.innerHTML = ''; // クリア

        if (items.length > 0) {
            const h3 = document.createElement('h3');
            h3.textContent = 'アイテム';
            listDiv.appendChild(h3);
            items.forEach((ent, i) => listDiv.appendChild(createEntityRow(ent, i % 2 !== 0)));
        }
        if (chars.length > 0) {
            const h3 = document.createElement('h3');
            h3.textContent = 'キャラクター・モンスター';
            listDiv.appendChild(h3);
            chars.forEach((ent, i) => listDiv.appendChild(createEntityRow(ent, i % 2 !== 0)));
        }
        if (items.length === 0 && chars.length === 0) {
            listDiv.textContent = 'アイテムや登場人物はまだ記録されていません。';
        }
        console.log(`[Extras] Rendered ${items.length} items and ${chars.length} characters.`);
    } catch (e) {
        console.error('Failed to render entities list:', e);
        listDiv.innerHTML = `<p class="error">リスト表示エラー</p>`;
        showToast(`エンティティリスト表示エラー: ${e.message}`); // import
    }
}

/** エンティティ情報1行分のDOM要素を作成 */
function createEntityRow(entity, isOdd) {
    // (中身は変更なし - 省略せず記述)
    const row = document.createElement('div');
    row.className = 'info-row';
    row.style.marginBottom = '20px';
    const topWrapper = document.createElement('div');
    topWrapper.style.justifyContent = 'space-between';
    topWrapper.style.alignItems = 'center';
    topWrapper.style.overflow = 'hidden';
    if (entity.imageData) {
        const thumb = document.createElement('img');
        thumb.src = entity.imageData;
        thumb.alt = entity.name;
        thumb.style.height = '150px';
        thumb.style.objectFit = 'contain';
        if (isOdd) {
            thumb.style.float = 'left';
            thumb.style.paddingRight = '20px';
        } else {
            thumb.style.float = 'right';
            thumb.style.paddingLeft = '20px';
        }
        thumb.style.borderRadius = '50%';
        thumb.style.shapeOutside = 'circle(50%)';
        topWrapper.appendChild(thumb);
    }
    const infoSpan = document.createElement('span');
    let displayName = entity.name;
    if (entity.category === 'item' && entity.acquired) {
        displayName += '【入手済】';
    }
    infoSpan.innerHTML = `<h4>${DOMPurify.sanitize(displayName)}</h4> ${DOMPurify.sanitize(
        entity.description
    )}`;
    topWrapper.appendChild(infoSpan);
    row.appendChild(topWrapper);
    const bottomWrapper = document.createElement('div');
    bottomWrapper.className = 'l-flexbox';
    const wandBtn = document.createElement('button');
    wandBtn.className = 'scene-menu-button';
    wandBtn.innerHTML = '<div class="iconmoon icon-dots-three-horizontal"></div>';
    bottomWrapper.appendChild(wandBtn);
    const dropdown = document.createElement('div');
    dropdown.className = 'scene-dropdown-menu';
    dropdown.style.display = 'none';
    dropdown.innerHTML = `<button class="dropdown-item entity-generate"><div class="iconmoon icon-picture"></div>画像生成</button><button class="dropdown-item entity-delete"><div class="iconmoon icon-bin"></div>削除</button>`;
    bottomWrapper.appendChild(dropdown);
    wandBtn.addEventListener('click', () => {
        dropdown.style.display = dropdown.style.display === 'none' ? 'flex' : 'none';
    });
    const genBtn = dropdown.querySelector('.entity-generate');
    if (genBtn) {
        genBtn.addEventListener('click', async () => {
            dropdown.style.display = 'none';
            await generateEntityImage(entity);
        });
    }
    const delBtn = dropdown.querySelector('.entity-delete');
    if (delBtn) {
        delBtn.addEventListener('click', async () => {
            dropdown.style.display = 'none';
            multiModalOpen({
                title: 'エンティティ削除',
                contentHtml: `「${DOMPurify.sanitize(entity.name)}」削除？`,
                okLabel: '削除',
                okButtonColor: '#f44336',
                onOk: async () => {
                    try {
                        await deleteEntity(entity.entityId);
                        await refreshEntitiesAndChips();
                    } catch (e) {
                        showToast(`削除失敗: ${e.message}`);
                    }
                },
            });
        });
    }
    topWrapper.appendChild(bottomWrapper);
    return row;
}

/**
 * シナリオ全体テキストからエンティティ抽出 (★ Gemini API 使用)
 */
// ★ export する (sceneUI.js などから呼び出すため)
export async function onUpdateEntitiesFromAllScenes() {
    console.log('[Extras] Updating entities from all scenes using Gemini...');
    const gemini = new GeminiApiClient(); // import
    if (!gemini.isAvailable) {
        alert('Gemini APIキー未設定/無効');
        return;
    } // import alert?
    if (gemini.isStubMode) {
        /* スタブ処理 */ return;
    }

    const scenarioId = window.currentScenarioId; // global
    if (!scenarioId) {
        alert('シナリオID不明');
        return;
    }

    showLoadingModal(true);
    const candidateListDiv = document.getElementById('entity-candidate-list');
    if (candidateListDiv) candidateListDiv.innerHTML = `<div class="loading">抽出中...</div>`;

    try {
        const existingEntities = await getEntitiesByScenarioId(scenarioId); // import
        const existingTextArr = existingEntities.map(
            (e) => `${e.name}(${e.category}): ${e.description.substring(0, 30)}...`
        );
        const existingDesc = existingTextArr.join('\n') || '（なし）';

        // シナリオテキストの準備 (sceneManager と同様のロジック)
        let scenarioText = '';
        const actionCount = window.scenes.length;
        let chunkEnd = Math.floor((actionCount - 15) / 10);
        if (chunkEnd < 0) chunkEnd = 0;
        for (let i = 0; i < chunkEnd; i++) {
            const sum = window.sceneSummaries[i];
            if (sum) {
                scenarioText += (sum.en || sum.ja || '') + '\n';
            }
        } // global
        const skipCount = chunkEnd * 10;
        let aCnt = 0;
        for (const scn of window.scenes) {
            if (scn.action?.content?.trim()) aCnt++;
            if (aCnt <= skipCount && aCnt !== 0) continue;
            if (scn.action?.content?.trim())
                scenarioText += `\nP:${scn.action.content_en || scn.action.content}\n`;
            scenarioText += `S:${scn.content_en || scn.content}\n`;
        } // global

        if (!scenarioText.trim()) {
            showToast('抽出対象のテキストがありません。');
            throw new Error('No text to process.');
        } // import

        const modelId =
            localStorage.getItem(PREFERRED_GEMINI_MODEL_LS_KEY) || 'gemini-1.5-flash-latest';
        // ★ Gemini に JSON 配列形式での出力を指示するプロンプト
        const prompt = `あなたはTRPGの情報を整理するAIです。以下のシナリオテキスト全体を読み、物語に登場した重要な【アイテム】や【キャラクター】(モンスター含む)を抽出してください。既に抽出済みのリストも参考に、重複を避け、新たに見つかったものだけをリストアップしてください。\n\n抽出済リスト:\n${existingDesc}\n\nシナリオテキスト:\n---\n${scenarioText}\n---\n\n出力形式は以下のJSON配列形式のみとしてください。説明や前置きは不要です。日本語で記述し、固有名詞が英語の場合はカタカナにしてください。プレイヤーが入手したと思われるアイテムには "acquired": true を設定してください。\n例: [{"category":"item","name":"古い鍵","description":"錆びついた銅製の鍵。","acquired":true}, {"category":"character","name":"ゴブリン","description":"小柄で緑色の肌を持つモンスター。","acquired":false}]\n\n新たに見つかったエンティティリスト(JSON配列):`;

        gemini.initializeHistory([]);
        console.log('[Extras] Calling Gemini for entity extraction...');
        const rawResponse = await gemini.generateContent(prompt, modelId);
        console.log('[Extras] Raw response (Entities):', rawResponse);

        // 応答からJSON部分を抽出する試み
        let newEntities = [];
        const jsonMatch = rawResponse.match(/\[\s*\{[\s\S]*\}\s*\]/); // [...] の部分を探す
        if (jsonMatch && jsonMatch[0]) {
            try {
                newEntities = JSON.parse(jsonMatch[0]);
                console.log('[Extras] Parsed new entities:', newEntities);
            } catch (e) {
                console.error('JSON parse failed:', e, '\nRaw response was:', rawResponse);
                showToast('AI応答の解析失敗');
            } // import
        } else {
            console.warn('Could not find JSON array in response:', rawResponse);
        }

        if (newEntities && Array.isArray(newEntities) && newEntities.length > 0) {
            let addedCount = 0;
            for (const e of newEntities) {
                if (e.name && e.category) {
                    // 最低限 name と category があるか
                    // ★ 既に同じ名前とカテゴリのものが存在しないかチェック (DBアクセス増える)
                    // const exists = existingEntities.some(ex => ex.name === e.name && ex.category === e.category);
                    // if (!exists) {
                    const rec = {
                        scenarioId,
                        category:
                            e.category === 'character' || e.category === 'モンスター'
                                ? 'character'
                                : 'item',
                        name: e.name,
                        description: e.description || '',
                        acquired: e.acquired === true,
                        imageData: '',
                    };
                    await addEntity(rec); // import
                    addedCount++;
                    // }
                }
            }
            await refreshEntitiesAndChips(); // このファイル内
            if (candidateListDiv)
                candidateListDiv.innerHTML = `${addedCount} 件の新しいアイテム/登場人物を登録しました。`;
            showToast(`${addedCount} 件登録完了`); // import
        } else {
            if (candidateListDiv)
                candidateListDiv.innerHTML = '新しく追加できそうなものはありませんでした。';
        }
    } catch (err) {
        console.error('エンティティ抽出失敗:', err);
        alert('抽出失敗:\n' + err.message);
        if (candidateListDiv) candidateListDiv.innerHTML = `<span class="error">抽出エラー</span>`;
    } finally {
        showLoadingModal(false);
    }
}

/** エンティティ画像生成 (★ Stability AI 使用) */
async function generateEntityImage(entity) {
    console.log(
        `[Extras] Generating image for entity ${entity?.entityId} (${entity?.name}) using Stability AI...`
    );
    if (!entity?.entityId || !entity.name) {
        showToast('画像生成対象のエンティティ情報が不正です。');
        return;
    }

    const stability = new StabilityApiClient(); // import
    if (!stability.isAvailable) {
        showToast('画像生成APIキー未設定/無効');
        return;
    }
    const stabilityApiKey = localStorage.getItem(STABILITY_API_KEY_LS_KEY); // 定数
    if (!stabilityApiKey) {
        showToast('Stability AI APIキー未設定');
        return;
    }
    const gemini = new GeminiApiClient(); // 翻訳用
    if (!gemini.isAvailable) {
        showToast('翻訳APIキー未設定/無効');
        return;
    }
    if (stability.isStubMode || gemini.isStubMode) {
        /* スタブ処理 */ return;
    }

    showLoadingModal(true);
    try {
        // プロンプト作成 (日本語)
        const promptJa = `${entity.category === 'item' ? 'アイテム:' : ''} ${entity.name}。 説明: ${
            entity.description || '(説明なし)'
        }`;
        console.log(`[Extras] Original prompt (JA) for entity: "${promptJa}"`);
        let promptEn = '';

        // 英語翻訳 (Gemini)
        try {
            console.log('Translating entity prompt...');
            promptEn = await generateEnglishTranslation(promptJa);
            console.log(`Translated prompt (EN): "${promptEn}"`);
            if (!promptEn?.trim()) throw new Error('翻訳結果空');
        } catch (transError) {
            throw new Error(`プロンプト英訳失敗: ${transError.message}`);
        }

        // Stability AI 呼び出し
        let width = 1024,
            height = 1024,
            stylePreset = 'fantasy-art'; // デフォルト
        if (entity.category === 'item') {
            stylePreset = 'photographic';
        } // アイテムは写真風
        else if (
            entity.category === 'character' &&
            entity.description?.toLowerCase().includes('monster')
        ) {
            stylePreset = 'comic-book';
        } // 説明にモンスターがあればコミック風 (例)

        const imageOptions = {
            samples: 1,
            width: width,
            height: height,
            style_preset: stylePreset,
        };
        console.log('Calling stabilityClient.generateImage (Entity):', imageOptions);
        const imageResults = await stability.generateImage(promptEn, stabilityApiKey, imageOptions); // ★ API 呼び出し
        const base64 = imageResults?.[0]?.imageDataB64;
        if (!base64) throw new Error('API画像データ取得失敗');
        const dataUrl = 'data:image/png;base64,' + base64;

        // DB更新
        entity.imageData = dataUrl;
        await updateEntity(entity); // import DB関数
        console.log(`Image saved for entity ${entity.entityId}.`);
        showToast('画像生成完了'); // import

        // UI更新
        await refreshEntitiesAndChips(); // このファイル内
    } catch (err) {
        console.error(`エンティティ画像生成失敗 (ID: ${entity.entityId}):`, err);
        showToast(`画像生成エラー: ${err.message}`); // import
    } finally {
        showLoadingModal(false);
    }
}

/** まとめてリスト描画＆アイテムチップス更新 */
async function refreshEntitiesAndChips() {
    // ★ renderItemChips は sceneUI.js から import する想定
    console.log('[Extras] Refreshing entities list and item chips...');
    await renderEntitiesList(); // このファイル内
    if (typeof renderItemChips === 'function') {
        // import されていれば
        await renderItemChips();
    } else {
        console.warn('renderItemChips function not found/imported.');
    }
}

/* =============================
 * パーティ表示関連 (★ sceneExtras.js にあったもの)
============================= */

/** パーティ情報モーダル表示 */
// ★ export する (sceneUI.js などから呼び出すため)
export function showPartyModal() {
    console.log('[Extras] Opening party modal...');
    multiModalOpen({
        // import
        title: 'パーティ情報',
        contentHtml: `<div id="party-modal-card-container" style="display:flex; flex-wrap:wrap; gap:15px; justify-content:center; padding:10px;">読込中...</div>`,
        appearanceType: 'top', // 上部表示
        showCloseButton: true,
        closeOnOutsideClick: true,
        cancelLabel: '閉じる',
        onOpen: () => {
            renderPartyCardsInModalMulti();
        }, // このファイル内で定義
    });
}

/** パーティカードをモーダル内に描画 */
function renderPartyCardsInModalMulti() {
    console.log('[Extras] Rendering party cards in modal...');
    const container = document.getElementById('party-modal-card-container');
    if (!container) return;
    container.innerHTML = '';
    // ★ window.currentScenario, window.characterData を参照 (global)
    const scenario = window.currentScenario;
    const wizardPartyCards = scenario?.wizardData?.party || []; // ウィザード時点のデータ
    const dbCards = window.characterData || []; // DB/メモリ上の最新データ

    if (wizardPartyCards.length === 0) {
        container.textContent = 'パーティメンバーなし';
        return;
    }

    // ウィザード時点のデータとDB/メモリ上の最新データをマージして表示
    const mergedParty = wizardPartyCards.map((wCard) => {
        const dbMatch = dbCards.find((dbC) => dbC.id === wCard.id);
        if (!dbMatch) return wCard; // DBにない場合(アバターなど)はウィザード時点のまま
        // DBにあれば最新情報を優先しつつ、ロール情報などはウィザード時点のを保持
        return { ...dbMatch, ...wCard, imageData: dbMatch.imageData || wCard.imageData };
    });

    mergedParty.forEach((card) => {
        const cardEl = createPartyCardElement(card); // このファイル内で定義
        container.appendChild(cardEl);
    });
    console.log(`[Extras] Rendered ${mergedParty.length} party cards.`);
}

/** パーティカード要素作成 (元の実装) */
function createPartyCardElement(c) {
    // (中身は変更なし - 省略せず記述)
    const cardEl = document.createElement('div');
    const rNum = (c.rarity || '★0').replace('★', '').trim();
    cardEl.className = `card rarity${rNum}`;
    cardEl.setAttribute('data-id', c.id);
    cardEl.addEventListener('click', () => {
        cardEl.classList.toggle('flipped');
    });
    const inner = document.createElement('div');
    inner.className = 'card-inner';
    const cf = document.createElement('div');
    cf.className = 'card-front';
    const bezel = document.createElement('div');
    bezel.className = `bezel rarity${rNum}`;
    cf.appendChild(bezel);
    let role = '';
    if (c.role === 'avatar') role = '(アバター)';
    else if (c.role === 'partner') role = '(パートナー)';
    const tEl = document.createElement('div');
    tEl.className = 'card-type';
    tEl.textContent = (c.type || '?') + role;
    cf.appendChild(tEl);
    const imgC = document.createElement('div');
    imgC.className = 'card-image';
    if (c.imageData) {
        const im = document.createElement('img');
        im.src = c.imageData;
        im.alt = c.name;
        imgC.appendChild(im);
    }
    cf.appendChild(imgC);
    const info = document.createElement('div');
    info.className = 'card-info';
    const nm = document.createElement('p');
    nm.innerHTML = `<h3>${DOMPurify.sanitize(c.name || '無名')}</h3>`;
    info.appendChild(nm);
    if (c.state) {
        const st = document.createElement('p');
        st.innerHTML = `<strong>状態：</strong>${DOMPurify.sanitize(c.state)}`;
        info.appendChild(st);
    }
    const sp = document.createElement('p');
    sp.innerHTML = `<strong>特技：</strong>${DOMPurify.sanitize(c.special || 'なし')}`;
    info.appendChild(sp);
    const cap = document.createElement('p');
    cap.innerHTML = `<span>${DOMPurify.sanitize(c.caption || 'なし')}</span>`;
    info.appendChild(cap);
    cf.appendChild(info);
    const cb = document.createElement('div');
    cb.className = 'card-back';
    cb.innerHTML = `<strong>${DOMPurify.sanitize(c.type || '?')}</strong>`;
    inner.appendChild(cf);
    inner.appendChild(cb);
    cardEl.appendChild(inner);
    return cardEl;
}

/** パーティ情報文章化 (scenarioWizard.js と同じ実装) */
export function buildPartyInsertionText(party) {
    // (中身は変更なし - 省略せず記述)
    if (!party?.length) return 'なし';
    let txt = '【パーティ】\n';
    party.forEach((p) => {
        txt += `- ${p.name || '?'} (${p.type || '?'})`;
        if (p.role === 'avatar') txt += '[あなた]';
        if (p.role === 'partner') txt += '[パートナー]';
        txt += `\n 詳細:${p.special || p.caption || '(なし)'}\n`;
    });
    return txt;
}

// --- ファイル読み込み完了ログ ---
console.log('[SceneExtras] sceneExtras.js loaded.');

// ★ 必要に応じて公開する関数を export
// export { showEndingModal, openEntitiesModal, renderEntitiesList, onUpdateEntitiesFromAllScenes, refreshEndingButtons, showPartyModal };
---
sceneUI.js
/********************************
 * sceneUI.js
 * シナリオ画面のUI関連イベント・表示更新など
 * ★ API 呼び出しを Gemini Text / Stability Image に変更
 * ★ ES Modules 形式、依存関係を import
 * ★ 省略なし (今度こそ！)
 ********************************/

// --- ▼▼▼ モジュールインポート (想定) ▼▼▼ ---
import { GeminiApiClient } from './geminiApiClient.js';
import { StabilityApiClient } from './stabilityApiClient.js';
import { open as multiModalOpen } from './multiModal.js';
import { showToast } from './common.js';
import { addSceneEntry, updateSceneEntry, getSceneEntriesByScenarioId, getEntitiesByScenarioId, updateScenario, deleteSceneEntry } from './indexedDB.js';
// --- 以下の import は関数の実際の場所に合わせてパスや関数名を修正してください ---

// sceneManager.js からと想定される関数 (★要確認/修正)
import {
  getNextScene, // 「次のシーン」「アイテム使用」ボタン
  generateEnglishTranslation, // トークン調整、プロンプト翻訳で使用
  generateImagePromptFromScene, // 挿絵生成のプロンプト作成で使用
  decompressCondition, // ネタバレモーダルや候補生成で使用 (common.jsかも？)
  areAllSectionsCleared, // ★ エンディングボタン表示で使用
  loadScenarioData, // ロード時に必要？(sceneMain.jsで呼ばれる想定)
} from './sceneManager.js'; // ★実際のファイルパスに注意

// sceneExtras.js からと想定される関数 (★要確認/修正)
import {
  showPartyModal, // PTボタン
  openEntitiesModal, // 情報ボタン
  renderEntitiesList, // 情報モーダル内で使用
  onUpdateEntitiesFromAllScenes, // 情報モーダル内で使用
  refreshEndingButtons, // エンディングボタン表示更新
  showEndingModal, // エンディングボタンクリック
} from './sceneExtras.js'; // ★実際のファイルパスに注意

// carousel.js からと想定される関数 (★要確認/修正)
import { initCarousel, removeDuplicateIDs } from './carousel.js';

// DOMPurify, pako はグローバルにある想定 (HTMLで読み込み済み)

// --- localStorage キー (menu.js と合わせる) ---
const GEMINI_API_KEY_LS_KEY = 'geminiApiKey';
const STABILITY_API_KEY_LS_KEY = 'stabilityApiKey';
const PREFERRED_GEMINI_MODEL_LS_KEY = 'preferredGeminiModel';

// --- ★ 画像ビューワの状態管理用オブジェクト初期化 (エラー修正) ★ ---
// window.imageViewerState = { sceneObj: null, currentIndex: 0, images: [], isOpen: false };
// 元の imageViewerState の定義に tapThreshold を追加（もし未定義なら）
window.imageViewerState = {
  sceneObj: null,
  currentIndex: 0,
  images: [],
  isOpen: false,
  startX: 0,
  startY: 0,
  currentX: 0,
  currentY: 0,
  isDragging: false,
  hasMoved: false, // tapThreshold を超えた移動があったか
  didIntentionalDrag: false, // わずかでもドラッグ操作を意図したか
  tapThreshold: 10, // タップと判定する移動距離の閾値 (px)
};

export function intUI() {
  // カルーセル初期化
  if (typeof initCarousel === 'function' && typeof removeDuplicateIDs === 'function') {
    setTimeout(() => {
      initCarousel();
      removeDuplicateIDs();
      console.log('[SceneUI] Carousel initialized.');
    }, 500);
  } else {
    console.warn('Carousel functions not found/imported.');
  }

  // アプリケーションバーへのボタン動的追加 (sceneMain.js で行うべきか要検討)
  const applicationBar = document.querySelector('.application-bar');
  const baseButton = document.getElementById('save-load-button'); // 基準ボタン
  if (applicationBar && baseButton) {
    console.log('[SceneUI] Adding buttons to application bar...');
    // 履歴ボタン
    if (!document.getElementById('toggle-history-button') && typeof toggleHistory === 'function') {
      const historyBtn = document.createElement('button');
      historyBtn.id = 'toggle-history-button';
      historyBtn.innerHTML = '<div class="iconmoon icon-newspaper"></div>履歴';
      historyBtn.title = '履歴表示切替';
      applicationBar.insertBefore(historyBtn, baseButton);
      historyBtn.addEventListener('click', toggleHistory); // このファイル内で定義
    }
    // PTボタン
    if (!document.getElementById('show-party-button') && typeof showPartyModal === 'function') {
      // import
      const partyBtn = document.createElement('button');
      partyBtn.id = 'show-party-button';
      partyBtn.innerHTML = '<div class="iconmoon icon-strategy"></div>PT';
      partyBtn.title = 'パーティ情報';
      applicationBar.insertBefore(partyBtn, baseButton);
      partyBtn.addEventListener('click', showPartyModal);
    }
    // 情報ボタン
    if (!document.getElementById('info-button') && typeof openEntitiesModal === 'function') {
      // import
      const infoBtn = document.createElement('button');
      infoBtn.id = 'info-button';
      infoBtn.innerHTML = '<div class="iconmoon icon-info"></div>情報';
      infoBtn.title = 'エンティティ情報';
      applicationBar.insertBefore(infoBtn, baseButton);
      infoBtn.addEventListener('click', openEntitiesModal);
    }
    // ネタバレ(目標)ボタン
    if (!document.getElementById('spoiler-button')) {
      const spoilerBtn = document.createElement('button');
      spoilerBtn.id = 'spoiler-button';
      spoilerBtn.innerHTML = '<div class="iconmoon icon-flag"></div>目標';
      spoilerBtn.title = '現在の目標';
      spoilerBtn.style.display = 'none';
      applicationBar.insertBefore(spoilerBtn, baseButton);
      spoilerBtn.addEventListener('click', openSpoilerModal); // このファイル内で定義
    }
  } else {
    console.warn('Application bar or base button not found for adding buttons.');
  }

  const endBtn = document.getElementById('ending-button');
  endBtn.addEventListener('click', () => showEndingModal('bad'));
  const clearEndBtn = document.getElementById('clear-ending-button');
  clearEndBtn.addEventListener('click', () => showEndingModal('clear'));

  // 回答候補チェックボックス
  const autoGenCbx = document.getElementById('auto-generate-candidates-checkbox');
  if (autoGenCbx) {
    try {
      autoGenCbx.checked = localStorage.getItem('autoGenerateCandidates') === 'true';
    } catch (e) {}
    autoGenCbx.addEventListener('change', () => {
      const isChecked = autoGenCbx.checked;
      try {
        localStorage.setItem('autoGenerateCandidates', String(isChecked));
      } catch (e) {}
      if (isChecked) {
        onGenerateActionCandidates();
      } // このファイル内
      else {
        const cont = document.getElementById('action-candidates-container');
        if (cont) cont.innerHTML = '';
      }
    });
    console.log('[SceneUI] Auto-generate listener added.');
  } else {
    console.warn('Auto-generate checkbox not found.');
  }

  // アイテム使用ボタン
  const useItemBtn = document.getElementById('use-item-button');
  if (useItemBtn) {
    useItemBtn.addEventListener('click', () => {
      if (typeof getNextScene === 'function') getNextScene(true);
      else {
        console.error('getNextScene not found.');
        showToast('エラー: 進行処理不可');
      }
    }); // import
    console.log('[SceneUI] Use item listener added.');
  } else {
    console.warn('Use item button not found.');
  }

  // 全セクション閲覧ボタン
  const viewSectionsBtn = document.getElementById('view-all-sections-button');
  if (viewSectionsBtn) {
    viewSectionsBtn.addEventListener('click', showAllSectionsModal);
    console.log('[SceneUI] View sections listener added.');
  } else {
    console.warn('View sections button not found.');
  }

  // ローディングモーダルキャンセルボタン
  const cancelReqBtn = document.getElementById('cancel-request-button');
  if (cancelReqBtn) {
    cancelReqBtn.addEventListener('click', onCancelFetch);
    console.log('[SceneUI] Loading cancel listener added.');
  } else {
    console.warn('Cancel request button not found.');
  }

  // カスタム画像生成関連ボタン (もしモーダルをJSで開閉する場合)
  /*
     const customGenBtn = document.getElementById('image-custom-generate-button');
     if (customGenBtn) customGenBtn.addEventListener('click', () => { ... });
     const customCancelBtn = document.getElementById('image-custom-cancel-button');
     if (customCancelBtn) customCancelBtn.addEventListener('click', closeImagePromptModal);
     */
}

// --- UI更新系関数 ---

/** ローディングモーダル表示/非表示 */
export function showLoadingModal(show) {
  const m = document.getElementById('loading-modal');
  if (!m) return;
  if (show) {
    m.classList.add('active');
  } else {
    m.classList.remove('active');
  }
}

/** APIリクエストキャンセル試行 */
export function onCancelFetch() {
  console.warn('[SceneUI] Request cancellation attempted (not supported).');
  showLoadingModal(false);
  showToast('キャンセルを試みます...(APIによっては停止できません)'); // import
}

/** 履歴表示のトグル */
function toggleHistory() {
  console.log('履歴ボタンがクリックされました'); // ← これを追加
  // ★ グローバル変数 window.currentScenario を参照
  if (!window.currentScenario) {
    console.warn('toggleHistory: currentScenario not found.');
    return;
  }
  const hist = document.getElementById('scene-history');
  if (!hist) {
    console.warn('toggleHistory: scene-history element not found.');
    return;
  }
  // showHistory プロパティをトグル（なければ false の逆で true に）
  window.currentScenario.showHistory = !(window.currentScenario.showHistory || false);
  hist.style.display = window.currentScenario.showHistory ? 'flex' : 'none';
  console.log(`History visibility toggled: ${window.currentScenario.showHistory}`);
  const btn = document.getElementById('toggle-history-button');
  if (btn) btn.style.backgroundColor = window.currentScenario.showHistory ? '#777' : '';
  // DB保存 (updateScenario は indexedDB.js から import)
  if (typeof updateScenario === 'function') {
    updateScenario(window.currentScenario).catch((e) => console.error('Failed save history state:', e)); // import
  } else {
    console.error('Cannot save history state: updateScenario function missing.');
  }
}

/** ネタバレ（目標表示）モーダルを開く */
function openSpoilerModal() {
  console.log('[SceneUI] Opening spoiler (goal) modal...');
  let goalText = '目標情報なし';
  const wd = window.currentScenario?.wizardData; // global
  // decompressCondition は import されている想定
  if (wd?.sections && typeof decompressCondition === 'function') {
    const sorted = [...wd.sections].sort((a, b) => (a.number || 0) - (b.number || 0));
    const firstUncleared = sorted.find((s) => !s.cleared);
    if (firstUncleared) {
      const condJa = decompressCondition(firstUncleared.conditionZipped || '') || '(不明)';
      const condEn = firstUncleared.conditionEn || '';
      goalText = `目標 (S ${firstUncleared.number}):\n${condJa}${condEn ? `\n(EN: ${condEn})` : ''}`;
    } else if (sorted.length > 0) {
      goalText = '全セクション目標達成済！';
    }
  } else if (!wd?.sections) {
    goalText = 'セクション情報なし';
  } else {
    goalText = '目標展開関数エラー';
  }

  multiModalOpen({
    // import
    title: '現在のセクション目標',
    contentHtml: `<pre style="white-space:pre-wrap; max-height:60vh; overflow-y:auto;">${DOMPurify.sanitize(goalText)}</pre>`, // global
    cancelLabel: '閉じる',
  });
}

/** 全セクション一覧モーダルを開く */
function showAllSectionsModal() {
  console.log('[SceneUI] Opening all sections modal...');
  multiModalOpen({
    // import
    title: '全セクション一覧',
    contentHtml: `<div id="all-sections-container" style="max-height:70vh; overflow-y:auto; white-space:pre-wrap; text-align:left; padding: 10px; background: rgba(0,0,0,0.2);">読込中...</div>`,
    cancelLabel: '閉じる',
    onOpen: renderAllSections, // このファイル内で定義
  });
}
/** 全セクション一覧を描画 */
function renderAllSections() {
  const container = document.getElementById('all-sections-container');
  if (!container) return;
  const wd = window.currentScenario?.wizardData; // global
  if (!wd?.sections?.length) {
    container.textContent = 'セクション情報なし';
    return;
  }
  const sorted = [...wd.sections].sort((a, b) => (a.number || 0) - (b.number || 0));
  let content = '';
  // decompressCondition は import されている想定
  if (typeof decompressCondition === 'function') {
    sorted.forEach((sec) => {
      const status = sec.cleared ? '【済】' : '【未】';
      const condition = decompressCondition(sec.conditionZipped || '') || '(不明)';
      const conditionEn = sec.conditionEn ? `\n   (EN: ${sec.conditionEn})` : '';
      content += `▼ S${sec.number} ${status}\n   目標: ${condition}${conditionEn}\n\n`;
    });
  } else {
    content = '条件展開関数エラー';
  }
  container.textContent = content; // pre タグは不要かも
}

// --- API呼び出し関連 ---

/**
 * 回答候補を生成 (★ Gemini API でJSON出力を指示し、JSでシャッフルする修正版)
 */
export async function onGenerateActionCandidates() {
  console.log('[SceneUI] Generating action candidates using Gemini (JSON format)...');

  const gemini = new GeminiApiClient(); // import
  if (!gemini.isAvailable) {
    showToast('Gemini APIキー未設定/無効');
    return;
  }
  if (gemini.isStubMode) {
    console.warn('STUB MODE: Skip candidates');
    const c = document.getElementById('action-candidates-container');
    // スタブモードでも複数のボタンを表示する例
    if (c)
      c.innerHTML = ['探索する', '話しかける', '休憩する', '踊る']
        .sort(() => 0.5 - Math.random()) // スタブもシャッフル
        .map((t) => `<button style="display:block; text-align:left; margin:0;">${t}</button>`)
        .join('');
    return;
  }

  const lastScene = window.scenes?.[window.scenes.length - 1]; // global
  if (!lastScene?.content) {
    showToast('行動候補生成にはシーンが必要');
    return;
  }
  const lastSceneTextJa = lastScene.content;

  // クリア条件テキストの取得
  let conditionTextJa = '(目標情報なし)';
  const wd = window.currentScenario?.wizardData; // global
  if (wd?.sections && typeof decompressCondition === 'function') {
    // decompressCondition を import
    const sorted = [...wd.sections].sort((a, b) => (a.number || 0) - (b.number || 0));
    const firstUncleared = sorted.find((s) => !s.cleared);
    if (firstUncleared) {
      conditionTextJa = decompressCondition(firstUncleared.conditionZipped || '') || '?';
    } else if (sorted.length > 0) {
      conditionTextJa = '(全目標達成済み)';
    }
  } else if (wd && !wd.sections) {
    conditionTextJa = '(セクション情報なし)';
  } else if (typeof decompressCondition !== 'function') {
    console.warn('decompressCondition function not imported/found.');
    conditionTextJa = '(条件展開不可)';
  }

  const candidatesContainer = document.getElementById('action-candidates-container');
  if (candidatesContainer) candidatesContainer.innerHTML = `<div class="loading">選択肢生成中...</div>`;
  showLoadingModal(true); // このファイル内で export されている想定

  try {
    const modelId = localStorage.getItem(PREFERRED_GEMINI_MODEL_LS_KEY) || 'gemini-1.5-flash-latest';

    // ★★★ プロンプトをJSON出力指示に変更 ★★★
    const prompt = `あなたはTRPGのGMアシスタントです。以下の状況に基づき、プレイヤーが次に取りうる**多様な**行動の選択肢を**4つ**提案し、その結果を必ず指定されたJSON形式で出力してください。\n\n状況:\n---\n現在のシーン:\n${lastSceneTextJa}\n---\n現在の目標（セクションクリア条件）:\n${conditionTextJa}\n---\n\n出力指示:\n- 提案する行動選択肢は4つ生成してください。\n- 各選択肢は具体的で、プレイヤーが実際に行動できる内容にしてください。\n- 多様性を意識し、探索、対話、戦闘準備、回避、あるいは少し意外な行動など、異なる方向性の選択肢を含めてください。\n- **必ず以下のJSON形式で、選択肢テキストの配列のみを出力してください。JSON以外の前置き、後書き、説明、コメント、マークダウンの \`\`\`json \`\`\` などは一切含めないでください。**\n\n出力形式 (JSON):\n{\n  "options": [\n    "選択肢のテキスト1",\n    "選択肢のテキスト2",\n    "選択肢のテキスト3",\n    "選択肢のテキスト4"\n  ]\n}`;
    console.log('[onGenerateActionCandidates] Prompt for options (JSON format):', prompt);

    gemini.initializeHistory([]);
    console.log('[onGenerateActionCandidates] Calling API for options...');
    const jsonString = await gemini.generateContent(prompt, modelId); // API呼び出し (JSON文字列が返る想定)
    console.log('[onGenerateActionCandidates] API raw response:', jsonString);

    let options = [];
    try {
      // ★★★ JSONパース処理 (マークダウン除去含む) ★★★
      const cleanJsonString = jsonString
        .replace('```json', '') // 開始マーカーを除去
        .replace('```', '') // 終了マーカーを除去
        .trim();
      const responseObject = JSON.parse(cleanJsonString);

      if (responseObject && Array.isArray(responseObject.options)) {
        options = responseObject.options
          .map((opt) => String(opt).trim()) // 文字列化、トリム
          .filter((opt) => opt && opt.length > 1); // 空や短すぎるものを除去
        console.log(`[onGenerateActionCandidates] Parsed ${options.length} options successfully.`);
      } else {
        console.warn('[onGenerateActionCandidates] Invalid JSON structure received:', cleanJsonString);
        throw new Error('AIが期待しない形式で応答しました。');
      }
    } catch (e) {
      console.error('[onGenerateActionCandidates] Failed to parse JSON response:', e, jsonString);
      if (typeof showToast === 'function') showToast('AI応答の解析に失敗しました');
      options = []; // パース失敗時は空にする
    }

    // ★★★ ボタン生成処理 (シャッフル含む) ★★★
    if (candidatesContainer) {
      candidatesContainer.innerHTML = ''; // コンテナをクリア

      if (options.length > 0) {
        // ★ JavaScript側でシャッフル (Fisher-Yatesアルゴリズム)
        const shuffledOptions = [...options]; // 配列をコピーしてシャッフル
        for (let i = shuffledOptions.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffledOptions[i], shuffledOptions[j]] = [shuffledOptions[j], shuffledOptions[i]];
        }
        console.log('[onGenerateActionCandidates] Shuffled options:', shuffledOptions);

        // シャッフル後の配列でボタン生成
        shuffledOptions.forEach((optionText) => {
          const btn = document.createElement('button');
          btn.textContent = optionText; // JSONから取得したテキストをそのまま設定
          btn.style.display = 'block';
          btn.style.textAlign = 'left';
          btn.style.margin = '0';
          btn.addEventListener('click', () => {
            const playerInput = document.getElementById('player-input');
            if (playerInput) {
              playerInput.value = btn.textContent;
            }
            // ★ オプション: クリックで候補を消す or チェックボックスをオフにする
            // candidatesContainer.innerHTML = '';
            // const autoCbx = document.getElementById('auto-generate-candidates-checkbox');
            // if (autoCbx) autoCbx.checked = false;
          });
          candidatesContainer.appendChild(btn);
        });
      } else {
        // 候補が取得できなかった場合
        candidatesContainer.innerHTML = `<span>行動候補の生成に失敗しました</span>`;
        console.warn('[onGenerateActionCandidates] No options generated or extracted.');
      }
    } else {
      console.error('[onGenerateActionCandidates] candidatesContainer not found!');
    }
  } catch (e) {
    // API呼び出し自体のエラーなど
    console.error('候補生成API呼び出しエラー:', e);
    if (candidatesContainer) candidatesContainer.innerHTML = `<span>候補生成エラー</span>`;
    if (typeof showToast === 'function') showToast(`候補生成エラー: ${e.message}`);
  } finally {
    if (typeof showLoadingModal === 'function') showLoadingModal(false);
    console.log('[onGenerateActionCandidates] Function finished.');
  }
}

/**
 * シーンの挿絵を生成 (★ Stability AI 使用)
 * @param {object} sceneObj 対象シーンオブジェクト
 */
export async function generateImageForScene(sceneObj) {
  console.log(`[SceneUI] Generating illustration for scene ${sceneObj?.sceneId}...`);
  if (!sceneObj?.sceneId || !sceneObj.content) {
    showToast('挿絵生成対象シーン情報不正');
    return;
  } // import

  const stability = new StabilityApiClient(); // import
  if (!stability.isAvailable) {
    showToast('画像生成APIキー未設定/無効');
    return;
  } // import
  const stabilityApiKey = localStorage.getItem(STABILITY_API_KEY_LS_KEY); // 定数
  if (!stabilityApiKey) {
    showToast('Stability AI APIキー未設定');
    return;
  } // import
  const gemini = new GeminiApiClient(); // 翻訳用
  if (!gemini.isAvailable) {
    showToast('翻訳APIキー未設定/無効');
    return;
  } // import
  if (stability.isStubMode || gemini.isStubMode) {
    /* スタブ処理 */ return;
  }

  showLoadingModal(true);
  try {
    // プロンプト取得 or 生成
    let promptText = '';
    const allEntries = await getSceneEntriesByScenarioId(sceneObj.scenarioId); // import
    const sceneRecord = allEntries.find((e) => e.type === 'scene' && e.sceneId === sceneObj.sceneId);
    promptText = sceneRecord?.prompt || '';
    if (!promptText && typeof generateImagePromptFromScene === 'function') {
      // import/このファイル内
      console.log('Generating image prompt...');
      promptText = await generateImagePromptFromScene(sceneObj.content); // ★ Gemini利用
      if (promptText && sceneRecord) {
        sceneRecord.prompt = promptText;
        await updateSceneEntry(sceneRecord);
      } // import
    }
    if (!promptText) throw new Error('画像プロンプト作成失敗');

    // 英語翻訳
    let promptEn = promptText;
    if (containsJapanese(promptText) && typeof generateEnglishTranslation === 'function') {
      // このファイル内
      console.log('Translating prompt...');
      try {
        promptEn = await generateEnglishTranslation(promptText);
      } catch (e) {
        console.error('Trans fail:', e);
        showToast('プロンプト英訳失敗');
        promptEn = promptText + ', illustration';
      } // import
    } else if (!promptEn.toLowerCase().includes('style')) {
      promptEn += ', illustration, beautiful';
    }

    // Stability AI 呼び出し
    const imageOptions = {
      samples: 1,
      width: 1344,
      height: 768,
      style_preset: 'cinematic-photorealistic',
    };
    console.log('Calling stabilityClient.generateImage:', imageOptions);
    const imageResults = await stability.generateImage(promptEn, stabilityApiKey, imageOptions); // ★ API呼び出し
    const base64 = imageResults?.[0]?.imageDataB64;
    if (!base64) throw new Error('API画像データ取得失敗');
    const dataUrl = 'data:image/png;base64,' + base64;

    // DB保存 & メモリ更新
    const newImgRec = {
      scenarioId: sceneObj.scenarioId,
      type: 'image',
      sceneId: sceneObj.sceneId,
      dataUrl: dataUrl,
      prompt: promptText,
    };
    const newId = await addSceneEntry(newImgRec); // import
    console.log(`Generated image saved (Entry ID: ${newId})`);
    sceneObj.images.push({ entryId: newId, dataUrl: dataUrl, prompt: promptText });

    // UI更新
    if (typeof updateSceneHistory === 'function') updateSceneHistory(); // import
    if (typeof showLastScene === 'function') showLastScene(); // import
    showToast('挿絵生成完了'); // import
  } catch (err) {
    console.error(`挿絵生成失敗:`, err);
    showToast(`挿絵生成エラー: ${err.message}`); // import
  } finally {
    showLoadingModal(false);
  }
}

/** カスタムプロンプトで画像を生成 (★ Stability AI 使用) */
async function onCustomImageGenerate(userPromptText) {
  // export 不要
  console.log(`[SceneUI] Generating custom image: "${userPromptText.substring(0, 50)}..."`);
  if (!userPromptText) {
    showToast('プロンプトが空');
    return;
  } // import

  const stability = new StabilityApiClient(); // import
  if (!stability.isAvailable) {
    showToast('画像APIキー未設定/無効');
    return;
  } // import
  const stabilityApiKey = localStorage.getItem(STABILITY_API_KEY_LS_KEY); // 定数
  if (!stabilityApiKey) {
    showToast('Stability AI キー未設定');
    return;
  } // import
  if (stability.isStubMode) {
    /* スタブ */ return;
  }

  const lastScene = window.scenes?.[window.scenes.length - 1]; // global
  if (!lastScene) {
    alert('画像追加先のシーンなし');
    return;
  }

  showLoadingModal(true);
  try {
    // プロンプトは英語前提 (UIで案内 or 翻訳)
    let promptEn = userPromptText;
    if (containsJapanese(promptEn)) {
      // このファイル内
      // ★ 翻訳処理を追加 (Gemini利用)
      console.log('Translating custom prompt...');
      const gemini = new GeminiApiClient(); // import
      if (!gemini.isAvailable) throw new Error('翻訳API利用不可');
      try {
        promptEn = await generateEnglishTranslation(userPromptText);
      } catch (transError) {
        // このファイル内
        console.error('Custom prompt trans fail:', transError);
        throw new Error('カスタムプロンプトの翻訳失敗');
      }
    }

    // Stability AI 呼び出し
    const imageOptions = { samples: 1, width: 1024, height: 1024, style_preset: 'digital-art' }; // 正方形/デジタルアート デフォルト
    console.log('Calling stabilityClient.generateImage (Custom):', imageOptions);
    const imageResults = await stability.generateImage(promptEn, stabilityApiKey, imageOptions); // ★ API呼び出し
    const base64 = imageResults?.[0]?.imageDataB64;
    if (!base64) throw new Error('API画像データ取得失敗');
    const dataUrl = 'data:image/png;base64,' + base64;

    // DB保存 & メモリ更新
    const imgRec = {
      scenarioId: lastScene.scenarioId,
      type: 'image',
      sceneId: lastScene.sceneId,
      dataUrl: dataUrl,
      prompt: userPromptText,
    };
    const newId = await addSceneEntry(imgRec); // import
    console.log(`Custom image saved (Entry ID: ${newId})`);
    lastScene.images.push({ entryId: newId, dataUrl: dataUrl, prompt: userPromptText });

    // UI更新
    if (typeof updateSceneHistory === 'function') updateSceneHistory(); // import
    if (typeof showLastScene === 'function') showLastScene(); // import
    showToast('カスタム画像生成完了'); // import
  } catch (err) {
    console.error('カスタム画像生成失敗:', err);
    showToast(`カスタム画像生成失敗: ${err.message}`); // import
  } finally {
    showLoadingModal(false);
  }
}
/** アイテムチップスを表示 */
export async function renderItemChips() {
  const container = document.getElementById('item-chips-container');
  if (!container) return;
  container.innerHTML = '';

  if (!window.currentScenario) return;
  const scenarioId = window.currentScenarioId;
  if (!scenarioId) return;

  // DB側アイテム
  const ents = await getEntitiesByScenarioId(scenarioId);
  const acquiredItems = ents.filter((e) => e.category === 'item' && e.acquired);

  // wizardDataのパーティアイテム
  const pArr = window.currentScenario?.wizardData?.party || [];
  const partyItems = pArr.filter((c) => c.type === 'アイテム');

  const result = [];
  const addedNames = new Set();

  // 1) パーティアイテム
  for (const it of partyItems) {
    const nm = it.name || '無名アイテム';
    if (addedNames.has(nm)) continue;
    addedNames.add(nm);

    result.push({
      name: nm,
      description: it.caption || '(説明不明)',
      imageData: it.imageData || '',
    });
  }
  // 2) DB取得アイテム
  for (const it of acquiredItems) {
    const nm = it.name || '無名アイテム';
    if (addedNames.has(nm)) continue;
    addedNames.add(nm);

    result.push({
      name: nm,
      description: it.description || '(説明不明)',
      imageData: it.imageData || '',
    });
  }

  if (result.length === 0) {
    container.textContent = '使用可能なアイテムはありません。';
    return;
  }

  let currentSelectedChip = null;
  result.forEach((item) => {
    const chip = document.createElement('div');
    chip.className = 'chip chip-withimage';
    // 画像表示
    if (item.imageData) {
      const im = document.createElement('img');
      im.src = item.imageData;
      im.alt = item.name;
      chip.appendChild(im);
    }
    // 名前
    const lbl = document.createElement('span');
    lbl.textContent = item.name;
    chip.appendChild(lbl);

    // 選択ハイライト
    chip.onclick = () => {
      if (currentSelectedChip && currentSelectedChip !== chip) {
        currentSelectedChip.classList.remove('selected');
      }
      const wasActive = chip.classList.contains('selected');
      if (wasActive) {
        chip.classList.remove('selected');
        window.selectedItem = null;
      } else {
        chip.classList.add('selected');
        window.selectedItem = item;
      }
      currentSelectedChip = wasActive ? null : chip;
    };
    container.appendChild(chip);
  });

  // 「更新」チップを最後に配置 ---
  const updateChip = document.createElement('div');
  updateChip.className = 'chip chip-withimage';
  updateChip.textContent = '更新';
  updateChip.onclick = () => {
    onUpdateEntitiesFromAllScenes();
  };
  container.appendChild(updateChip);
}

/* ===========================================================
   シーン履歴表示、最新シーン表示など UI更新系関数
=========================================================== */
/** 履歴表示を更新 */
window.updateSceneHistory = function () {
  const his = document.getElementById('scene-history');
  if (!his) return;
  his.innerHTML = '';

  // シナリオ/セクション情報
  const wd = window.currentScenario?.wizardData;
  let sections = [];
  if (wd && wd.sections) {
    sections = wd.sections;
  }
  const sorted = [...sections].sort((a, b) => a.number - b.number);
  const firstUncleared = sorted.find((s) => !s.cleared);

  if (!firstUncleared && sorted.length > 0) {
    // 全部クリア済み
    const tile = document.createElement('div');
    tile.className = 'history-tile summary title';
    tile.textContent = 'シナリオ達成!';
    his.appendChild(tile);
  }

  for (const s of sorted) {
    const t = document.createElement('div');
    if (s.number < (firstUncleared?.number || Infinity)) {
      t.className = 'history-tile summary';
      t.textContent = `${decompressCondition(s.conditionZipped)}(クリア済み)`;
    } else if (s.number === firstUncleared?.number) {
      t.className = 'history-tile summary';
      t.textContent = `セクション${s.number} (未クリア)`;
    }
    his.appendChild(t);
  }
  let tile = document.createElement('div');
  tile.className = 'history-tile summary separator';
  his.appendChild(tile);

  // シナリオ概要
  const scenarioSummaryEl = document.createElement('div');
  scenarioSummaryEl.id = 'scenario-summary';
  scenarioSummaryEl.innerHTML = wd?.scenarioSummary || '';
  his.appendChild(scenarioSummaryEl);

  // 全シーンの描画 (最後の1件は下で別表示)
  const lastScene = [...window.scenes].slice(-1)[0] || null;
  const skipId = lastScene ? lastScene.sceneId : null;
  const toShow = window.scenes.filter((sc) => sc.sceneId !== skipId);

  // ★ Gemini API が利用可能かチェック
  const gemini = new GeminiApiClient(); // インスタンス作成
  const isGeminiAvailable = gemini.isAvailable; // isAvailable プロパティ (または同等のメソッド) で判定

  for (const scn of toShow) {
    const tile = document.createElement('div');
    tile.className = 'history-tile';

    // アクション
    if (scn.action?.content) {
      const at = document.createElement('p');
      at.className = 'action-text';
      at.setAttribute('contenteditable', isGeminiAvailable ? 'true' : 'false');
      at.innerHTML = DOMPurify.sanitize(scn.action.content, DOMPURIFY_CONFIG);
      at.addEventListener('blur', async () => {
        await onSceneOrActionContentEdited(scn, at.innerHTML.trim(), true);
      });
      tile.appendChild(at);
    }

    // シーン本文
    const st = document.createElement('p');
    st.className = 'scene-text';
    st.setAttribute('contenteditable', isGeminiAvailable ? 'true' : 'false');
    st.innerHTML = DOMPurify.sanitize(scn.content, DOMPURIFY_CONFIG);
    st.addEventListener('blur', async () => {
      await onSceneOrActionContentEdited(scn, st.innerHTML.trim(), false);
    });
    tile.appendChild(st);

    // 画像一覧
    const scImages = scn.images || [];
    scImages.forEach((imgRec, index) => {
      const img = document.createElement('img');
      img.src = imgRec.dataUrl;
      img.alt = '生成画像';
      img.style.maxHeight = '350px';
      img.style.width = '100%';
      img.style.objectFit = 'contain';

      img.addEventListener('click', () => {
        openImageViewer(scn, index);
      });
      tile.appendChild(img);
    });

    // シーン操作ドロップダウン
    const c = document.createElement('div');
    const dropdown = document.createElement('div');
    dropdown.className = 'scene-dropdown-menu';
    dropdown.style.display = 'none';
    dropdown.innerHTML = `
        <button class="dropdown-item scene-delete">
          <div class="iconmoon icon-bin"></div>シーンを削除
        </button>
        <button class="dropdown-item scene-illustration">
          <div class="iconmoon icon-picture"></div>挿絵を生成
        </button>
      `;
    c.appendChild(dropdown);

    c.className = 'r-flexbox';
    const wandBtn = document.createElement('button');
    wandBtn.className = 'scene-menu-button';
    wandBtn.innerHTML = '<div class="iconmoon icon-dots-three-horizontal"></div>';
    c.appendChild(wandBtn);

    wandBtn.addEventListener('click', () => {
      dropdown.style.display = dropdown.style.display === 'none' ? 'flex' : 'none';
    });

    const delBtn = dropdown.querySelector('.scene-delete');
    if (delBtn) {
      delBtn.addEventListener('click', async () => {
        dropdown.style.display = 'none';
        await deleteScene(scn);
      });
    }
    const illustBtn = dropdown.querySelector('.scene-illustration');
    if (illustBtn) {
      illustBtn.addEventListener('click', async () => {
        dropdown.style.display = 'none';
        await generateImageForScene(scn);
      });
    }

    tile.appendChild(c);
    his.appendChild(tile);
  }
  his.scrollTop = his.scrollHeight;
};

/** ビューワを開く */
function openImageViewer(sceneObj, startIndex) {
  // 1) state にデータ保持
  window.imageViewerState.sceneObj = sceneObj;
  window.imageViewerState.currentIndex = startIndex;
  window.imageViewerState.images = sceneObj.images || [];
  window.imageViewerState.isOpen = true;

  // 2) multiModal.open
  multiModalOpen({
    title: '画像ビューワー',
    contentHtml: `
        <div style="position:relative; background-color:#000; text-align:center; overflow:hidden;">
          <img id="viewer-image-element" class="viewer-image" 
               style="max-width:100%; max-height:80vh; transition:transform 0.2s;"
          />
          <div id="viewer-controls" class="viewer-controls hidden" 
               style="position:absolute; top:0; left:0; right:0; bottom:0; pointer-events:none;">
            <div class="center-buttons" style="pointer-events:auto; display:flex; gap:20px; justify-content:center; margin-top:40px;">
              <button id="viewer-delete-button">削除</button>
              <button id="viewer-download-button">ダウンロード</button>
            </div>
          </div>
        </div>
      `,
    appearanceType: 'center',
    closeOnOutsideClick: false, // 外クリックで閉じるかは好みで
    showCloseButton: false, // 右上×は不要ならfalse
    okLabel: 'OK', // 「OK」ボタンで閉じる
    // 追加ボタンは再度削除/ダウンロードしてもよいが、ここでは viewer-controls 内にあるため省略
    onOpen: () => {
      // モーダルが描画されたので、ここで画像表示/スワイプイベント登録
      initViewerModalContent();
    },
  });
}

function initViewerModalContent() {
  const imgEl = document.getElementById('viewer-image-element');
  const controlsEl = document.getElementById('viewer-controls');
  const delBtn = document.getElementById('viewer-delete-button');
  const dlBtn = document.getElementById('viewer-download-button');

  if (!imgEl || !delBtn || !dlBtn) return;

  // スワイプ等のイベント付与
  addViewerTouchEvents(imgEl);

  // 「削除」ボタン
  delBtn.onclick = () => {
    onClickViewerDelete();
  };

  // 「ダウンロード」ボタン
  dlBtn.onclick = () => {
    onClickViewerDownload();
  };

  // 初期表示
  showImageInViewer();
}

function showImageInViewer() {
  const { images, currentIndex } = window.imageViewerState;
  const viewerImg = document.getElementById('viewer-image-element');
  if (!viewerImg) return;
  if (!images[currentIndex]) return;

  viewerImg.src = images[currentIndex].dataUrl;
  viewerImg.style.transform = 'translateX(0px)';
}

/** スワイプイベント (グローバルリスナー版) */
function addViewerTouchEvents(imgEl) {
  const state = window.imageViewerState; // エイリアス

  // pointermove ハンドラ (グローバル)
  const handlePointerMove = (e) => {
    // isDragging チェックは不要 (リスナーが存在する = ドラッグ中)
    e.preventDefault();
    const dx = e.clientX - state.startX;
    const dy = e.clientY - state.startY;
    state.currentX = e.clientX;
    state.currentY = e.clientY;

    // わずかでも動いたらドラッグ操作意図ありとみなす
    if (!state.didIntentionalDrag && (Math.abs(dx) > 2 || Math.abs(dy) > 2)) {
      state.didIntentionalDrag = true;
    }

    // tapThreshold を超えたら hasMoved フラグを立てる
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (!state.hasMoved && dist > state.tapThreshold) {
      state.hasMoved = true;
    }

    // ドラッグ中は画像位置を更新
    imgEl.style.transform = `translateX(${dx}px)`;
  };

  // pointerup / pointercancel ハンドラ (グローバル)
  const handlePointerEnd = (e) => {
    // isDragging チェックは念のため
    if (!state.isDragging) return;

    // グローバルリスナーを解除
    document.removeEventListener('pointermove', handlePointerMove, { passive: false });
    document.removeEventListener('pointerup', handlePointerEnd);
    document.removeEventListener('pointercancel', handlePointerEnd);

    // ポインタキャプチャを解放
    // try-catch は、万が一要素が存在しない/キャプチャされてない場合のエラーを防ぐため
    try {
      imgEl.releasePointerCapture(e.pointerId);
    } catch (error) {
      // console.warn("Failed to release pointer capture:", error);
    }

    // スワイプ/タップ判定へ
    finishSwipeOrTap(e.type === 'pointercancel');
  };

  // pointerdown ハンドラ (画像要素に設定)
  imgEl.onpointerdown = (e) => {
    // メインボタン(通常マウス左クリック、タッチ)以外は無視
    if (e.button !== 0 && e.pointerType === 'mouse') return;
    // すでにドラッグ中の場合は無視（マルチタッチ対策）
    if (state.isDragging) return;

    e.preventDefault(); // デフォルトのドラッグなどを抑制
    e.stopPropagation(); // 親要素への伝播を抑制

    state.isDragging = true;
    state.hasMoved = false; // リセット
    state.didIntentionalDrag = false; //リセット
    state.startX = e.clientX;
    state.startY = e.clientY;
    state.currentX = e.clientX;
    state.currentY = e.clientY;

    // ポインタをキャプチャ
    try {
      imgEl.setPointerCapture(e.pointerId);
    } catch (error) {
      // console.error("Failed to set pointer capture:", error);
      // キャプチャ失敗時はドラッグ開始しない方が安全かもしれない
      state.isDragging = false;
      return;
    }

    // グローバルリスナーを登録 (passive: false で preventDefault を有効に)
    document.addEventListener('pointermove', handlePointerMove, { passive: false });
    document.addEventListener('pointerup', handlePointerEnd);
    document.addEventListener('pointercancel', handlePointerEnd);

    // ドラッグ開始時はアニメーションを切る
    imgEl.style.transition = 'none';
  };

  // クリックイベントの誤発火防止 (ドラッグ操作直後のクリックを無視)
  let wasDragging = false;
  imgEl.addEventListener(
    'click',
    (e) => {
      if (wasDragging) {
        e.preventDefault();
        e.stopPropagation();
        // console.log("Suppressed click after drag");
      }
    },
    true
  ); // キャプチャフェーズで早めに処理

  // finishSwipeOrTap 内で wasDragging を適切に設定する必要あり (後述)
  window.setWasDragging = (val) => {
    wasDragging = val;
  };
}

/** スワイプorタップ判定 */
function finishSwipeOrTap(isCancel) {
  const imgEl = document.getElementById('viewer-image-element');
  const s = window.imageViewerState;

  // ドラッグ状態を解除 (リスナーは handlePointerEnd で解除済み)
  s.isDragging = false;
  // 直後のクリックイベントを抑制するためのフラグを設定（少し遅延させる）
  const dragOccurred = s.didIntentionalDrag; // わずかでもドラッグしたか
  window.setWasDragging(dragOccurred);
  setTimeout(() => {
    window.setWasDragging(false);
  }, 100); // 100ms後に抑制解除

  if (!imgEl) return;
  if (isCancel) {
    resetImagePosition(imgEl);
    return;
  }

  // タップ判定: 意図的なドラッグ操作がなかった場合
  if (!s.didIntentionalDrag) {
    // console.log("Tap detected");
    toggleViewerControls();
    // タップの場合は位置をリセット（念のため）
    resetImagePosition(imgEl);
    return;
  }

  // --- 以下、スワイプ判定 ---
  const dx = s.currentX - s.startX;
  // スワイプとみなす閾値を調整 (例: 画面幅の 15%)
  const swipeThreshold = window.innerWidth * 0.15; // この値は調整してください

  if (Math.abs(dx) < swipeThreshold) {
    // スワイプ距離が足りない場合は元の位置に戻す
    // console.log("Swipe distance too short, resetting.");
    resetImagePosition(imgEl);
  } else {
    // スワイプ方向に応じて次/前の画像へ
    if (dx < 0) {
      // console.log("Swipe left detected");
      goNextImage();
    } else {
      // console.log("Swipe right detected");
      goPrevImage();
    }
  }
}
/** バウンスバック */
function resetImagePosition(imgEl) {
  imgEl.style.transition = 'transform 0.2s';
  imgEl.style.transform = 'translateX(0px)';
  setTimeout(() => {
    imgEl.style.transition = '';
  }, 200);
}

/** 次へ */
function goNextImage() {
  const s = window.imageViewerState;
  if (s.currentIndex < s.images.length - 1) {
    animateSwipeTransition(-window.innerWidth);
    s.currentIndex++;
  } else {
    bounceBack(-1);
  }
}

/** 前へ */
function goPrevImage() {
  const s = window.imageViewerState;
  if (s.currentIndex > 0) {
    animateSwipeTransition(window.innerWidth);
    s.currentIndex--;
  } else {
    bounceBack(1);
  }
}

/** スワイプアニメ後に差し替え */
function animateSwipeTransition(offset) {
  const imgEl = document.getElementById('viewer-image-element');
  if (!imgEl) return;
  imgEl.style.transition = 'transform 0.2s';
  imgEl.style.transform = `translateX(${offset}px)`;
  setTimeout(() => {
    showImageInViewer();
    imgEl.style.transition = 'none';
  }, 200);
}

/** 端で弾く */
function bounceBack(direction) {
  const imgEl = document.getElementById('viewer-image-element');
  if (!imgEl) return;
  imgEl.style.transition = 'transform 0.2s';
  imgEl.style.transform = `translateX(${direction * 60}px)`;
  setTimeout(() => {
    imgEl.style.transform = 'translateX(0px)';
  }, 200);
  setTimeout(() => {
    imgEl.style.transition = '';
  }, 400);
}

/** タップ時のコントロール表示切替 */
function toggleViewerControls() {
  const controls = document.getElementById('viewer-controls');
  if (!controls) return;
  controls.classList.toggle('hidden');
}
/** 画像削除 (async/await版) */
async function onClickViewerDelete() {
  // async キーワード追加
  const s = window.imageViewerState;
  const { currentIndex, images } = s;
  if (!images[currentIndex]) return;

  // entryId の存在確認
  const entryId = images[currentIndex].entryId;
  if (!entryId) {
    console.error('Cannot delete image: entryId is missing.');
    alert('削除に必要な情報が見つかりません。');
    return;
  }

  if (!confirm('この画像を削除します。よろしいですか？')) return;

  // deleteSceneEntry が利用可能かチェック
  if (typeof deleteSceneEntry !== 'function') {
    console.error('deleteSceneEntry function is not available.');
    alert('データベース削除機能が見つかりません。');
    return;
  }

  showLoadingModal(true); // Loading表示開始

  try {
    await deleteSceneEntry(entryId); // await で待機

    images.splice(currentIndex, 1); // メモリから削除

    if (images.length === 0) {
      // 画像がなくなったらモーダルを閉じる処理（multiModal依存）
      const closeButton = document.querySelector('.multimodal.active .modal-footer button.cancel, .multimodal.active .modal-close-button');
      if (closeButton) closeButton.click();
      else console.warn('Could not find modal close button to click.');
      // UI更新はモーダルが閉じた後でも良いかもしれない
      if (typeof updateSceneHistory === 'function') updateSceneHistory();
      if (typeof showLastScene === 'function') showLastScene();
      showToast('最後の画像が削除されました。'); // Toast表示
      return; // モーダルが閉じるので以降の処理は不要
    }

    // インデックス調整
    if (currentIndex >= images.length) {
      s.currentIndex = images.length - 1;
    }

    // 残りの画像を表示し、UI更新
    showImageInViewer();
    if (typeof updateSceneHistory === 'function') updateSceneHistory();
    if (typeof showLastScene === 'function') showLastScene();
    showToast('画像を削除しました。'); // Toast表示
  } catch (err) {
    console.error('Delete error:', err);
    alert('削除に失敗しました: ' + err.message);
  } finally {
    showLoadingModal(false); // Loading表示終了
  }
}

/** 画像ダウンロード */
function onClickViewerDownload() {
  const s = window.imageViewerState;
  const { images, currentIndex } = s;
  if (!images[currentIndex]) return;

  const link = document.createElement('a');
  link.href = images[currentIndex].dataUrl;
  link.download = 'image.png';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

/** ビューワを閉じる */
function closeImageViewer() {
  window.imageViewerState.isOpen = false;
  const viewerModal = document.getElementById('image-viewer-modal');
  if (viewerModal) {
    viewerModal.classList.remove('active');
  }
}

/** シーン削除 */
async function deleteScene(sceneObj) {
  const allEntries = await getSceneEntriesByScenarioId(sceneObj.scenarioId);
  const scRec = allEntries.find((e) => e.type === 'scene' && e.sceneId === sceneObj.sceneId);
  if (scRec) {
    await deleteSceneEntry(scRec.entryId);
  }
  const imgs = allEntries.filter((e) => e.type === 'image' && e.sceneId === sceneObj.sceneId);
  for (const iRec of imgs) {
    await deleteSceneEntry(iRec.entryId);
  }
  window.scenes = window.scenes.filter((s) => s.sceneId !== sceneObj.sceneId);

  updateSceneHistory();
  showLastScene();
}

/** 最新シーン表示 */
export async function showLastScene() {
  const storyDiv = document.getElementById('story');
  const lastSceneImagesDiv = document.getElementById('last-scene-images');
  const lastSceneAdded = document.getElementById('last-scene-added');

  if (!storyDiv || !lastSceneImagesDiv) return;

  const nextSceneBtn = document.getElementById('next-scene');
  const playerInput = document.getElementById('player-input');
  const playerActionLabel = document.getElementById('player-action');
  // ★ Gemini API が利用可能かチェック
  const gemini = new GeminiApiClient(); // インスタンスを作成
  // ↓↓↓ isAvailable プロパティが存在する場合の例。実際のクラス実装に合わせてください。
  const isGeminiAvailable = gemini.isAvailable;

  const lastScene = [...window.scenes].slice(-1)[0] || null;
  if (lastScene) {
    storyDiv.innerHTML = '';
    lastSceneAdded.innerHTML = '';

    // プレイヤーアクション
    if (lastScene.action?.content) {
      const at = document.createElement('p');
      at.className = 'action-text';
      at.setAttribute('contenteditable', isGeminiAvailable ? 'true' : 'false');
      at.innerHTML = DOMPurify.sanitize(lastScene.action.content, DOMPURIFY_CONFIG);
      at.addEventListener('blur', async () => {
        await onSceneOrActionContentEdited(lastScene, at.innerHTML.trim(), true);
      });
      storyDiv.appendChild(at);
    }

    // シーン本文
    const st = document.createElement('p');
    st.className = 'scene-text';
    st.setAttribute('contenteditable', isGeminiAvailable ? 'true' : 'false');
    st.innerHTML = DOMPurify.sanitize(lastScene.content, DOMPURIFY_CONFIG);
    st.addEventListener('blur', async () => {
      await onSceneOrActionContentEdited(lastScene, st.innerHTML.trim(), false);
    });
    storyDiv.appendChild(st);

    // ドロップダウン
    const dropdown = document.createElement('div');
    dropdown.className = 'scene-dropdown-menu';
    dropdown.style.display = 'none';
    dropdown.innerHTML = `
        <button class="dropdown-item last-scene-delete">
          <div class="iconmoon icon-bin"></div>シーンを削除
        </button>
        <button class="dropdown-item last-scene-illustration">
          <div class="iconmoon icon-picture"></div>挿絵を生成
        </button>
      `;
    lastSceneAdded.appendChild(dropdown);

    const wandBtn = document.createElement('button');
    wandBtn.className = 'scene-menu-button';
    wandBtn.innerHTML = '<div class="iconmoon icon-dots-three-horizontal"></div>';
    lastSceneAdded.appendChild(wandBtn);

    wandBtn.addEventListener('click', () => {
      dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
    });

    const delItem = dropdown.querySelector('.last-scene-delete');
    if (delItem) {
      delItem.addEventListener('click', async () => {
        dropdown.style.display = 'none';
        await deleteScene(lastScene);
      });
    }
    const illustItem = dropdown.querySelector('.last-scene-illustration');
    if (illustItem) {
      illustItem.addEventListener('click', async () => {
        dropdown.style.display = 'none';
        await generateImageForScene(lastScene);
      });
    }

    // 画像一覧
    lastSceneImagesDiv.innerHTML = '';
    lastScene.images.forEach((imgObj, index) => {
      const div = document.createElement('div');
      div.className = 'image-container';

      const imgEl = document.createElement('img');
      imgEl.src = imgObj.dataUrl;
      imgEl.alt = '生成画像';
      imgEl.style.maxHeight = '50vh';
      imgEl.style.objectFit = 'contain';
      imgEl.addEventListener('click', () => {
        openImageViewer(lastScene, index);
      });

      div.appendChild(imgEl);
      lastSceneImagesDiv.appendChild(div);
    });

    if (isGeminiAvailable) {
      nextSceneBtn.style.display = 'inline-block';
      playerInput.style.display = 'inline-block';
      playerActionLabel.textContent = 'プレイヤーの行動を入力してください';
    } else {
      nextSceneBtn.style.display = 'none';
      playerInput.style.display = 'none';
      playerActionLabel.textContent = '';
    }
  } else {
    // シーンが無い場合（導入前）
    storyDiv.innerHTML = '';
    lastSceneImagesDiv.innerHTML = '';
    if (isGeminiAvailabley) {
      nextSceneBtn.style.display = 'inline-block';
      playerInput.style.display = 'none';
      playerActionLabel.textContent = '最初のシーン(導入)を作成します。';
    } else {
      nextSceneBtn.style.display = 'none';
      playerInput.style.display = 'none';
      playerActionLabel.textContent = '';
    }
  }
}

// --- ★ 下記は古いモーダル実装の名残 or 未使用関数 ---
/** カスタム画像生成モーダルを開く (multiModal未使用版) */
export function openImagePromptModal(scenePrompt = '') {
  // この関数は現在の HTML では呼び出されていない可能性が高い
  console.warn('[SceneUI] openImagePromptModal (old version) called.');
  const ip = document.getElementById('image-custom-prompt');
  if (ip) ip.value = scenePrompt;
  const modal = document.getElementById('image-prompt-modal');
  if (modal) modal.classList.add('active');
}
/** カスタム画像生成モーダルを閉じる (古い実装) */
function closeImagePromptModal() {
  const modal = document.getElementById('image-prompt-modal');
  if (modal) modal.classList.remove('active');
}
function containsJapanese(text) {
  if (!text) return false;
  return /[ぁ-んァ-ン一-龯]/.test(text);
}
/* ===========================================================
   シーンテキスト編集、履歴トグル、アイテムchips表示 など
=========================================================== */
/** シーンorアクションのテキストを編集 */
async function onSceneOrActionContentEdited(sceneObj, newText, isActionEdit) {
  const gemini = new GeminiApiClient(); // import
  if (!gemini.isAvailable) return;
  //    if (!window.apiKey) return;
  const oldText = isActionEdit ? sceneObj.action.content : sceneObj.content;
  if (newText.trim() === oldText.trim()) {
    return;
  }
  showLoadingModal(true);
  try {
    // 英訳
    const en = await generateEnglishTranslation(newText);
    if (isActionEdit) {
      sceneObj.action.content = newText;
      sceneObj.action.content_en = en;
    } else {
      sceneObj.content = newText;
      sceneObj.content_en = en;
    }
    // DB更新
    const allEntries = await getSceneEntriesByScenarioId(sceneObj.scenarioId);
    const sceneRec = allEntries.find((e) => e.type === 'scene' && e.sceneId === sceneObj.sceneId);
    if (sceneRec) {
      sceneRec.content = sceneObj.content;
      sceneRec.content_en = sceneObj.content_en;
      sceneRec.actionContent = sceneObj.action.content;
      sceneRec.actionContent_en = sceneObj.action.content_en;
      await updateSceneEntry(sceneRec);
    }
  } catch (err) {
    console.error('再翻訳失敗:', err);
  } finally {
    showLoadingModal(false);
  }
}

// --- ファイル読み込み完了ログ ---
console.log('[SceneUI] sceneUI.js loaded.');

// ★ 必要に応じて公開する関数を export
// export { toggleHistory, onGenerateActionCandidates, generateImageForScene, onCustomImageGenerate, ... };
---
styles.css
/* styles.css */

@font-face {
  font-family: 'icomoon';
  src: url('fonts/icomoon.eot?asdasda');
  src: url('fonts/icomoon.eot?asdasdasd') format('embedded-opentype'), url('fonts/icomoon.ttf?asdasdasd') format('truetype'), url('fonts/icomoon.woff?asdasdad') format('woff'), url('fonts/icomoon.svg?asdasdad') format('svg');
  font-weight: normal;
  font-style: normal;
  font-display: block;
}

.iconmoon {
  font-family: 'icomoon' !important;
  font-size: 1.2rem;
}
.icon-dots-three-horizontal:before {
  content: '\e900';
  /* 3つ並んだ水平ドットのアイコン（メニュー、オプションなど） */
}
.icon-home:before {
  content: '\e901';
  /* 家のアイコン（ホーム画面、メインページなど） */
}
.icon-home3:before {
  content: '\e902';
  /* 別デザインのホームアイコン（ホーム画面、トップページ） */
}
.icon-home2:before {
  content: '\e903';
  /* もう一つのホームアイコン（ホーム画面、トップページ） */
}
.icon-save:before {
  content: '\e904';
  /* 保存のアイコン（セーブ、書き込みなど） */
}
.icon-address:before {
  content: '\e905';
  /* 住所アイコン（所在地、アドレス情報など） */
}
.icon-chat:before {
  content: '\e906';
  /* チャットのアイコン（会話、メッセージ、チャット画面など） */
}
.icon-credit-card:before {
  content: '\e907';
  /* クレジットカードのアイコン（支払い、決済など） */
}
.icon-documents:before {
  content: '\e908';
  /* ドキュメントのアイコン（複数書類、ファイルなど） */
}
.icon-flag1:before {
  content: '\e909';
  /* フラグアイコン（マーク、注目など） */
}
.icon-game-controller:before {
  content: '\e90a';
  /* ゲームコントローラーのアイコン（ゲーム関連、エンターテインメントなど） */
}
.icon-info-with-circle:before {
  content: '\e90b';
  /* 丸枠付きの情報アイコン（ヘルプ、案内など） */
}
.icon-info:before {
  content: '\e90c';
  /* 情報アイコン（ヘルプ、詳細情報など） */
}
.icon-mail:before {
  content: '\e90d';
  /* メールのアイコン（メッセージ、連絡先など） */
}
.icon-tag:before {
  content: '\e90e';
  /* タグのアイコン（分類、ラベルなど） */
}
.icon-typing:before {
  content: '\e90f';
  /* 入力中のアイコン（チャット、テキスト入力など） */
}
.icon-search:before {
  content: '\e007';
  /* 検索のアイコン（サーチ、虫眼鏡など） */
}
.icon-clipboard:before {
  content: '\e008';
  /* クリップボードのアイコン（コピー、貼り付け、メモなど） */
}
.icon-newspaper:before {
  content: '\e009';
  /* 新聞のアイコン（ニュース、記事など） */
}
.icon-book-open:before {
  content: '\e00b';
  /* 開いている本のアイコン（テキスト、ドキュメント参照など） */
}
.icon-browser:before {
  content: '\e00c';
  /* ブラウザアイコン（ウェブ閲覧、ページなど） */
}
.icon-picture:before {
  content: '\e00f';
  /* 画像アイコン（写真、ギャラリーなど） */
}
.icon-edit:before {
  content: '\e01c';
  /* 編集のアイコン（ペンツール、修正など） */
}
.icon-ribbon:before {
  content: '\e01e';
  /* リボンアイコン（受賞、バッジ、飾りなど） */
}
.icon-streetsign:before {
  content: '\e029';
  /* 道路標識アイコン（道案内、方向など） */
}
.icon-gears:before {
  content: '\e02b';
  /* ギア（歯車）アイコン（設定、オプションなど） */
}
.icon-key:before {
  content: '\e02c';
  /* 鍵のアイコン（セキュリティ、ロックなど） */
}
.icon-strategy:before {
  content: '\e03b';
  /* 戦略アイコン（プランニング、戦略的思考など） */
}
.icon-beaker:before {
  content: '\e03c';
  /* ビーカーアイコン（実験、化学、テストなど） */
}
.icon-profile-male:before {
  content: '\e040';
  /* 男性プロフィールアイコン（ユーザー、人物など） */
}
.icon-chat1:before {
  content: '\e049';
  /* 別デザインのチャットアイコン（会話、メッセージなど） */
}
.icon-target:before {
  content: '\e04e';
  /* ターゲットアイコン（目標、的など） */
}
.icon-pacman:before {
  content: '\e916';
  /* パックマンアイコン（ゲーム、エンタメなど） */
}
.icon-book:before {
  content: '\e91f';
  /* 本のアイコン（書籍、資料など） */
}
.icon-books:before {
  content: '\e920';
  /* 複数の本アイコン（ライブラリ、書籍集など） */
}
.icon-library:before {
  content: '\e921';
  /* 図書館アイコン（ライブラリ、保管場所など） */
}
.icon-folder-download:before {
  content: '\e933';
  /* ダウンロードフォルダアイコン（ファイル取得など） */
}
.icon-folder-upload:before {
  content: '\e934';
  /* アップロードフォルダアイコン（ファイル送信など） */
}
.icon-price-tag:before {
  content: '\e935';
  /* プライスタグアイコン（値札、価格情報など） */
}
.icon-price-tags:before {
  content: '\e936';
  /* プライスタグが複数のアイコン（複数の価格情報など） */
}
.icon-coin-dollar:before {
  content: '\e93b';
  /* ドル硬貨のアイコン（通貨、金銭、経済など） */
}
.icon-floppy-disk:before {
  content: '\e962';
  /* フロッピーディスクのアイコン（セーブ、保存など） */
}
.icon-undo2:before {
  content: '\e967';
  /* 元に戻すアイコン（アンドゥ、巻き戻しなど） */
}
.icon-bubble:before {
  content: '\e96b';
  /* 吹き出しアイコン（コメント、メッセージなど） */
}
.icon-bubbles:before {
  content: '\e96c';
  /* 複数の吹き出しアイコン（会話、スレッドなど） */
}
.icon-bubbles2:before {
  content: '\e96d';
  /* 別デザインの複数吹き出しアイコン（メッセージやチャットなど） */
}
.icon-user:before {
  content: '\e971';
  /* ユーザーアイコン（人物、アカウントなど） */
}
.icon-cog:before {
  content: '\e994';
  /* 歯車アイコン（設定、オプションなど） */
}
.icon-magic-wand:before {
  content: '\e997';
  /* 魔法の杖アイコン（特別な操作、エフェクトなど） */
}
.icon-trophy:before {
  content: '\e99e';
  /* トロフィーのアイコン（受賞、実績、コンテストなど） */
}
.icon-gift:before {
  content: '\e99f';
  /* ギフトアイコン（プレゼント、特典など） */
}
.icon-bin:before {
  content: '\e9ac';
  /* ゴミ箱アイコン（削除、破棄など） */
}
.icon-bin2:before {
  content: '\e9ad';
  /* 別デザインのゴミ箱アイコン（削除、破棄など） */
}
.icon-flag:before {
  content: '\e9cc';
  /* フラグアイコン（マーク、印など） */
}
.icon-star-full:before {
  content: '\e9d9';
  /* 星のアイコン（お気に入り、評価など） */
}
.icon-heart:before {
  content: '\e9da';
  /* ハートアイコン（いいね、愛、好みなど） */
}
.icon-smile:before {
  content: '\e9e1';
  /* 笑顔アイコン（幸せ、嬉しいなど） */
}
.icon-sad:before {
  content: '\e9e5';
  /* 悲しい顔アイコン（落ち込み、悲哀など） */
}
.icon-confused:before {
  content: '\e9f5';
  /* 困惑した顔アイコン（混乱、不明など） */
}
.icon-neutral:before {
  content: '\e9f7';
  /* 無表情アイコン（特に感情なし、中立など） */
}
.icon-hipster:before {
  content: '\e9f9';
  /* ヒップスター風アイコン（おしゃれ、個性的など） */
}
.icon-cross:before {
  content: '\ea0f';
  /* バツ印のアイコン（閉じる、キャンセルなど） */
}
.icon-volume-high:before {
  content: '\ea26';
  /* 音量大のアイコン（最大音量、音声出力など） */
}
.icon-volume-mute2:before {
  content: '\ea2a';
  /* 音量ミュートアイコン（無音、ミュートなど） */
}
.icon-arrow-right:before {
  content: '\ea34';
  /* 右矢印アイコン（次へ、移動など） */
}
.icon-arrow-left:before {
  content: '\ea38';
  /* 左矢印アイコン（戻る、移動など） */
}
.icon-sort-alpha-asc:before {
  content: '\ea48';
  /* アルファベット昇順ソートのアイコン（A→Zの並びなど） */
}
.icon-sort-alpha-desc:before {
  content: '\ea49';
  /* アルファベット降順ソートのアイコン（Z→Aの並びなど） */
}
.icon-sort-numeric-asc:before {
  content: '\ea4a';
  /* 数値昇順ソートのアイコン（小さい数→大きい数など） */
}
.icon-sort-numberic-desc:before {
  content: '\ea4b';
  /* 数値降順ソートのアイコン（大きい数→小さい数など） */
}
.icon-undo:before {
  content: '\e965';
}

.icon-redo:before {
  content: '\e966';
}

.icon-star-empty:before {
  content: '\e9d7';
}

.icon-card-case:before {
  content: '\e912';
}
.icon-card:before {
  content: '\e910';
}
.icon-star-empty:before {
  content: '\e9d7';
}
/* ベース */
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  background-color: #3d3d3d;
}

.container {
  position: relative;
  box-sizing: border-box;
  max-width: calc(100% - 40px);
  margin: 80px auto 20px;
  padding: 20px;
  background-color: rgba(0, 0, 0, 0.7);
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  color: #f0f0f0;
}

.button-container {
  display: flex;
  flex-direction: row;
  gap: 20px;
  justify-content: center;
}

#warehouse-card-container {
  opacity: 0;
  transition: opacity 0.3s ease;
}

h1 {
  text-align: center;
}

h2 {
  font-size: 1.5em;
  margin-bottom: 10px;
}

.api-key-section {
  margin-bottom: 20px;
}

input,
textarea {
  box-sizing: border-box;
  width: 100%;
  padding: 10px;
  font-size: 1.5rem;
  border: 1px solid #ccc;
  background-color: #434343;
  color: #f0f0f0;
  margin-bottom: 10px;
}

input[type='checkbox'] {
  width: initial;
  margin: auto 10px auto 0;
  padding: 0;
  width: 2rem;
  height: 2rem;
}

button {
  text-shadow: 1px 1px 4px #000;
  padding: 10px 10px;
  background-color: #4caf50;
  background-color: #5f4c38;
  /*background-color: transparent;*/
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  min-height: 3rem;
  min-width: 5.5rem;
  box-sizing: border-box;
  box-shadow: inset 0px 0px 8px 2px #161616;
  border: 1px solid #876d51;
  background-image: linear-gradient(0deg, #00000061, transparent);

  /* box-shadow: inset 0px 0px 8px 2px #161616; */
  /* border: 1px solid #fff; */
  /* background-image: linear-gradient(87deg, #00000061, transparent); */
}

.scene-dropdown-menu button {
  background-color: transparent;
  box-shadow: inset 0px 0px 8px 2px #161616;
  border: 1px dashed #bbb;
  color: #bbb;
  border-radius: 0;
  background-image: linear-gradient(87deg, #00000061, transparent);
}
.scene-dropdown-menu button:hover {
  box-shadow: none;
  border: 1px dashed #fff;
  color: #fff;
  border-radius: 0;
  background-image: linear-gradient(87deg, #00000061, transparent);
}
.scene-dropdown-menu button + button {
  border-left: none;
}

button:hover {
  background-color: #45a049 !important;
  border: 1px solid #45a049 !important;
}

/* シーン履歴 */
.scene-history {
  max-height: 50vh;
  overflow-y: auto;
  border: none;
  padding: 0;
  background-color: transparent;
  display: flex;
  flex-direction: column;
  gap: 0;
  margin-bottom: 20px;
  margin-right: -20px;
  margin-left: -20px;
  margin-top: -20px;
}

#scenario-summary,
.history-tile.summary {
  font-size: 0.8rem;
  font-family: serif;
  background-color: #1111115e;
  padding: 10px 20px;
  align-items: flex-start;
}

.history-tile.summary.separator {
  padding: 0;
  border-bottom: 1px dashed #666;
}

.history-tile.summary.title {
  font-size: 1rem;
}

.history-tile {
  position: relative;
  box-sizing: border-box;
  padding: 20px;
  background-color: transparent;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  margin: 0 auto;
  text-align: right;
  width: 100%;
  display: flex;
  flex-direction: column;
}

.history-tile:nth-child(odd) {
  background-color: #00000059;
}

.scene-text,
.action-text,
.scenario-text {
  text-align: left;
  font-family: serif;
  line-height: 1.8em;
  margin: 0;
  padding: 0;
  font-size: 22px;
  letter-spacing: 0.1em;
  border: 1px dashed transparent;
  cursor: text;
}

.action-text {
  font-family: initial;
}

.history-tile .scene-text,
.history-tile .action-text,
.history-tile .scenario-text {
  font-size: 0.8rem;
}

.history-tile .action-text {
  font-size: 1rem;
}

.history-tile:last-child .action-text {
  font-size: 1.4rem;
}

.scene-menu-button {
  position: relative;
  min-width: initial;
  right: 0;
  margin-bottom: 0px;
  background-color: transparent;
  border: 1px solid transparent;
  color: #bbb;
  width: initial !important;
  border-radius: 20px;
  min-height: initial;
  max-height: initial;
  text-shadow: none;
  box-shadow: none;
  background-image: none;
  margin: 18px 2px;
  padding: 3px 12px;
  box-shadow: 0 0 0 2px #ffffff99;
}
.scene-menu-button:hover {
  box-shadow: none;
  color: #fff;
}
.delete-scene {
  max-width: 10rem;
  background-color: transparent;
  border: 1px dashed #bbb;
  color: #bbb;
  width: 100%;
  border-radius: 20px;
  min-height: initial;
  max-height: initial;
  text-shadow: none;
  box-shadow: none;
  background-image: none;
}

.delete-scene:hover {
  background-color: #aaaaaa73;
  color: #000;
  border-color: #000;
}

.scene-text[contenteditable]:focus,
.action-text[contenteditable]:focus,
.scenario-text[contenteditable]:focus {
  border: 1px dashed #4caf50;
  outline: none;
}

#story {
  font-size: 1.4rem;
  padding-bottom: 10px;
  min-height: 60px;
}

/* ▼ 0件時メッセージ */
#no-scenarios-message {
  display: none;
  color: #ccc;
  text-align: center;
  margin-top: 20px;
}

/* ▼ モーダル（フェードイン／アウトで表示） */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  /* 背景の黒み */
  background-color: rgba(0, 0, 0, 0.8);

  /* フレックスで中央寄せ */
  display: flex;
  justify-content: center;
  align-items: center;

  /* ▼ フェードイン/アウトに使う */
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
  z-index: 9999;
}

.modal.active {
  opacity: 1;
  pointer-events: auto;
  flex-direction: column;
  justify-content: center;
}

/* モーダル内部 */
.modal-content {
  box-sizing: border-box;
  background-color: rgba(0, 0, 0, 0.6);
  color: #f0f0f0;
  padding: 0;
  border-radius: 5px;
  text-align: center;
  max-height: 100vh;
  overflow-y: auto;
  width: 100%;
  /* ふわっと拡大 */
  transform: scale(0.9);
  transition: transform 0.3s ease;
}

.modal.active .modal-content {
  transform: scale(1);
}

.modal-content {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* カード関連 */
#card-container,
#party-modal-card-container,
#warehouse-card-container {
  margin-top: 10px;
  box-sizing: border-box;
  display: flex;
  gap: 20px;
  flex-wrap: wrap;
  justify-content: center;
  width: 100%;
}

.card {
  width: 100%;
  aspect-ratio: 63 / 88;
  perspective: 1000px;
  cursor: pointer;
  transition: transform 0.3s ease;
  position: relative;
  max-width: 300px;
  overflow: hidden;
}

.card-inner {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;
  transition: transform 0.6s;
}

.card.flipped .card-inner {
  transform: rotateY(180deg);
}

.card-front,
.card-back {
  color: #222;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 2%;
  backface-visibility: hidden;
  box-shadow: 0 2px 2px rgba(0, 0, 0, 0.2);
}

.card-front {
  box-sizing: border-box;
  padding: 3%;
  background-color: #fff;
  display: flex;
  flex-direction: column;
  position: relative;
}

.card-front h3 {
  padding: 0;
  margin: 0;
  font-size: 1rem;
}

.card-front .card-type {
  position: absolute;
  right: 10px;
  background-color: rgba(255, 255, 255, 0.8);
  padding: 2px 6px;
  border-radius: 4px;
  font-weight: bold;
  font-size: 0.85rem;
  z-index: 2;
}

.card-front .card-image {
  width: 100%;
  aspect-ratio: 16 / 12;
  background: linear-gradient(135deg, #cccccc70, #eeeeee70);
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  position: relative;
}

.card-front .card-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: top;
}

.card-front .gen-image-btn {
  position: absolute;
  bottom: 8px;
  right: 8px;
  padding: 4px 8px;
  background-color: rgba(0, 0, 0, 0.6);
  color: #fff;
  border: none;
  border-radius: 4px;
  font-size: 0.8rem;
  z-index: 2;
  box-shadow: none;
  background-image: none;
}

.gen-image-btn:disabled {
  background-color: #999;
  color: #ccc;
  cursor: not-allowed;
  opacity: 0.6;
}

.card-front .card-info {
  padding: 8px;
  display: flex;
  flex-direction: column;
  gap: 4px;
  flex-grow: 1;
  overflow: auto;
  background-color: rgba(255, 255, 255, 0.7);
}

.card-front .card-info p {
  margin: 0;
  font-size: 0.85rem;
}

.card-front .card-info p:last-child {
  padding: 0;
  height: 100%;
  font-size: 0.85rem;
  align-items: center;
  display: flex;
  background-color: #eee;
  margin-top: 10px;
}

.card-front .card-info p:last-child span {
  transform: skew(-5deg);
  display: flex;
  padding: 10px;
}

.card-back {
  box-sizing: border-box;
  background: linear-gradient(135deg, #1e3c72, #2a5298);
  color: #fff;
  transform: rotateY(180deg);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2rem;
  padding: 10px;
  text-align: center;
}

@media (max-width: 600px) {
  #card-container {
    grid-template-columns: repeat(1, 1fr);
  }
}

.bezel {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
  height: 100%;
  width: 100%;
  box-sizing: border-box;
  z-index: 100;
  border-radius: 2%;
  padding: 3%;
}

.bezel.rarity0 {
  background: linear-gradient(145deg, #c0c0c0, #d3d3d3, #e0e0e0, #a9a9a9);
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

.bezel.rarity1 {
  background: linear-gradient(145deg, #b87333, #da8a67, #e97451, #c35817);
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

.bezel.rarity2 {
  background: linear-gradient(145deg, #c0c0c0, #d3d3d3, #e0e0e0, #a9a9a9);
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

.bezel.rarity3 {
  background: linear-gradient(145deg, #b69a00, #ffda64, #ffda6b, #d79000);
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

.bezel.rarity4 {
  position: absolute;
  background: linear-gradient(145deg, #d1d1d1, #aeb9ff, #c0c0c0, #ecebe8);
  background-size: 400% 400%;
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
  animation: platinum-shimmer 5s ease-in-out infinite;
}

.bezel.rarity5 {
  background: linear-gradient(145deg, #4b0082, #0000cd, #008080, #fff);
  background-size: 150% 150%;
  mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
  animation: jewel-glow 5s ease-in-out infinite;
}

@keyframes platinum-shimmer {
  0% {
    background-position: 0% 50%;
  }

  50% {
    background-position: 100% 50%;
  }

  100% {
    background-position: 0% 50%;
  }
}

@keyframes jewel-glow {
  0% {
    filter: brightness(1);
    background-position: 0% 50%;
  }

  50% {
    filter: brightness(1.2);
    background-position: 100% 50%;
  }

  100% {
    filter: brightness(1);
    background-position: 0% 50%;
  }
}

#party-card-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
}

.card.selected .bezel {
  outline: 10px solid #f44336;
  outline-offset: -10px;
  outline: 10px solid #f44336;
  outline-offset: -10px;
  background-image: none;
  -webkit-mask-image: none;
  background-color: #0000004d;
}

.manipulate-panel {
  display: flex;
  flex-direction: column;
  gap: 10px;
  width: 100%;
  justify-content: center;
  align-items: center;
}

.chips-container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.warehouse-tab,
.chip {
  display: inline-flex;
  align-items: center;
  padding: 10px;
  border-radius: 30px;
  background-color: rgba(227, 227, 227, 0.4);
  color: #f0f0f0;

  cursor: pointer;
  user-select: none;
  transition: background-color 0.2s;
  min-width: 6rem;
  justify-content: center;
  background-image: linear-gradient(0deg, #00000061, transparent);
  border: 1px solid #999;
  box-shadow: inset 0px 0px 8px 2px #161616;
}

.chip-mini {
  min-width: 6rem;
}

.chip-withimage {
  min-width: initial;
  border-radius: 2px;
  display: flex;
  flex-direction: row;
  justify-content: left;
  gap: 10px;
}

.chip-withimage img {
  height: 80px;
  border-radius: 40px;
  width: 80px;
  object-fit: cover;
}

.chip:hover {
  border: 1px solid #00d14c;
  background-color: #00d14c;
}

.warehouse-tab.active,
.chip.selected {
  background-color: #009e39;
  color: #fff;
}

.bg-thumb {
  position: relative;
  cursor: pointer;
}

.bg-thumb-delete {
  position: absolute;
  top: 5px;
  right: 5px;
  background-color: rgba(200, 0, 0, 0.7);
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.8rem;
  padding: 4px;
  display: none;
}

.bg-thumb:hover .bg-thumb-delete {
  display: inline-block;
}

.bg-stock-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 16px;
  margin: 20px 0;
}

/* ダミー要素用 */
.dummy {
  visibility: hidden;
  pointer-events: none;
  background-color: transparent;
  border: none;
}

/* レア度3以上で背景画像が大きくなりがちな場合に対応 */
.card.rarity3 .card-front .card-image,
.card.rarity4 .card-front .card-image,
.card.rarity5 .card-front .card-image {
  z-index: 0;
  height: 100%;
  width: 100%;
  display: flex;
  justify-content: right;
  align-items: flex-start;
}

.card.rarity3 .card-front .card-image img,
.card.rarity4 .card-front .card-image img,
.card.rarity5 .card-front .card-image img {
  object-position: bottom;
  opacity: 0.9;
}

.card.rarity3 .card-info,
.card.rarity4 .card-info,
.card.rarity5 .card-info {
  position: absolute;
  box-sizing: border-box;
  width: 100%;
  left: 0;
  bottom: 0;
  padding-left: calc(3% + 8px);
  padding-right: calc(3% + 8px);
  padding-top: 3%;
  padding-bottom: 3%;
  border-radius: 0 0 20px 20px;
  background-color: rgba(37, 37, 37, 0.85);
  color: #fff;
  text-shadow: 0 0 10px #fff;
}

.card.rarity3 .card-front .card-info p:last-child,
.card.rarity4 .card-front .card-info p:last-child,
.card.rarity5 .card-front .card-info p:last-child {
  margin-left: -3%;
  margin-right: -3%;
  background-color: rgba(0, 0, 0, 0.7);
  color: #fff;
}

.card.rarity3 .card-front .card-info p:last-child span,
.card.rarity4 .card-front .card-info p:last-child span,
.card.rarity5 .card-front .card-info p:last-child span {
  padding-top: 20px;
  padding-bottom: 20px;
}

.card.rarity3 .card-front .gen-image-btn,
.card.rarity4 .card-front .gen-image-btn,
.card.rarity5 .card-front .gen-image-btn {
  position: relative;
  left: initial;
  right: 10px;
  bottom: initial;
  top: 100px;
}

#scenario-list-container {
  text-align: right;
  align-items: center;
  display: flex;
  flex-direction: column;
  max-height: 50vh;
  overflow-y: auto;
}

.scenario-list-container,
.scenario-wizard-section,
.api-key-section,
.element-section {
  display: flex;
  flex-wrap: wrap;
  flex-direction: row;
  justify-content: center;
  gap: 10px;
  margin-top: 20px;
  margin-bottom: 20px;
}

.scenario-list {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  width: 100%;
  padding: 20px 10px;
  box-sizing: border-box;
  border: 1px solid #876d51;
}

.accordion-content .scenario-list:first-child {
  border-top: none;
}

.scenario-list + .scenario-list {
  border-top: none;
}

.scenario-list.selected {
  border: 1px solid #ff0;
}

.scenario-list:nth-child(odd) {
  background-color: #00000069;
}

.scenario-list .info {
  display: inline-block;
  line-height: 1.2rem;
  box-sizing: border-box;
  text-align: left;
  width: 100%;
}

.scenario-list .buttons {
  box-sizing: border-box;
  display: flex;
  margin-left: auto;
  flex-direction: row;
  gap: 10px;
  justify-content: right;
  flex-wrap: wrap;
}

.scenario-list .buttons .left-button {
  margin-right: auto;
}

.scenario-wizard-section {
  margin-top: 40px;
  margin-bottom: 40px;
}

.element-section button {
  margin: 0;
}

/* ▼ 倉庫ヘッダー全体の横並びレイアウト */
.warehouse-header-bar {
  display: flex;
  align-items: center;
  justify-content: center;
  /* 画面中央に置きたい場合 */
  width: calc(90% - 40px);
  margin: 0 auto 10px;
  gap: 10px;
  flex-wrap: wrap;
}

.warehouse-left,
.warehouse-center,
.warehouse-right {
  display: flex;
  flex: 1;
  align-items: center;
  gap: 10px;
}

.warehouse-center {
  justify-content: center;
}

.warehouse-left {
  justify-content: left;
}

.warehouse-right {
  justify-content: right;
}

@media (max-width: 700px) {
  .warehouse-tabs {
    flex-wrap: wrap;
    justify-content: center;
  }

  .warehouse-tab {
    min-width: 5rem;
  }

  .warehouse-header-bar {
    flex-direction: column;
    width: 100%;
  }
}

/* タブの見た目 */
.warehouse-tabs {
  display: flex;
  gap: 10px;
}

/* ソートUI */
#warehouse-sort-dropdown {
  box-sizing: border-box;
  height: 3rem;
  background-color: #333;
  color: #fff;
  border: 1px solid #666;
  border-radius: 4px;
  padding: 4px 8px;
  font-size: 0.9rem;
  cursor: pointer;
}

#warehouse-sort-dropdown:focus {
  outline: 2px solid #4caf50;
}

#warehouse-sort-direction-btn {
  width: 36px;
  height: 36px;
  background-color: #333;
  color: #fff;
  border: 1px solid #666;
  border-radius: 4px;
  font-size: 1.1rem;
  cursor: pointer;
  transition: background-color 0.2s;
}

#warehouse-sort-direction-btn:hover {
  background-color: #444;
}

#stop-bgm-button {
  margin: 0;
}

.close-warehouse-btn {
  margin: 0;
  display: flex;
  right: 20px;
  top: 20px;
  min-width: initial;
  min-height: initial;
  position: fixed;
  z-index: 10;
  border-radius: 50%;
  height: 50px;
  width: 50px;
  padding: 0;
  align-items: center;
  justify-content: center;
  max-width: initial;
  max-height: initial;
}

button.important {
  margin: 0;
  background-color: #2196f3;
  font-size: 1.4rem;
  padding: 20px 35px;
  border-color: #2196f3;
}

#start-new-scenario-button:hover {
  background-color: #45a049;
  border-color: #45a049;
}

#toggle-history-button,
#change-bg-button {
  position: relative;
  z-index: 1;
  font-size: 0.7rem;
}

#token-adjust-button {
  position: relative;
  z-index: 1;
}

#back-to-menu {
  position: relative;
  z-index: 1;
  font-size: 0.7rem;
}
#open-tutorial-list-button {
  position: relative;
  margin-right: auto;
}
#save-load-button {
  position: relative;
}
#view-all-sections-button {
  position: absolute;
  z-index: 1;
  left: 20px;
}

#clear-ending-button,
#ending-button {
  position: relative;
}

#get-card-button {
  position: absolute;
  left: 250px;
  margin: 0;
}

#image-auto-generate-button {
  width: 10rem;
}

.r-flexbox {
  display: flex;
  flex-direction: row;
  gap: 10px;
  align-items: center;
  justify-content: right;
}

.l-flexbox {
  display: flex;
  flex-direction: row;
  gap: 10px;
  align-items: center;
  justify-content: left;
}

@media (max-width: 900px) {
  .mobile-col {
    flex-direction: column;
    margin-bottom: 20px;
  }
}

.s-flexbox {
  display: flex;
  flex-direction: row;
  gap: 10px;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 20px;
}

.c-flexbox {
  display: flex;
  flex-direction: row;
  gap: 10px;
  align-items: center;
  justify-content: center;
  margin-bottom: 20px;
}

#player-action {
  margin-bottom: 20px;
}

/* ----- ステップ0のパーティ選択用クラス ----- */

/* 1行ぶんの枠 */
.wizard-party-row {
  display: flex;
  align-items: center;
  margin-bottom: 10px;

  /* 背景を少し透過した感じにするなど */
  background-color: rgba(255, 255, 255, 0.08);
  border-radius: 6px;
  transition: background-color 0.2s;
}

/* ホバー時に少し明るくなる */
.wizard-party-row:hover {
  background-color: rgba(255, 255, 255, 0.15);
}

/* 中にあるラジオボタンを隠して行全体クリックを可能にするための工夫 */
.wizard-party-row input[type='radio'] {
  /* 完全に隠したい場合 (見た目のラジオを後述の擬似要素で作る) */
  display: none;
}

/* ラベル部分 */
.wizard-party-label {
  display: flex;
  align-items: center;
  cursor: pointer;
  width: 100%;
  /* 行全体をラベルにする */
  padding: 10px 15px;
  /* 余白を少し広めに */
  box-sizing: border-box;
}

/* ラジオボタンの擬似要素を表示: before を丸にしてチェック状にする */
.wizard-party-label::before {
  content: '';
  display: inline-block;
  width: 20px;
  height: 20px;
  min-width: 20px;
  min-height: 20px;
  border-radius: 50%;
  border: 2px solid #fff;
  margin-right: 12px;
  transition: background-color 0.1s, border-color 0.1s;
  box-sizing: border-box;
}

/* 選択状態: input[type="radio"]:checked + .wizard-party-label::before で円を塗りつぶす */
.wizard-party-row input[type='radio']:checked + .wizard-party-label::before {
  background-color: #019a39;
  /* 選択時の色 (例: 緑) */
  border-color: #00d14c;
}

/* パーティ画像 */
.wizard-party-label img {
  width: 60px;
  height: 60px;
  object-fit: cover;
  margin-right: 10px;
  border-radius: 4px;
  border: 1px solid #222;
  /* ほんの少し枠をつける */
  background-color: #161616;
}

/* 画像がない場合の No Image box */
.no-image-box {
  width: 60px;
  height: 60px;
  background-color: #555;
  color: #fff;
  margin-right: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  border: 1px solid #222;
}

#confirm-party-text,
#confirm-genre-type-text {
  text-align: left;
  width: 100%;
  margin: 0;
  margin-bottom: 10px;
}

#you-avatar-btn {
  width: 10rem;
}

#avatar-card-preview-container {
  width: 100%;
  display: flex;
  justify-content: center;
  flex-direction: column;
  align-items: center;
  flex: 0.5;
}

#avatar-form-container {
  display: flex;
  width: 100%;
  flex-direction: column;
  justify-content: left;
  align-items: flex-start;
  flex: 1;
}

.accordion-header:hover {
  background-color: #45a049;
  border: 1px solid #45a049;
}

/* アコーディオン全体のラッパ */
.accordion {
}

/* アコーディオンヘッダー */
.accordion-header {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  position: relative;
  text-shadow: 1px 1px 4px #000;
  background-color: #5f4c38;
  color: #fff;
  box-sizing: border-box;
  box-shadow: inset 0px 0px 8px 2px #161616;
  border: 1px solid #876d51;
  background-image: linear-gradient(0deg, #00000061, transparent);
  cursor: pointer;
  padding: 10px 15px;
  user-select: none;
  border-radius: 5px 5px 0 0;
}

/* アコーディオンコンテンツ */
.accordion-content {
  overflow: hidden;
  transition: max-height 0.3s ease, padding 0.3s ease;
  max-height: 0;
  margin-bottom: 0;
}

.accordion-content.open {
  padding: 0;
  margin-bottom: 20px;
  max-height: 50vh;
  overflow-y: auto;
}

#show-hidden-scenarios {
  width: 1rem;
  height: 1rem;
}

.book {
  top: 0px;
  transition: ease 0.3s all;
}

.book:hover {
  top: 0;
  display: flex;
  z-index: 1000;
}

/*
悩み中…
.book::after{
  content: "";
  width: 0px;
  height: 100%;
  border-radius: 0;
  z-index: 100000;
  left: 100%;
  top: 0;
  background-color: #610404;
  transition: ease 0.3s all;}

.book:hover::after{
  width: 10px;
  position: absolute;
  display: flex
;
  transform-origin: left;
}
*/
/* =====================================
   3D 回転のための追加クラス
   （既存の .book は触らず、そのまま利用）
===================================== */
.book-wrapper {
  perspective: 1000px;
  display: inline-block;
  vertical-align: bottom;
  position: relative;
}

.book-inner {
  transform-style: preserve-3d;
  transition: transform 0.7s ease;
  transform-origin: left center;
  height: 200px;
}

.book {
  transform: rotateY(0deg);
  backface-visibility: hidden;
  position: absolute;
  left: 0;
  top: 0;
}

.book-front {
  transform: rotateY(90deg);
  /* ← 重要 */
  transform-origin: 0 0;
  backface-visibility: hidden;
  position: absolute;
  left: 0px;
  top: 0;
  height: 200px;
  /* 7:5比率で */
  width: 170px;
  transition: all 1s ease;
}

.book-front img {
  position: relative;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: center;
  box-shadow: 0 5px 10px -4px #000;
}

.book-wrapper.facing-front .book-inner {
  transform: rotateY(-90deg);
  /* 背表紙 0 + (-90) = -90, 表紙 90 + (-90) = 0 */
}

.book-front-title {
  box-sizing: border-box;
  position: absolute;
  text-wrap: auto;
  background-color: #00000099;
  width: 100%;
  padding: 5px;
  top: 10px;
}

.bookshelf-board {
  width: 100%;
  border-bottom: 25px solid #fff;
  border-image-source: linear-gradient(to right bottom, rgb(219 183 111), rgb(194 134 73));

  flex: 1;
  overflow-x: auto;
  overflow-y: hidden;

  border-bottom: 20px solid;
  border-image-slice: 1;
  border-image-width: 1;
  border-image-outset: 0;
  border-image-repeat: stretch;
}

.book-wrapper.facing-front:last-child {
  padding-right: 140px;
}

/* ドラッグ中のドロップ候補用スタイル */
.book-wrapper.drag-over {
  box-sizing: border-box;
  border-right: 15px solid transparent;
  border-image-slice: 1;
  border-image-width: 5px;
  border-image-outset: 0;
  border-image-repeat: stretch;
  border-image-source: linear-gradient(to left, #fff 0px, #fff 20px, rgba(0, 0, 0, 0) 20px, rgba(0, 0, 0, 0) 100%);
}

#edit-scenario-covercolor1,
#edit-scenario-covercolor2 {
  padding: 0;
}

/* ================================
   シナリオ編集モーダル用の調整
================================ */

/* モーダル全体のコンテンツ幅をやや狭く & 中央寄せ */
.edit-scenario-modal-content {
  margin: 0 auto;
  text-align: left;
  /* 左寄せにすると入力欄が見やすい */
}

/* モーダルのタイトルと入力欄・ボタン間に余白 */
.edit-scenario-modal-content h3 {
  margin-top: 0;
  margin-bottom: 1rem;
}

/* 各行ごとにラベルと入力欄を横並び */
.edit-row {
  display: flex;
  align-items: center;
  max-width: 400px;
  margin-bottom: 1rem;
  flex-wrap: wrap;
  /* 狭い画面のとき折り返す */
  justify-content: center;
}

/* ラベルの幅・右余白などを統一 */
.edit-row label {
  margin: 0;
  white-space: nowrap;
  font-size: 1rem;
  /* お好みで */
  width: 100%;
}

/* ラジオボタン群は同じ行に2つ並べるだけ */
.radio-group label {
  margin-right: 16px;
  display: flex;
  align-items: center;
  gap: 4px;
}

/* カラーピッカーにあまり余計なpaddingをつけない */
#edit-scenario-covercolor1,
#edit-scenario-covercolor2 {
  width: 40px;
  height: 40px;
  margin: 0;
  padding: 0;
  border: 1px solid #ccc;
  cursor: pointer;
}

/* ボタンを横並び + 中央寄せに */
.modal-buttons {
  display: flex;
  justify-content: center;
  gap: 1rem;
  margin-top: 1rem;
}

.application-bar {
  position: fixed;
  display: flex;
  gap: 10px;
  top: 0;
  background-color: rgba(0, 0, 0, 0.7);
  width: 100%;
  z-index: 100;
  justify-content: right;
  box-shadow: 0 0 8px #000;
  padding: 10px;
  box-sizing: border-box;
  flex-wrap: wrap;
}

.application-bar button {
  line-height: 1.5rem;
  min-width: 4rem;
}

#last-scene-images img {
  max-height: 50vh;
  max-width: 100%;
  object-fit: contain;
}

.image-container {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 10px;
  object-fit: contain;
}

#entity-list-container {
  min-width: 60%;
  font-family: serif;
}
#entity-list-container h3 {
  font-family: initial;
  margin-top: 40px;
  margin-bottom: 20px;
  font-size: 1.2rem;
  font-weight: normal;
  border-bottom: 1px solid;
}

#entity-list-container h4 {
  font-family: initial;
  margin: 0;
  font-size: 1.2rem;
  font-weight: normal;
}
#entity-generate-button {
  margin: 0 auto;
}

.info-row {
  padding: 10px;
}
#entity-list-container .info-row {
  padding: 20px;
}
#entity-list-container .info-row:nth-child(odd) {
  background-color: #2d2d2d96;
}
.scene-dropdown-menu {
  display: flex;
  flex-wrap: nowrap;
  font-size: 0;
}
/* =========================
   画像ビューワ用の追加分
========================= */

/* 画像ビューア用モーダル本体 */
.image-viewer-modal {
  /* 通常の .modal と同じ仕組みを使うので特に追加指定しない */
}

.image-viewer-modal-content {
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;

  /* モーダル全体を黒背景、余白ナシで中央配置 */
  background-color: #000000d0;
  padding: 0;
  border-radius: 0;
  width: 100%;
  max-width: 100%;
  max-height: 100vh;
  overflow: hidden;
}

/* 拡大表示する画像 */
.viewer-image {
  object-fit: contain;
  max-width: 100%;
  max-height: 100%;
  transition: transform 0.2s ease;
  background-color: transparent;
  cursor: pointer; /* タップでコントロール表示 */
}

/* コントロール（削除/ダウンロード/閉じる）を中央や下部に重ねる */
.viewer-controls {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none; /* 全体はクリック無効にしてボタンだけ有効にする */
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

/* 非表示時 */
.viewer-controls.hidden {
  display: none;
}

/* 中央に並ぶ削除/ダウンロードボタン */
.viewer-controls .center-buttons {
  pointer-events: auto; /* ここだけクリック可能 */
  display: flex;
  gap: 20px;
  margin-bottom: 20px;
  flex-direction: row;

  background-color: rgba(0, 0, 0, 0.6);
  padding: 10px 20px;
  border-radius: 4px;
}

/* 閉じるボタンは下寄せ */
.close-button-container {
  pointer-events: auto; /* クリック有効 */
  margin-top: 20px;
}

.close-button-container button {
  background-color: rgba(0, 0, 0, 0.6);
  border-color: #ccc;
}

/* ==== 以下、カルーセル追加スタイル ==== */
.carousel-wrapper {
  margin-top: 0;
  background-color: transparent;
}
.carousel-tabs-scrollable {
  overflow-x: auto;
  overflow-y: hidden;
  white-space: nowrap;
  margin-bottom: 10px;
}
.carousel-tabs {
  display: inline-flex;
  gap: 8px;
  flex-wrap: nowrap;
}
.carousel-tab {
  background-color: #222;
  color: #eee;
  border-radius: 4px;
  border: 1px solid #666;
  padding: 8px 16px;
  cursor: pointer;
  flex-shrink: 0;
  user-select: none;
}
.carousel-tab.active {
  background-color: #005f24;
}
.carousel-viewport {
  overflow: hidden;
  position: relative;
  margin-left: -20px;
  margin-right: -20px;
}
.carousel-track {
  display: flex;
  transition: transform 0.3s;
  will-change: transform;
  touch-action: pan-y; /* 縦スクロールを妨げないように */
}
.carousel-cell {
  box-sizing: border-box;
  width: 100%;
  flex-shrink: 0;
  box-sizing: border-box;
  padding: 20px;
  background-color: rgba(0, 0, 0, 0.3);
  border: 1px solid #333;
}
.carousel-cell h3 {
  margin-top: 0;
}

#action-candidates-container {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}

/* オーバーレイ */
#tutorial-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.4);

  /* z-indexはモーダルより上/下など適宜調整 */
  z-index: 9998;

  /* クリックを完全に透過する */
  pointer-events: none;

  display: none; /* 初期は非表示、表示したいときにJSでblockに */
}

/* チュートリアルダイアログ */
#tutorial-dialog {
  position: fixed;
  z-index: 19999;
  pointer-events: auto; /* ダイアログ内部はクリック可 */
  width: 300px;
  padding: 15px;
  background-color: rgba(255, 242, 207, 0.88);
  box-sizing: border-box;

  display: none; /* 初期は非表示 */
  opacity: 0;
  transition: opacity 0.25s;
}

/* ハイライト */
.tutorial-highlight {
  box-shadow: 0 0 10px 5px yellow;
  position: relative !important;
  z-index: 19999 !important;

  /* クリックを透過する */
}

.step-title {
  font-size: 0.8rem;
  text-align: left;
  color: #555;
}

.step-message {
  font-size: 1.2rem;
  margin-top: 20px;
  margin-bottom: 20px;
}

.step-skip-container {
  margin-top: 5px;
  display: flex;
  flex-direction: row;
  justify-content: left;
  align-items: center;
}

.step-skip-container input[type='checkbox'] {
  margin: 0;
  height: 1rem;
  width: 1rem;
}
.step-skip-container label {
  padding: 5px;
}

#tutorial-next-btn {
  background-color: #4caf50;
  border: 1px solid #45a049;
  box-shadow: none;
}

/* =======================
   ここから本題のドロップダウン用スタイル
======================= */
/* front-menu-button: 本の正面にマウスオーバーで表示される「...」ボタン */
.front-menu-button {
  position: absolute;
  right: 8px;
  bottom: 8px;
  background-color: #5f4c38;
  border: 1px solid #876d51;
  border-radius: 20px;
  box-shadow: inset 0px 0px 8px 2px #161616;
  background-image: linear-gradient(0deg, #00000061, transparent);
  width: 40px;
  height: 40px;
  font-size: 1.2rem;
  color: #fff;
  display: none; /* 初期は非表示 */
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 10;
}

/* front-dropdown-menu: ドロップダウン本体 */
.front-dropdown-menu {
  position: absolute;
  display: none;
  flex-direction: column;
  min-width: 140px;
  background-color: #5f4c38;
  border: 1px solid #876d51;
  border-radius: 4px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  padding: 5px 0;
  z-index: 999;
}

.front-dropdown-menu.open {
  display: flex;
}

/* 個別のメニューアイテム */
.front-dropdown-menu button {
  background-color: #5f4c38;
  border: none;
  width: 100%;
  text-align: left;
  padding: 10px;
  color: #fff;
  font-size: 0.9rem;
  border-bottom: 1px solid #876d51;
  cursor: pointer;
  box-shadow: inset 0px 0px 8px 2px #161616;
  background-image: linear-gradient(0deg, #00000061, transparent);
}

.front-dropdown-menu button:hover {
  background-color: #45a049 !important;
  border: 1px solid #45a049 !important;
  border-radius: 0;
}

.front-dropdown-menu button:last-child {
  border-bottom: none;
}

/* 既存とは別に、ポータル用コンテナを定義する */
#dropdown-portal {
  box-sizing: border-box;
  position: absolute; /* ボタンクリック時にJSでtop/leftを計算して指定 */
  display: none; /* 初期は非表示 */
  flex-direction: column;
  min-width: 170px;
  background-color: #5f4c38;
  border: 1px solid #876d51;
  border-radius: 4px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  padding: 5px;
  z-index: 9999; /* 最前面に */
}

/* ポータルを開く時は .open を付与して表示 */
#dropdown-portal.open {
  display: flex;
}

/* ドロップダウン内部のボタン */
#dropdown-portal button {
  background-color: #5f4c38;
  border: none;
  width: 100%;
  text-align: left;
  padding: 10px;
  color: #fff;
  font-size: 0.9rem;
  border-bottom: 1px solid #876d51;
  cursor: pointer;
  box-shadow: inset 0px 0px 8px 2px #161616;
  background-image: linear-gradient(0deg, #00000061, transparent);
}

#dropdown-portal button:hover {
  background-color: #45a049 !important;
  border: 1px solid #45a049 !important;
  border-radius: 0;
}

#dropdown-portal button:last-child {
  border-bottom: none;
}

#warehouse-modal {
  justify-content: flex-start;
}

/* universalSaveLoad用のスロット一覧 */
#slot-container {
  margin: 0 auto;
  display: flex;
  flex-direction: column;
  max-width: 400px;
  gap: 10px;
  margin-bottom: 20px;
}
#slot-items-container {
  background-color: rgba(0, 0, 0, 0.4);
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
#add-slot-button {
  width: 100%;
  border: none !important;
  background-color: rgba(255, 255, 255, 0.08);
  min-height: initial;
  border-radius: 0;
  line-height: 2rem;
  padding: 0;
}
#add-slot-button:hover {
  border: none !important;
  box-shadow: none;
  background-color: rgba(0, 255, 55, 0.39) !important;
}

.save-slot-row-container {
  display: flex;
  width: 100%;
  flex-direction: row;
}
.save-slot-row-container button {
  border: none;

  min-width: initial;
  min-height: initial;
  background: none;
  box-shadow: none;
  background-color: rgba(255, 255, 255, 0.08);
  border-radius: 0;
}
.save-slot-row-container button:hover {
  border: none !important;
  background-color: rgb(255 0 0 / 39%) !important;

  min-width: initial;
  min-height: initial;
  background: none;
}

.save-slot-row-container button .iconmoon {
  font-size: 0.5rem !important;
}
.save-slot-row {
  display: flex;
  align-items: center;
  background-color: rgba(255, 255, 255, 0.08);
  border-radius: 4px;
  transition: background-color 0.2s;
  margin-right: auto;
  flex: 1;
}
.save-slot-row:hover {
  background-color: rgba(255, 255, 255, 0.15);
}
.save-slot-row input[type='radio'] {
  display: none;
}
.save-slot-row label {
  cursor: pointer;
  padding: 10px;
  width: 100%;
  font-size: 0.9rem;
  display: flex;
  align-items: center;
  text-align: left;
}
.save-slot-row label::before {
  content: '';
  display: inline-block;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 2px solid #bbb;
  margin-right: 10px;
  box-sizing: border-box;
  transition: background-color 0.2s, border-color 0.2s;
}
.save-slot-row input[type='radio']:checked + label::before {
  background-color: #4caf50;
  border-color: #4caf50;
}

#info-modal {
  z-index: 9998;
}

#loading-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  /* 大きな値を設定 */
  z-index: 999999;
  display: none; /* 初期非表示 */
}

#loading-modal.active {
  display: flex; /* or block */
  justify-content: center;
  align-items: center;
}
/* ================================
   Gemini モデル選択 UI 用のスタイル
   ================================ */
.model-selector {
  display: flex;
  flex-wrap: wrap; /* スマホ表示などで折り返すように */
  align-items: center; /* 要素を縦方向に中央揃え */
  gap: 10px; /* 要素間のスペース */
  padding: 15px; /* 内側の余白 */
  background-color: rgba(0, 0, 0, 0.2); /* 少し背景色をつける */
  border-radius: 5px; /* 角を丸める */
  margin-top: 20px; /* 上の要素とのマージン */
  margin-bottom: 20px; /* 下の要素とのマージン */
}

.model-selector label {
  margin-right: 5px; /* ラベルとセレクトボックスの間のスペース */
  white-space: nowrap; /* ラベルが折り返さないように */
  color: #f0f0f0; /* 文字色 */
}

.model-selector select {
  padding: 8px; /* 内側の余白 */
  border-radius: 4px; /* 角を丸める */
  border: 1px solid #666; /* 枠線 */
  background-color: #444; /* 背景色 */
  color: #fff; /* 文字色 */
  min-width: 200px; /* 最低限の幅 */
  flex-grow: 1; /* 利用可能なスペースがあれば伸びる */
  cursor: pointer; /* カーソルをポインターに */
}

.model-selector select:disabled {
  opacity: 0.7; /* 無効時は少し薄く */
  cursor: not-allowed; /* 無効時のカーソル */
}

.model-selector button {
  /* 既存のボタンスタイルを継承しつつ、微調整 */
  padding: 8px 12px; /* パディング調整 */
  min-height: initial; /* 高さを自動調整 */
  min-width: initial; /* 幅を自動調整 */
  /* 既存のボタンに合わせて line-height なども調整すると良い */
}

.model-description {
  font-size: 0.85rem; /* 文字サイズ */
  color: #ccc; /* 文字色 */
  margin-top: 10px; /* 上の要素とのスペース */
  width: 100%; /* 横幅いっぱいを使う */
  line-height: 1.4; /* 行間 */
  flex-basis: 100%; /* 常に改行させる */
}

.pricing-link {
  font-size: 0.8rem; /* 文字サイズ */
  margin-top: 5px; /* 上の要素とのスペース */
  width: 100%; /* 横幅いっぱいを使う */
  flex-basis: 100%; /* 常に改行させる */
  text-align: right; /* 右寄せにする（任意） */
}

.pricing-link a {
  color: #aaa; /* リンクの色 */
  text-decoration: none; /* 下線を消す */
}
.pricing-link a:hover {
  color: #fff; /* ホバー時の色 */
  text-decoration: underline; /* ホバー時に下線を表示 */
}

/* ================================
   参考 script.js のメッセージ表示用スタイル
   (既存のスタイルと競合する場合は調整してください)
   ================================ */
.story-history {
  /* チャット履歴のコンテナ (もし使う場合) */
  /* border: 1px solid #555; */
  /* padding: 10px; */
  /* height: 400px; */
  /* overflow-y: auto; */
  /* margin-bottom: 15px; */
  /* background-color: rgba(0, 0, 0, 0.1); */
}

.message {
  /* 個々のメッセージ */
  padding: 8px;
  margin-bottom: 8px;
  border-radius: 4px;
  line-height: 1.6;
}

.message.user {
  /* ユーザーの発言 */
  background-color: rgba(76, 175, 80, 0.2); /* 緑系の背景 */
  text-align: right;
}

.message.model {
  /* モデルの応答 */
  background-color: rgba(33, 150, 243, 0.2); /* 青系の背景 */
  text-align: left;
}

.message strong {
  /* 役割表示 (あなた: / 物語:) */
  display: block;
  margin-bottom: 4px;
  font-size: 0.9em;
  color: #aaa;
}

.loading {
  /* 生成中表示 (もし使う場合) */
  /* text-align: center; */
  /* color: #888; */
  /* margin-top: 10px; */
}

.error-message {
  /* エラーメッセージ表示 (もし使う場合) */
  /* color: #f44336; */
  /* text-align: center; */
  /* margin-top: 10px; */
  /* background-color: rgba(244, 67, 54, 0.1); */
  /* padding: 8px; */
  /* border-radius: 4px; */
}
/* styles.css に追加 */

.favorite-btn {
  padding: 0px;
  margin-right: 10px;
  background: none !important; /* !important で他のボタンスタイルを上書き */
  border: none !important;
  box-shadow: none !important;
  min-width: initial !important; /* 幅はアイコンに合わせる */
  min-height: initial !important; /* 高さは自動 */
  cursor: pointer;
  vertical-align: middle; /* 他のテキストと高さを合わせる */
  font-size: 1.2rem; /* アイコンサイズ */
  line-height: 1rem; /* 行の高さをアイコンに合わせる */
  color: #ccc; /* 通常の色 */
  transition: color 0.2s, transform 0.2s; /* 色とサイズの変化を滑らかに */
}

.favorite-btn:hover {
  background-color: transparent !important;
  border: none !important;
  color: gold !important; /* ホバー時の色 */
}

/* お気に入り状態のスタイル */
.scenario-list.is-favorite .favorite-btn {
  color: gold; /* お気に入り時の色 */
}

/* アイコンフォントのスタイル (icomoonに合わせて調整) */
.favorite-btn .iconmoon {
  vertical-align: middle;
}
/* .icon-star-full:before { content: "\e9d9"; } */ /* icomoonの定義を確認 */
---
