貴方は会社の中で一番のエンジニアです。
最下部にアプリケーションのソースを添付しました。
・
・
・
・
・
・
以上を実施し、編集しないファイルを除き完全なコードを下さい。しかしながら、最高の成果物を出すために、少しでも不明な点があれば質問をください。

scenario.html
<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8" />
  <title>one and only</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <!-- 黒背景 + 白文字ベースのCSS -->
  <link rel="stylesheet" href="styles.css" />
  <!-- サニタイズ -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@2/dist/purify.min.js"></script>
  <!-- zip -->
  <script src="https://cdn.jsdelivr.net/npm/pako/dist/pako.min.js"></script>
  <!-- 雑多 -->
  <script src="js/common.js"></script>
  <!-- multiModal.js -->
  <script src="js/multiModal.js"></script>
  <!-- 背景管理用 -->
  <script src="js/background.js"></script>
  <!-- 取説 -->
  <script src="js/tutorialData.js"></script>
  <script src="js/tutorialManager.js"></script>
  <script src="js/universalSaveLoad.js"></script>

</head>

<body>
  <div class="application-bar">
    <!-- メニューに戻るボタン -->
    <button id="back-to-menu">
      <div class="iconmoon icon-home3"></div>戻る
    </button>
    <!-- 取説一覧ページへ遷移するボタン -->
    <button id="open-tutorial-list-button">
      <div class="iconmoon icon-book"></div>取説
    </button>
    <button id="save-load-button">
      <div class="iconmoon icon-address"></div>
      続き
    </button>
    <!-- 背景を変更するボタン -->
    <button id="change-bg-button">
      <div class="iconmoon icon-picture"></div>背景
    </button>
  </div>
  <!-- ▼ トークン調整ボタン -->
  <!--button id="token-adjust-button">トークン調整</button-->
  <!-- トークン調整モーダル -->
  <div id="token-adjust-modal" class="modal">
    <div class="modal-content" style="max-width:500px;">
      <h2>英語データの生成</h2>
      <p id="token-adjust-message"></p>
      <button id="token-adjust-ok-button">OK</button>
      <button id="token-adjust-cancel-button">キャンセル</button>
      <p id="token-adjust-progress" style="margin-top:20px;white-space:pre;"></p>
    </div>
  </div>

  <!-- ネタバレボタン（目的達成型のみ表示） -->
  <!--button id="spoiler-button" style="display:none; background-color:#E91E63; margin-top:20px; float:right;">
  ネタバレ</button-->
  
  <div class="container">
    <!-- シーン履歴 (初期非表示) -->
    <div id="scene-history" class="scene-history" style="display:none;"></div>

    <!-- ゲーム画面セクション -->
    <div class="game-section" style="display:none;">
      <div id="story" style="margin-bottom:20px;"></div>
      <div id="last-scene-images" style="margin-bottom:20px;"></div>
      <div id="last-scene-added" class="r-flexbox"></div>

      <div id="player-action">プレイヤーの行動を入力してください</div>
      <!-- ▼ ここからカルーセル追加 -->
      <div class="carousel-wrapper">
        <!-- タブ部分（横スクロール可能） -->
        <div class="carousel-tabs-scrollable">
          <div class="carousel-tabs">
            <!-- 将来タブを増やせるようにボタンを並べる -->
            <button class="carousel-tab active" data-carousel-target="0">
              通常
            </button>
            <button class="carousel-tab" data-carousel-target="1">
              アイテム
            </button>
          </div>
        </div>

        <!-- スライド本体（ループに対応しやすいようにクローンを仕込む）-->
        <div class="carousel-viewport">
          <div class="carousel-track">
            <!-- 1枚目 -->
            <div class="carousel-cell" data-cell-index="0">

              <!-- 回答候補のチェックボックス -->
              <div style="display: flex; margin-bottom: 10px;">
                <label style="margin-left:10px;display: flex;">
                  <input type="checkbox" id="auto-generate-candidates-checkbox" style="margin: 0;" />
                  <p style="width: 100%;margin: 0;padding: 5px 0 5px 10px;">AIが選択肢を作成する</p>
                </label>
              </div>
              <div style="display: flex;flex-direction: column;gap: 10px;">
                <div id="action-candidates-container"></div>
                <textarea id="player-input" rows="4" placeholder="プレイヤーの行動を入力..."></textarea>
                <div class="c-flexbox" style="margin-bottom: 0;">
                  <button id="next-scene" class="important" style="display:none; ">次のシーン</button>
                </div>

                <div class="c-flexbox">
                  <!-- ▼ エンディング関連ボタン&モーダル（追加） -->
                  <button id="ending-button" style="display:none;">エンディング</button>
                  <button id="clear-ending-button" style="display:none;">クリア・エンディング</button>
                </div>
              </div>
            </div>
            <!-- 2枚目 -->
            <div class="carousel-cell" data-cell-index="1">
              <div style="display: flex;flex-direction: column;gap: 10px;">
                <!-- ▼ ここにアイテムのchipsを並べる -->
                <div id="item-chips-container" class="chips-container"></div>
                <!-- アイテム使用ボタン -->
                <div class="c-flexbox" style="margin-bottom: 0;">
                  <button id="use-item-button" class="important">アイテム使用</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <!-- ▲ カルーセル追加ここまで -->

    </div>

  </div>

  <!-- 全セクションを閲覧するボタン -->
  <button id="view-all-sections-button">全セクションを閲覧する</button>

  <!-- ローディングモーダル -->
  <div id="loading-modal" class="modal">
    <div class="modal-content">
      <p>応答を待っています...</p>
      <button id="cancel-request-button" onclick="onCancelFetch()">キャンセル</button>
    </div>
  </div>

  <!-- 探索型の場合のみ表示される「カードを取得」ボタン -->
  <button id="get-card-button" style="display:none;">
    カードを取得する
  </button>

  <!-- スクリプト群 -->
  <script src="js/indexedDB.js"></script>
  <script src="js/sceneMain.js"></script>
  <script src="js/carousel.js"></script>
  <script src="js/sceneGlobals.js"></script>
  <script src="js/sceneManager.js"></script>
  <script src="js/sceneExtras.js"></script>
  <script src="js/sceneUI.js"></script>
</body>

</html>---
common.js
/*******************************************************
 * common.js
 * アプリ全体で使い回す共通関数をまとめるファイルです。
 *******************************************************/

/**
 * 簡易トーストメッセージの表示
 * （画面右下にふわっと3秒ほど出す）
 */
function showToast(message) {
  // 既存トーストがあれば削除
  const oldToast = document.getElementById("toast-message");
  if (oldToast) {
    oldToast.remove();
  }

  // 新規トースト要素を作成
  const toast = document.createElement("div");
  toast.id = "toast-message";
  toast.textContent = message;

  // スタイル設定
  toast.style.position = "fixed";
  toast.style.bottom = "20px";
  toast.style.left = "50%";
  toast.style.transform = "translateX(-50%)";
  toast.style.backgroundColor = "rgba(0, 0, 0, 0.8)";
  toast.style.color = "#fff";
  toast.style.padding = "10px 20px";
  toast.style.borderRadius = "4px";
  toast.style.fontSize = "14px";
  toast.style.zIndex = "9999";
  toast.style.opacity = "0";
  toast.style.transition = "opacity 0.3s ease";

  document.body.appendChild(toast);

  // フェードイン
  requestAnimationFrame(() => {
    toast.style.opacity = "1";
  });

  // 3秒後にフェードアウトして削除
  setTimeout(() => {
    toast.style.opacity = "0";
    toast.addEventListener("transitionend", () => {
      toast.remove();
    });
  }, 3000);
}
window.addEventListener("DOMContentLoaded", async () => {

  // 「取説」ボタンのクリックで tutorialList.html へ遷移
  const tutorialButton = document.getElementById("open-tutorial-list-button");
  tutorialButton.addEventListener("click", () => {
    window.location.href = "tutorialList.html";
  });
});---
multiModal.js
// multiModal.js
// 複数同時表示を可能にする簡易サンプル

class ModalInstance {
  constructor(options) {
    this.options = { ...options };  // 必要に応じてデフォルトをマージ
    this.modalBackdrop = null;
    this.modalContainer = null;
    this.isOpen = false;
  }

  open() {
    // まだDOMを作っていなければ生成
    if (!this.modalBackdrop) {
      this.createDOM();
    }
    // オプションを反映
    this.applyAppearanceType(this.options.appearanceType || "center");
    this.fillContents();

    // z-index の上積み (他のモーダルより前面に出す)
    // 既存モーダル数に応じて足す方法など、色々工夫可
    const baseZ = 9999;
    const topZ = baseZ + getOpenedModalCount() * 2; 
    this.modalBackdrop.style.zIndex = topZ;
    this.modalContainer.style.zIndex = topZ + 1;

    // 表示
    this.modalBackdrop.style.display = "block";
    this.isOpen = true;

    // モーダル外クリックでキャンセル
    if (this.options.closeOnOutsideClick) {
      this.modalBackdrop.addEventListener("click", this.onBackdropClick);
    }
    // 管理用リストに追加
    addToGlobalModalList(this);
    
    // ★ ここで onOpen があれば呼ぶ
    //    (少し遅延させることで、DOM反映直後に確実に実行)
    if (typeof this.options.onOpen === "function") {
      setTimeout(() => {
        this.options.onOpen();
      }, 0);
    }
  }

  createDOM() {
    // バックドロップ
    this.modalBackdrop = document.createElement("div");
    this.modalBackdrop.className = "mmodal-backdrop";
    Object.assign(this.modalBackdrop.style, {
      position: "fixed",
      top: "0", left: "0",
      width: "100%", height: "100%",
      backgroundColor: "rgba(0, 0, 0, 0.7)",
      display: "none"
    });

    // コンテナ
    this.modalContainer = document.createElement("div");
    this.modalContainer.className = "mmodal-container";
    Object.assign(this.modalContainer.style, {
      position: "absolute",
      backgroundColor: "rgba(0,0,0,0.8)",
      color: "#fff",
      padding: "20px",
      borderRadius: "5px",
      width: "calc(100% - 20px)",
      boxSizing: "border-box",
      overflow: "auto",
      maxHeight: "100vh"
    });

    // バックドロップにコンテナをネスト → body へ追加
    this.modalBackdrop.appendChild(this.modalContainer);
    document.body.appendChild(this.modalBackdrop);

    // bind用
    this.onBackdropClick = this.onBackdropClick.bind(this);
  }

  applyAppearanceType(type) {
    if (type === "center") {
      this.modalContainer.style.top = "50%";
      this.modalContainer.style.left = "50%";
      this.modalContainer.style.transform = "translate(-50%, -50%)";
    } else if (type === "top") {
      this.modalContainer.style.top = "0";
      this.modalContainer.style.left = "50%";
      this.modalContainer.style.transform = "translate(-50%, 0)";
    }
    // ほかのデザインにも対応したければここで追加
  }

  fillContents() {
    // いったんコンテナ内クリア
    this.modalContainer.innerHTML = "";

    // タイトル
    if (this.options.title) {
      const h2 = document.createElement("h2");
      h2.textContent = this.options.title;
      this.modalContainer.appendChild(h2);
    }

    // 内容
    if (this.options.contentHtml) {
      const cdiv = document.createElement("div");
      cdiv.innerHTML = this.options.contentHtml;
      this.modalContainer.appendChild(cdiv);
    }

    // 右上×
    if (this.options.showCloseButton) {
      const closeBtn = document.createElement("button");
      closeBtn.textContent = "×";
      Object.assign(closeBtn.style, {
        position: "absolute",
        top: "10px",
        right: "10px",
        background: "transparent",
        border: "none",
        color: "#fff",
        fontSize: "1.2rem",
        cursor: "pointer"
      });
      closeBtn.addEventListener("click", () => this.cancel());
      this.modalContainer.appendChild(closeBtn);
    }

    // ボタン群
    const btnArea = document.createElement("div");
    Object.assign(btnArea.style, {
      display: "flex",
      justifyContent: "center",
      gap: "10px",
      marginTop: "20px"
    });

    // その他ボタン
    if (Array.isArray(this.options.additionalButtons)) {
      for (const bcfg of this.options.additionalButtons) {
        const b = document.createElement("button");
        b.textContent = bcfg.label || "ボタン";
        b.addEventListener("click", () => {
          if (bcfg.onClick) bcfg.onClick();
        });
        btnArea.appendChild(b);
      }
    }

    // キャンセルボタン
    if (typeof this.options.cancelLabel === "string") {
      const cancelBtn = document.createElement("button");
      cancelBtn.textContent = this.options.cancelLabel;
      cancelBtn.addEventListener("click", () => this.cancel());
      btnArea.appendChild(cancelBtn);
    }

    // OKボタン
    if (typeof this.options.okLabel === "string") {
      const okBtn = document.createElement("button");
      okBtn.textContent = this.options.okLabel;
      okBtn.addEventListener("click", () => this.ok());
      btnArea.appendChild(okBtn);
    }

    this.modalContainer.appendChild(btnArea);
  }

  onBackdropClick(e) {
    if (e.target === this.modalBackdrop) {
      this.cancel();
    }
  }

  ok() {
    // コールバック呼び出し → close
    if (this.options.onOk) {
      this.options.onOk();
    }
    this.close();
  }

  cancel() {
    // コールバック呼び出し → close
    if (this.options.onCancel) {
      this.options.onCancel();
    }
    this.close();
  }

  close() {
    if (!this.isOpen) return;
    this.isOpen = false;

    // DOM除去
    if (this.modalBackdrop && this.modalBackdrop.parentNode) {
      this.modalBackdrop.parentNode.removeChild(this.modalBackdrop);
    }
    // モーダルリストから除去
    removeFromGlobalModalList(this);
  }
}

// 下記2つのヘルパーは「現在開いているモーダルの数」を確認するなどのためのもの。
const globalModalList = [];
function addToGlobalModalList(modalInstance) {
  globalModalList.push(modalInstance);
}
function removeFromGlobalModalList(modalInstance) {
  const i = globalModalList.indexOf(modalInstance);
  if (i >= 0) {
    globalModalList.splice(i, 1);
  }
}
function getOpenedModalCount() {
  return globalModalList.length;
}

// 使いやすいように export的なオブジェクトにまとめる
window.multiModal = {
  /**
   * newしてopenするだけのラッパ
   */
  open(options) {
    const m = new ModalInstance(options);
    m.open();
    return m; // この戻り値から m.close() なども可能
  }
};
  ---
background.js
// background.js

// グローバルに保持しておく
let currentPageName = "index"; // デフォルトは index

/**
 * 初期化処理：ページロード後に呼び出し
 * pageName は例："index", "characterCreate", "partyCreate"など
 */
async function initBackground(pageName = "index") {
  currentPageName = pageName;

  // localStorage から そのページ専用のID または "none" を読み取り
  let selectedId = localStorage.getItem("selectedBgId_" + pageName);

  // なければ index 用にフォールバック（ただし "none" は除く）
  if (!selectedId) {
    const fallbackId = localStorage.getItem("selectedBgId_index");
    if (fallbackId && fallbackId !== "none") {
      selectedId = fallbackId;
    }
  }

  // もし最終的に selectedId があれば適用
  if (selectedId) {
    if (selectedId === "none") {
      document.body.style.backgroundImage = "none";
    } else {
      // DBからidに対応する画像を取得して適用
      const imgId = parseInt(selectedId, 10);
      if (!isNaN(imgId)) {
        const img = await getBgImageById(imgId);
        if (img && img.dataUrl) {
          document.body.style.backgroundImage = `url(${img.dataUrl})`;
          document.body.style.backgroundSize = "cover";
          document.body.style.backgroundAttachment = "fixed";
          document.body.style.backgroundPositionX = "center";
        }
      }
    }
  }

  // イベントを付与
  const changeBgBtn = document.getElementById("change-bg-button");
  if (changeBgBtn) {
    changeBgBtn.addEventListener("click", onChangeBgButtonClick);
  }
}

/**
 * 背景を変更するボタンのクリック時
 */
async function onChangeBgButtonClick() {
  const all = await getAllBgImages();
  if (all.length === 0) {
    // ストックが無ければ → 生成してから開く
    await generateNewBackground();
  }
  // モーダルを開く
  openBgModal();
}

/**
 * 新規背景生成
 */
async function generateNewBackground() {
  // 1) 「背景画像を生成中...」のモーダルを開く
  let generatingModal = multiModal.open({
    title: "背景画像を生成中",
    contentHtml: `<p>しばらくお待ちください...</p>`,
    showCloseButton: false,
    closeOnOutsideClick: false
  });

  try {
    const apiKey = localStorage.getItem("apiKey") || "";
    if (!apiKey) {
      // APIキー未設定なら警告モーダルを出す
      generatingModal.close();
      multiModal.open({
        title: "エラー",
        contentHtml: "<p>APIキーが設定されていません。</p>",
        cancelLabel: "閉じる"
      });
      return;
    }

    // ▼ 「最新シナリオ」から取得したpromptを使う
    let promptText = await fetchLatestScenarioPrompt();
    if (!promptText) {
      // シナリオが無いor失敗した場合は従来の固定文言
      promptText = "A beautiful scenic landscape or architecture, highly detailed, no text";
    }

    // 例として DALL-E3 API呼び出し
    const response = await fetch("https://api.openai.com/v1/images/generations", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${apiKey}`
      },
      body: JSON.stringify({
        model: "dall-e-3",
        prompt: promptText,
        n: 1,
        size: "1024x1024",
        response_format: "b64_json"
      })
    });
    const data = await response.json();
    if (data.error) {
      throw new Error(data.error.message);
    }
    const base64 = data.data[0].b64_json;
    const dataUrl = "data:image/png;base64," + base64;

    // DBに保存
    const newId = await addBgImage(dataUrl);

    // 生成後、即適用
    document.body.style.backgroundImage = `url(${dataUrl})`;
    document.body.style.backgroundSize = "cover";
    document.body.style.backgroundAttachment = "fixed";
    document.body.style.backgroundPositionX = "center";

    // 今ページ専用のキーに保存
    localStorage.setItem("selectedBgId_" + currentPageName, newId.toString());

    // index で「none」以外を設定したら、他ページの "none" 設定を削除
    if (currentPageName === "index") {
      removeAllNoneSettingsExceptIndex();
    }

  } catch (err) {
    console.error("背景生成失敗:", err);
    generatingModal.close(); // 一旦閉じる
    // エラーダイアログ
    multiModal.open({
      title: "背景生成失敗",
      contentHtml: `<p>${DOMPurify.sanitize(err.message)}</p>`,
      cancelLabel: "閉じる"
    });
  } finally {
    // 成功・失敗に関係なく、生成中モーダルを閉じる
    if (generatingModal && generatingModal.isOpen) {
      generatingModal.close();
    }
  }
}

/**
 * 背景選択モーダルを開く
 */
async function openBgModal() {
  // multiModalで「背景選択」モーダルを開く
  multiModal.open({
    title: "背景選択",
    contentHtml: `
      <div id="bg-stock-container" class="bg-stock-grid" style="margin-bottom:10px;"></div>
      <div class="c-flexbox" style="margin-bottom:10px;">
        <button id="bg-none-button">背景無し</button>
        <button id="bg-generate-button">生成する</button>
      </div>
    `,
    showCloseButton: true,
    appearanceType: "center",
    closeOnOutsideClick: true,
    cancelLabel: "閉じる",
    onOpen: async () => {
      // モーダル生成後に要素がDOMに存在する → ここでイベント＆表示更新
      const container = document.getElementById("bg-stock-container");
      if (!container) return;

      const noneBtn = document.getElementById("bg-none-button");
      const genBtn = document.getElementById("bg-generate-button");

      // ボタンイベント付与
      if (noneBtn) {
        noneBtn.addEventListener("click", () => {
          onBgNoneButton();
        });
      }
      if (genBtn) {
        genBtn.addEventListener("click", async () => {
          await generateNewBackground();
          // 再描画
          await refreshBgStock(container);
        });
      }

      // ストック一覧を初回表示
      await refreshBgStock(container);
    }
  });
}

/**
 * 背景一覧を container に再描画
 */
async function refreshBgStock(containerEl) {
  if (!containerEl) return;
  containerEl.innerHTML = "";

  const all = await getAllBgImages();
  if (all.length === 0) {
    containerEl.textContent = "ストックが空です。";
    return;
  }

  all.forEach(img => {
    const wrap = document.createElement("div");
    wrap.className = "bg-thumb";

    const thumb = document.createElement("img");
    thumb.src = img.dataUrl;
    thumb.style.width = "100%";
    thumb.alt = "背景候補";

    thumb.addEventListener("click", () => {
      // 選択 → 即適用
      document.body.style.backgroundImage = `url(${img.dataUrl})`;
      document.body.style.backgroundSize = "cover";
      document.body.style.backgroundAttachment = "fixed";
      document.body.style.backgroundPositionX = "center";

      // 今ページ用に保存
      localStorage.setItem("selectedBgId_" + currentPageName, img.id.toString());

      // indexで背景を「none」以外にした場合、他ページの "none" 設定をクリア
      if (currentPageName === "index") {
        removeAllNoneSettingsExceptIndex();
      }
    });
    wrap.appendChild(thumb);

    // 削除ボタン
    const delBtn = document.createElement("button");
    delBtn.className = "bg-thumb-delete";
    delBtn.textContent = "×";
    delBtn.addEventListener("click", async (e) => {
      e.stopPropagation();
      // confirm代わりに multiModal を使用
      multiModal.open({
        title: "背景削除確認",
        contentHtml: `<p>この背景を削除しますか？</p>`,
        showCloseButton: true,
        appearanceType: "center",
        closeOnOutsideClick: true,
        okLabel: "OK",
        cancelLabel: "キャンセル",
        onOk: async () => {
          await deleteBgImage(img.id);

          // 削除したIDを使っているページキーがあれば削除
          for (const k of Object.keys(localStorage)) {
            if (k.startsWith("selectedBgId_")) {
              const stored = localStorage.getItem(k);
              if (stored === String(img.id)) {
                localStorage.removeItem(k);
              }
            }
          }
          // 再描画
          await refreshBgStock(containerEl);
        }
      });
    });
    wrap.appendChild(delBtn);

    containerEl.appendChild(wrap);
  });
}

/**
 * 背景無しボタン
 */
function onBgNoneButton() {
  // 現在ページの背景を消す
  document.body.style.backgroundImage = "none";
  // 選択キーに "none" をセット
  localStorage.setItem("selectedBgId_" + currentPageName, "none");
  // (indexで"none"を選んでも、他ページの"none"設定を消すロジックは特に無い)
}

/**
 * indexページで「背景なし以外」を設定した場合、
 * ほかのページが "none" を記録していたら削除する
 */
function removeAllNoneSettingsExceptIndex() {
  for (const key of Object.keys(localStorage)) {
    if (key.startsWith("selectedBgId_") && key !== "selectedBgId_index") {
      if (localStorage.getItem(key) === "none") {
        localStorage.removeItem(key);
      }
    }
  }
}

/* -----------------------------------------
   ここからは IndexedDB 関連など、背景画像管理のヘルパー
----------------------------------------- */

// 追加(保存)
function addBgImage(dataUrl) {
  return new Promise((resolve, reject) => {
    if (!db) {
      reject("DB未初期化");
      return;
    }
    const tx = db.transaction("bgImages", "readwrite");
    const store = tx.objectStore("bgImages");
    const record = {
      dataUrl,
      createdAt: new Date().toISOString()
    };
    const req = store.add(record);
    req.onsuccess = evt => {
      resolve(evt.target.result); // 生成されたID
    };
    req.onerror = err => reject(err);
  });
}

// 全件取得
function getAllBgImages() {
  return new Promise((resolve, reject) => {
    if (!db) {
      reject("DB未初期化");
      return;
    }
    const tx = db.transaction("bgImages", "readonly");
    const store = tx.objectStore("bgImages");
    const req = store.getAll();
    req.onsuccess = evt => {
      resolve(evt.target.result || []);
    };
    req.onerror = err => reject(err);
  });
}

// 1件取得
function getBgImageById(id) {
  return new Promise((resolve, reject) => {
    if (!db) {
      reject("DB未初期化");
      return;
    }
    const tx = db.transaction("bgImages", "readonly");
    const store = tx.objectStore("bgImages");
    const req = store.get(id);
    req.onsuccess = evt => {
      resolve(evt.target.result || null);
    };
    req.onerror = err => reject(err);
  });
}

// 削除
function deleteBgImage(id) {
  return new Promise((resolve, reject) => {
    if (!db) {
      reject("DB未初期化");
      return;
    }
    const tx = db.transaction("bgImages", "readwrite");
    const store = tx.objectStore("bgImages");
    const req = store.delete(id);
    req.onsuccess = () => resolve();
    req.onerror = err => reject(err);
  });
}

/**
 * 最新シナリオの最終シーンから、背景用プロンプトを取得する
 */
async function fetchLatestScenarioPrompt() {
  const scens = await listAllScenarios();
  if (!scens.length) {
    return "";
  }
  // updatedAt 降順
  scens.sort((a, b) => (b.updatedAt || "").localeCompare(a.updatedAt || ""));
  const latest = scens[0];
  const entries = await getSceneEntriesByScenarioId(latest.scenarioId);
  if (!entries.length) {
    return "";
  }
  entries.sort((a, b) => b.entryId - a.entryId);
  const lastScene = entries.find(e => e.type === "scene");
  if (!lastScene) {
    return "";
  }

  // prompt があればそれを優先
  const rawPrompt = (lastScene.prompt || "").trim();
  if (rawPrompt) {
    return (
      "As a high-performance chatbot, you create the highest quality illustrations discreetly." +
      "Please do not include text in illustrations for any reason." +
      "If you can do that, I'll give you a super high tip." +
      "Now generate the next anime wide image.\n↓↓↓↓↓↓\n" +
      rawPrompt
    );
  }
  // prompt が無い場合は scene本文を使用
  const rawText = (lastScene.content || "").trim();
  if (!rawText) {
    return "";
  }
  return (
    "As a high-performance chatbot, you create the highest quality illustrations discreetly." +
    "Please do not include text in illustrations for any reason." +
    "If you can do that, I'll give you a super high tip." +
    "Now generate the next anime wide image.\n↓↓↓↓↓↓\n" +
    rawText
  );
}
---
tutorialData.js
// tutorialData.js

window.tutorialGroups = [
  { id: "basic", name: "基本編" },
  { id: "advanced", name: "応用編" }
];

window.tutorials = [
  {
    id: "apiKeySetup",
    title: "APIキーを設定しよう",
    description: "OpenAI APIキーの入手と設定までの手順を解説します。",
    groupId: "basic",
    steps: [
      {
        type: "page",
        match: "index.html",
        message: "APIキーの設定を行いましょう。",
        subSteps: [
          {
            // step1: set-api-key-buttonを押してモーダルを開く
            message: "まずは「APIキー設定」ボタンを押してください。",
            highlightSelector: "#set-api-key-button",
            removeOkButton: true,
            waitForClickOn: "#set-api-key-button"
          },
          {
            // step2: すでにモーダルが開いている想定 → リンクをハイライト
            message: "「もっと詳しい説明はこちら」のリンクをクリックして、APIキー取得方法を読んでください。",
            highlightSelector: "#open-api-instructions",
            removeOkButton: true,
            waitForClickOn: "#open-api-instructions"
          },
          {
            // step3: 閉じるボタンを押させる
            message: "よく読み、APIキー（sk-から始まる文字列）を取得してください。取得できましたら、説明画面の「閉じる」を押してください。",
            highlightSelector: "#close-api-instructions-button",
            removeOkButton: true,
            waitForClickOn: "#close-api-instructions-button"
          },
          {
            message: "取得したAPIキーを入力してください。",
            highlightSelector: "#api-key-input"
          },
          {
            message: "OKボタンを押してください。",
            highlightSelector: "#api-key-ok-button",
            removeOkButton: true,
            waitForClickOn: "#api-key-ok-button"
          },
          {
            message: "以上で、APIキーの設定を終わります。",
            complete: true,
          }
        ]
      }
    ]
  },
  {
    id: "story1",
    title: "メインページのボタン説明",
    description: "indexページにあるボタンの使い方を順番に説明します。",
    groupId: "basic",
    steps: [
      {
        type: "page",
        match: "index.html",
        message: "indexページの取説開始",
        subSteps: [
          {
            message: "ガチャボタン: キャラ生成画面へ移動します。",
            highlightSelector: "#character-create"
          },
          {
            message: "パーティボタン: 作成したキャラを編成・管理します。",
            highlightSelector: "#party-list"
          },
          {
            message: "倉庫: ガチャで引いたカードが収納されています。",
            highlightSelector: "#show-warehouse-btn"
          },
          {
            message: "以上で、ボタン説明を終わります。",
            complete: true
          }
        ]
      }
    ]
  },
  {
    id: "gachaFlow",
    title: "ガチャの流れ",
    description: "トップ画面 から ガチャ画面 へ進み、ガチャを引いて倉庫で確認するまでの流れを解説します。",
    groupId: "basic", // または適切なグループID
    steps: [
      // 1) index.html
      {
        type: "page",
        match: "index.html",
        message: "ガチャの流れを説明します。",
        subSteps: [
          {
            message: "まずは「ガチャ」ボタンを押してください。",
            highlightSelector: "#character-create",
            removeOkButton: true,
            waitForClickOn: "#character-create"
          }
        ]
      },
      // 2) characterCreate.html
      {
        type: "page",
        match: "characterCreate.html",
        message: "ガチャ画面での操作を行いましょう。",
        subSteps: [
          {
            message: "「エレメントガチャ」ボタンを押してください。",
            highlightSelector: "#gacha-btn",
            removeOkButton: true,
            waitForClickOn: "#gacha-btn"
          },
          {
            message: "OKボタンを押してください。（生成開始）",
            highlightSelector: "#genre-setting-ok-btn",
            removeOkButton: true,
            waitForClickOn: "#genre-setting-ok-btn"
          },
          {
            message: "生成が完了するまでしばらくお待ちください。完了したら次へ進みます。"
            // ここでは特に highlightSelector や waitForClickOn は無く、ダイアログの「次へ」で進行
          },
          {
            message: "生成が確認できたら、戻るボタンを押してindexページへ戻りましょう。",
            // 戻るボタンが #back-to-menu か #back-to-index などのIDかを確認
            highlightSelector: "#back-to-menu",
            removeOkButton: true,
            waitForClickOn: "#back-to-menu"
          }
        ]
      },
      // 3) 再び index.html に戻って倉庫へ
      {
        type: "page",
        match: "index.html",
        message: "ガチャで引いたカードを倉庫で確認しましょう。",
        subSteps: [
          {
            message: "「倉庫」ボタンを押して、今引いたカードを確認してください。",
            highlightSelector: "#show-warehouse-btn",
            removeOkButton: true,
            waitForClickOn: "#show-warehouse-btn"
          },
          {
            message: "倉庫の説明は後ほどするとして、ガチャしたカードが表示されていると思います。",
          },
          {
            // 次のsubStepで閉じるボタンをハイライト
            message: "最後に「×」ボタンを押して倉庫を閉じましょう。",
            highlightSelector: "#close-warehouse-btn",
            removeOkButton: true,
            waitForClickOn: "#close-warehouse-btn"
          },
          {
            message: "これでガチャの説明は以上です。",
            complete: true
          }
        ]
      }
    ]
  },

  {
    id: "story3",
    title: "高度な倉庫管理",
    description: "倉庫画面でのソートやフィルタリング、選択モードなど高度な機能を紹介します。",
    groupId: "advanced",
    steps: [
      {
        type: "page",
        match: "index.html",
        message: "倉庫管理の使い方を説明します。",
        subSteps: [
          {
            // 1) 倉庫を開く
            message: "まずは「倉庫」ボタンを押して、倉庫画面を開きましょう。",
            highlightSelector: "#show-warehouse-btn",
            removeOkButton: true,
            waitForClickOn: "#show-warehouse-btn"
          },
          {
            // 2) 左側タブの紹介
            message: "これが倉庫画面です。",
          },
          {
            // 2) 左側タブの紹介
            message: "画面上のタブをクリックすると、種類ごとにカードを絞り込めます。試しに切り替えてみましょう。",
            highlightSelector: ".warehouse-tabs"
          },
          {
            // 3) ソートドロップダウン
            message: "右上のドロップダウンから、名前順や日時順などのソートを選べます。",
            highlightSelector: "#warehouse-sort-dropdown"
          },
          {
            // 4) ソート方向ボタン
            message: "ソート方向ボタンを押すと、昇順/降順を切り替えられます。",
            highlightSelector: "#warehouse-sort-direction-btn"
          },
          {
            // 7) 選択モードの使い方
            message: "複数のカードを一括操作したい場合は「選択モード」を使いましょう。選択モードをオンにするとカードを複数同時選択ができます。まとめて削除できます。",
            highlightSelector: "#toggle-warehouse-selection-mode-btn",
          },
          {
            // 2) 左側タブの紹介
            message: "カードをクリックすると、赤い枠が付きます。左上の選択したカードを削除ボタンを押すことで、削除が可能になります。",
          },
          {
            // 8) 倉庫を閉じる
            message: "最後に、右上の「×」(倉庫を閉じるボタン)を押して倉庫を閉じましょう。",
            highlightSelector: "#close-warehouse-btn",
            removeOkButton: true,
            waitForClickOn: "#close-warehouse-btn"
          },
          {
            // 9) 完了
            message: "以上で、倉庫画面の高度な管理機能の説明は終わりです。",
            complete: true
          }
        ]
      }
    ]
  },


  // ======= 既存の「あなたの分身を作成しよう」などがあればそのまま =======
  {
    id: "createAvatar",
    title: "あなたの分身を作成しよう",
    description: "自分だけのアバターを作成するチュートリアルです。",
    groupId: "basic",
    steps: [
      {
        type: "page",
        match: "index.html",
        message: "「あなたの分身」機能の使い方を学びましょう。",
        subSteps: [
          {
            // (1) あなたの分身ボタンを押させる
            message: "まずは「あなたの分身」ボタンを押してください。",
            highlightSelector: "#you-avatar-btn",
            removeOkButton: true,   // 「次へ」ボタンを非表示
            waitForClickOn: "#you-avatar-btn"
          },
          {
            // (2) 名前を入力
            message: "入力画面が開きました。まずは名前を入力しましょう。",
            highlightSelector: "#avatar-name"
          },
          {
            // (3) 性別を入力
            message: "性別を選択してください。",
            highlightSelector: "#avatar-gender-chips"
          },
          {
            // (4) 特技
            message: "特技を入力しましょう。",
            highlightSelector: "#avatar-skill"
          },
          {
            // (5) カードのセリフ
            message: "続いてカードのセリフを入力してください。",
            highlightSelector: "#avatar-serif"
          },
          {
            // (6) レア度
            message: "レア度を選択しましょう。",
            highlightSelector: "#avatar-rarity-chips"
          },
          {
            // (7) 画像生成
            message: "画像生成ボタンを押してみましょう。（押下後は完了までしばらくお待ちください）",
            highlightSelector: ".gen-image-btn"
          },
          {
            // (8) 保存ボタン
            message: "最後に、保存ボタンを押しましょう。",
            highlightSelector: "#avatar-save-btn"
          },
          {
            // (9) 完成
            message: "以上でアバターが完成です！",
            complete: true
          }
        ]
      }
    ]
  },

  // ================================
  // 新規追加「シナリオの作成と進行」
  // ================================
  {
    id: "scenarioCreation",
    title: "シナリオの作成と進行",
    description: "トップ画面 → シナリオウィザード → シナリオ画面 の流れで新しいシナリオを作成・進行します。",
    groupId: "basic",
    steps: [
      // ---------- index.html ----------
      {
        type: "page",
        match: "index.html",
        message: "シナリオの作成と進行：まずは index.html での操作です。",
        subSteps: [
          {
            message: "「新しいシナリオを始める」ボタンを押してください。",
            highlightSelector: "#start-new-scenario-button",
            removeOkButton: true,   // 次へボタン非表示
            waitForClickOn: "#start-new-scenario-button"
          }
        ]
      },

      // ---------- scenarioWizard.html ----------
      {
        type: "page",
        match: "scenarioWizard.html",
        message: "次にウィザード画面で操作を行います。",
        subSteps: [
          {
            message: "あなたの分身（パーティ）を選んでください。",
            highlightSelector: "#wizard-party-list"
          },
          {
            message: "選び終えたら「次へ」ボタンを押しましょう。",
            highlightSelector: "#go-wizard-step1-btn",
            removeOkButton: true,
            waitForClickOn: "#go-wizard-step1-btn"
          },
          {
            message: "ジャンル選択チップで「自由入力」を選択してください。",
            highlightSelector: "#choice-free"
          },
          {
            message: "自由入力ジャンルテキストボックスに「ミステリー」と入力しましょう。",
            highlightSelector: "#free-genre-input"
          },
          {
            message: "「次へ」ボタンを押します。",
            highlightSelector: "#go-step2-btn",
            removeOkButton: true,
            waitForClickOn: "#go-step2-btn"
          },
          {
            message: "「目標達成型（目的達成型）」ボタンを押しましょう。",
            highlightSelector: "#type-objective-btn"
          },
          {
            message: "OKを押下し、キャンセルは押さずにしばらく待ちます。",
            highlightSelector: "#confirm-scenario-ok",
            removeOkButton: true,
            waitForClickOn: "#confirm-scenario-ok"
          },
          {
            message: "処理が終わり、シナリオ要約が表示されたら次へ進みます。"
          },
          {
            message: "「このシナリオで始める」ボタンを押してください。",
            highlightSelector: "#start-scenario-button",
            removeOkButton: true,
            waitForClickOn: "#start-scenario-button"
          }
        ]
      },

      // ---------- scenario.html ----------
      {
        type: "page",
        match: "scenario.html",
        message: "新しく作成されたシナリオを進行させてみましょう。",
        subSteps: [
          {
            message: "画面最下部までスクロールし、行動テキストボックスで「自己紹介」と入力してください。",
            highlightSelector: "#player-input"
          },
          {
            message: "次のシーンボタンを押してください。キャンセルは押さず、完了を待ちます。",
            highlightSelector: "#next-scene",
            removeOkButton: true,
            waitForClickOn: "#next-scene"
          },
          {
            message: "次のシーンが表示されたら次へ進みます。"
          },
          {
            message: "これでシナリオの作成は完了です。左上のホームボタンからトップページに戻れます。",
            highlightSelector: "#back-to-menu"
          },
          {
            message: "進行中のシナリオ一覧の一番上の「続きへ」ボタンから、先ほど作成したシナリオにアクセスできます。"
          },
          {
            message: "以上がシナリオの作成と進行でした。",
            complete: true
          }
        ]
      }
    ]
  }

];
---
tutorialManager.js
(function () {
  // -------------------------------------------
  // A) スコープ内変数
  // -------------------------------------------
  let overlayEl = null;
  let dialogEl = null;
  let modalCheckInterval = null;

  // -------------------------------------------
  // B) DOMContentLoaded 後に開始
  // -------------------------------------------
  document.addEventListener("DOMContentLoaded", async () => {
    createBaseElements();  // オーバーレイ & ダイアログを生成 or 再利用
    await runTutorials();  // チュートリアル全体の開始
  });

  // -------------------------------------------
  // C) ベース要素生成
  // -------------------------------------------
  function createBaseElements() {
    // 既に存在すれば使い回し
    overlayEl = document.getElementById("tutorial-overlay");
    dialogEl = document.getElementById("tutorial-dialog");
    if (overlayEl && dialogEl) return;

    // (1) オーバーレイ
    overlayEl = document.createElement("div");
    overlayEl.id = "tutorial-overlay";
    overlayEl.classList.add("tutorial-overlay");
    // pointer-events: none; にして、下の要素操作を許可
    overlayEl.style.pointerEvents = "none";
    document.body.appendChild(overlayEl);

    // (2) ダイアログ
    dialogEl = document.createElement("div");
    dialogEl.id = "tutorial-dialog";
    dialogEl.classList.add("tutorial-dialog");
    // ダイアログ上は pointer-events: auto; でクリック可
    dialogEl.style.pointerEvents = "auto";
    document.body.appendChild(dialogEl);
  }

  // -------------------------------------------
  // D) チュートリアル全体の起動
  // -------------------------------------------
  async function runTutorials() {
    if (!window.tutorials || !Array.isArray(window.tutorials)) {
      console.warn("No tutorials found.");
      return;
    }

    // URLパラメータに forceTutorial があれば強制実行
    const forcedTutorialId = getQueryParam("forceTutorial");
    if (forcedTutorialId) {
      const target = window.tutorials.find(t => t.id === forcedTutorialId);
      if (target) {
        await runTutorialIfMatchPage(target);
      }
      return;
    }

    // 通常実行: 現在ページにマッチ & 未完了のストーリーを順番に
    const currentPage = getCurrentPageName();
    const pageTutorials = window.tutorials.filter(story =>
      story.steps.some(step => step.type === "page" && step.match === currentPage)
    );

    // ID末尾の数字が小さい順にソート
    pageTutorials.sort((a, b) => getStoryIdNumber(a.id) - getStoryIdNumber(b.id));

    for (const story of pageTutorials) {
      const isCompleted = localStorage.getItem("completeStory_" + story.id) === "true";
      if (!isCompleted) {
        await runTutorialIfMatchPage(story);
        break; // 1つ実行したらループ抜け
      }
    }
  }

  async function runTutorialIfMatchPage(story) {
    const currentPage = getCurrentPageName();
    // このストーリーに現在ページ用の step があるか？
    const hasStepForPage = story.steps.some(
      step => step.type === "page" && step.match === currentPage
    );
    if (hasStepForPage) {
      await startTutorialSteps(story);
    }
  }
  // -------------------------------------------
  // E) チュートリアルステップ開始
  // -------------------------------------------
  async function startTutorialSteps(story) {
    const currentPage = getCurrentPageName();

    // 1) このページに該当する step 一覧を抽出 (複数あり得る)
    const allPageSteps = story.steps.filter(s => s.type === "page" && s.match === currentPage);
    if (!allPageSteps.length) return;

    // 2) story 全体の "page" step の順序リスト
    const pageSteps = story.steps.filter(s => s.type === "page");

    // 3) 今のページ上にある step を「前ステップが完了しているか/自分が未完了か」を確認しながら順に実行
    for (const st of allPageSteps) {
      // (a) すでにこの step が完了済みならスキップ
      if (isPageStepDone(story.id, st)) {
        console.log(`[Tutorial] This page-step is already done:`, st);
        continue;
      }

      // (b) 前のpage-stepがある場合、その完了フラグをチェック
      const idx = pageSteps.indexOf(st);
      if (idx > 0) {
        const prevStep = pageSteps[idx - 1];
        if (!isPageStepDone(story.id, prevStep)) {
          // 前stepがまだ終わっていない → このstepは実行不可
          console.log(`[Tutorial] The previous page-step (index:${idx - 1}) is not done yet. Stop here.`);
          return; // ここで終了（後続stepも実行しない）
        }
      }

      // (c) subSteps実行
      console.log(`[Tutorial] start subSteps for page-step index:${idx}`);
      const subSteps = st.subSteps || [];
      if (!subSteps.length) {
        // 単発表示
        const r = await showDialog(story.title, st.message, null, "1/1");
        if (r.skipCheck || r.ok) {
          markPageStepDone(story, st);
        }
      } else {
        // 複数 subSteps
        let subStepCanceled = false;
        let stepCounter;

        for (let i = 0; i < subSteps.length; i++) {
          const sub = subSteps[i];
          // i番目のサブステップなので (i+1)/(全サブステップ数) を渡す
          stepCounter = `${i + 1}/${subSteps.length}`;

          const r = await showDialog(story.title, sub.message, sub, stepCounter);
          if (r.skipCheck) {
            // 「次は表示しない」→ チュートリアル全体完了に
            localStorage.setItem("completeStory_" + story.id, "true");
            return;
          }
          if (!r.ok) {
            // キャンセル → 中断
            subStepCanceled = true;
            break;
          }
        }
        if (!subStepCanceled) {
          // subSteps全部クリア → page-step完了
          markPageStepDone(story, st);
        }
      }
    }
  }

  // -------------------------------------------
  // F) page-stepの完了フラグ管理
  // -------------------------------------------
  function isPageStepDone(storyId, step) {
    const stepIndex = getPageStepIndex(storyId, step);
    if (stepIndex < 0) return false; // stepが見つからない
    const key = `pageStepDone_${storyId}_${stepIndex}`;
    return localStorage.getItem(key) === "true";
  }

  function markPageStepDone(story, step) {
    const stepIndex = getPageStepIndex(story.id, step);
    if (stepIndex < 0) return;
    // 今のpage-step完了
    localStorage.setItem(`pageStepDone_${story.id}_${stepIndex}`, "true");

    // もしこれが story.steps のうち最後のtype===page だったら → 全体完了
    const pageSteps = story.steps.filter(s => s.type === "page");
    const currentIdx = pageSteps.indexOf(step);
    if (currentIdx === pageSteps.length - 1) {
      localStorage.setItem(`completeStory_${story.id}`, "true");
      console.log(`[Tutorial] story ${story.id} fully completed.`);
    } else {
      console.log(`[Tutorial] page-step index=${currentIdx} done. More steps remain.`);
    }
  }

  function getPageStepIndex(storyId, step) {
    const pageSteps = (window.tutorials.find(t => t.id === storyId) || {}).steps?.filter(s => s.type === "page") || [];
    return pageSteps.indexOf(step);
  }

  // -------------------------------------------
  // G) ダイアログ表示 (Promise で完了を返す)
  // -------------------------------------------
  function showDialog(title, message, subStep, stepCounter="") {
    return new Promise((resolve) => {
      // ダイアログ HTML を組み立て
      dialogEl.innerHTML = buildDialogHTML(title, message, subStep, stepCounter);

      // 表示開始
      overlayEl.style.display = "block";
      dialogEl.style.display = "block";
      dialogEl.style.opacity = "0";

      // ボタン類
      const nextBtn = dialogEl.querySelector("#tutorial-next-btn");
      const cancelBtn = dialogEl.querySelector("#tutorial-cancel-btn");
      const skipCheck = dialogEl.querySelector("#tutorial-skip-checkbox");

      // 「完了ボタン」要素 (completeステップ用)
      const completeBtn = dialogEl.querySelector("#tutorial-complete-btn");

      // 「OKボタン非表示」指定なら
      if (subStep?.removeOkButton && nextBtn) {
        nextBtn.style.display = "none";
      }

      // もし「完了ボタン」(complete)があるなら、そのクリック時に resolve({ok:true}) して終わる
      if (completeBtn) {
        completeBtn.addEventListener("click", () => closeDialog({
          ok: true,
          cancel: false,
          skipCheck: false
        }));
      }

      // イベント
      if (nextBtn) {
        nextBtn.addEventListener("click", () => closeDialog({
          ok: true,
          cancel: false,
          skipCheck: !!skipCheck?.checked
        }));
      }
      if (cancelBtn) {
        cancelBtn.addEventListener("click", () => {
          // ▼ ここで forceTutorial パラメータを削除
          removeForceTutorialParam();
          closeDialog({
            ok: false,
            cancel: true,
            skipCheck: !!skipCheck?.checked
          });
        });
      }

      /** forceTutorialパラメータだけを削除してURLを上書き */
      function removeForceTutorialParam() {
        const currentUrl = new URL(window.location.href);
        currentUrl.searchParams.delete("forceTutorial");
        // 同じページでURLだけ書き換え(リロードせず)
        window.history.replaceState({}, "", currentUrl);
      }

      // ハイライト関連
      let highlightEl = null;
      if (subStep?.highlightSelector) {
        highlightEl = document.querySelector(subStep.highlightSelector);
        if (highlightEl) {
          highlightEl.classList.add("tutorial-highlight");
          highlightEl.scrollIntoView({ block: "center", inline: "center", behavior: "smooth" });
          waitForScrollEnd(highlightEl, () => {
            positionDialog(dialogEl, highlightEl);
            fadeInDialog();
          });
        } else {
          centerDialog(dialogEl);
          fadeInDialog();
        }
      } else {
        centerDialog(dialogEl);
        fadeInDialog();
      }

      // 特定要素クリック待ち
      let clickHandler = null;
      if (subStep?.waitForClickOn) {
        const targetEl = document.querySelector(subStep.waitForClickOn);
        if (targetEl) {
          clickHandler = () => {
            closeDialog({
              ok: true,
              cancel: false,
              skipCheck: !!skipCheck?.checked
            });
          };
          targetEl.addEventListener("click", clickHandler);
        }
      }

      // ここではモーダル監視はオフにした例
      //startModalCheck();

      function closeDialog(action) {
        // ハイライト解除
        if (highlightEl) {
          highlightEl.classList.remove("tutorial-highlight");
        }
        // クリック待ち解除
        if (clickHandler && subStep?.waitForClickOn) {
          const tEl = document.querySelector(subStep.waitForClickOn);
          tEl?.removeEventListener("click", clickHandler);
        }

        // 非表示
        dialogEl.style.display = "none";
        dialogEl.style.opacity = "0";
        overlayEl.style.display = "none";
        stopModalCheck();

        resolve(action);
      }

      function fadeInDialog() {
        requestAnimationFrame(() => {
          dialogEl.style.opacity = "1";
        });
      }
    });
  }

  function buildDialogHTML(title, message, subStep, stepCounter = "") {
    // もし subStep?.complete が true なら、完了ボタンのみ表示のレイアウトにする
    if (subStep?.complete) {
      return `
      <div class="step-title">
        ${escapeHtml(title)}${escapeHtml(stepCounter)}
      </div>
      <div class="step-message">${escapeHtml(message)}</div>
      <div style="display:flex; justify-content:right; gap:10px;">
        <button id="tutorial-complete-btn" style="min-width:6rem;">完了</button>  
      </div>
    `;
    }
    return `
      <div class="step-title">
        ${escapeHtml(title)}${escapeHtml(stepCounter)}
      </div>
      <div class="step-message">${escapeHtml(message)}</div>
      <div style="display:flex; justify-content:right; gap:10px;">
        <button id="tutorial-next-btn">次へ</button>
        <button id="tutorial-cancel-btn">キャンセル</button>
      </div>
      <div class="step-skip-container">
        <input type="checkbox" id="tutorial-skip-checkbox" />
        <label for="tutorial-skip-checkbox">次は表示しない</label>
      </div>
    `;
  }

  // -------------------------------------------
  // H) モーダル監視 (任意)
  // -------------------------------------------
  function startModalCheck() {
    stopModalCheck();
    modalCheckInterval = setInterval(() => {
      const isModalOpen = !!document.querySelector(".modal.active");
      // tutorualOverlayは常にクリック透過にしたい場合は "none" で固定
      overlayEl.style.pointerEvents = isModalOpen ? "none" : "none";
    }, 300);
  }

  function stopModalCheck() {
    if (modalCheckInterval) {
      clearInterval(modalCheckInterval);
      modalCheckInterval = null;
    }
  }

  // -------------------------------------------
  // I) 位置調整・ユーティリティ
  // -------------------------------------------
  function positionDialog(dialog, highlightEl) {
    const hlRect = highlightEl.getBoundingClientRect();
    const dw = dialog.offsetWidth;
    const dh = dialog.offsetHeight;

    // 下に配置できるか判定
    const spaceBelow = window.innerHeight - hlRect.bottom;
    let topPos;
    if (spaceBelow > dh + 10) {
      topPos = hlRect.bottom + 10;
    } else {
      topPos = hlRect.top - dh - 10;
    }
    if (topPos < 0) topPos = 0;

    let leftPos = hlRect.left;
    if (leftPos + dw > window.innerWidth) {
      leftPos = window.innerWidth - dw - 10;
    }
    if (leftPos < 0) leftPos = 0;

    dialog.style.top = topPos + "px";
    dialog.style.left = leftPos + "px";

    // 被りがあれば横ずらし
    const boxRect = dialog.getBoundingClientRect();
    if (checkOverlap(hlRect, boxRect)) {
      shiftHorizontally(dialog, hlRect, boxRect);
      clipToViewport(dialog);
    } else {
      clipToViewport(dialog);
    }
  }

  function checkOverlap(r1, r2) {
    const overlapX = (r1.left < r2.right) && (r1.right > r2.left);
    const overlapY = (r1.top < r2.bottom) && (r1.bottom > r2.top);
    return overlapX && overlapY;
  }

  function shiftHorizontally(dialog, hlRect, boxRect) {
    const highlightCenterX = (hlRect.left + hlRect.right) / 2;
    const screenCenterX = window.innerWidth / 2;
    const dw = boxRect.width;
    let newLeft;
    if (highlightCenterX < screenCenterX) {
      newLeft = hlRect.right + 10;
    } else {
      newLeft = hlRect.left - dw - 10;
    }
    if (newLeft < 0) newLeft = 0;
    if (newLeft + dw > window.innerWidth) {
      newLeft = window.innerWidth - dw - 10;
    }
    dialog.style.left = newLeft + "px";
  }

  function clipToViewport(dialog) {
    const boxRect = dialog.getBoundingClientRect();
    let topPos = boxRect.top;
    let leftPos = boxRect.left;
    const dw = boxRect.width;
    const dh = boxRect.height;

    if (topPos < 0) topPos = 0;
    if (topPos + dh > window.innerHeight) {
      topPos = window.innerHeight - dh - 10;
      if (topPos < 0) topPos = 0;
    }
    if (leftPos < 0) leftPos = 0;
    if (leftPos + dw > window.innerWidth) {
      leftPos = window.innerWidth - dw - 10;
      if (leftPos < 0) leftPos = 0;
    }
    dialog.style.top = topPos + "px";
    dialog.style.left = leftPos + "px";
  }

  function centerDialog(dialog) {
    const dw = dialog.offsetWidth;
    const dh = dialog.offsetHeight;
    let topPos = (window.innerHeight - dh) / 2;
    let leftPos = (window.innerWidth - dw) / 2;
    if (topPos < 0) topPos = 0;
    if (leftPos < 0) leftPos = 0;
    dialog.style.top = topPos + "px";
    dialog.style.left = leftPos + "px";
  }

  function waitForScrollEnd(el, callback) {
    let stableCount = 0;
    let lastTop = null;
    function step() {
      const rect = el.getBoundingClientRect();
      const currentTop = rect.top;
      if (lastTop !== null && Math.abs(currentTop - lastTop) < 0.5) {
        stableCount++;
      } else {
        stableCount = 0;
      }
      lastTop = currentTop;
      if (stableCount > 5) {
        callback();
      } else {
        requestAnimationFrame(step);
      }
    }
    requestAnimationFrame(step);
  }

  // -------------------------------------------
  // J) 細かいユーティリティ
  // -------------------------------------------
  function getCurrentPageName() {
    let page = location.pathname.split("/").pop() || "";
    if (!page || page === "") {
      page = "index.html";
    }
    return page;
  }
  function getQueryParam(name) {
    const params = new URLSearchParams(window.location.search);
    return params.get(name);
  }
  function getStoryIdNumber(storyId) {
    const match = storyId.match(/\d+$/);
    return match ? parseInt(match[0], 10) : 999999;
  }
  function escapeHtml(str) {
    if (!str) return "";
    return str
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;");
  }
})();
---
universalSaveLoad.js
/************************************************************
 * universalSaveLoad.js
 * 
 * シナリオに紐づかず、全体で共通のセーブスロットを管理する。
 * slotIndex=1～N のレコードに "data" として
 *   {
 *     scenarioId,
 *     scenarioTitle,
 *     scenarioWizardData,
 *     scenes
 *   }
 * を保存する方式。
 ************************************************************/


// ▼ 画面上にある "続き" ボタンへイベントを付与
document.addEventListener("DOMContentLoaded", () => {
  const saveLoadButton = document.getElementById("save-load-button");
  if (saveLoadButton) {
    saveLoadButton.addEventListener("click", openSaveLoadModal);
  }
});

/**
 * セーブ／ロード用モーダルを multiModal で開く。
 */
window.openSaveLoadModal = async function () {
  multiModal.open({
    title: "セーブ/ロード",
    contentHtml: `
      <div id="slot-container">
        <div id="slot-items-container"></div>
        <button id="add-slot-button">＋</button>
      </div>
      <div class="c-flexbox" style="margin-bottom:20px;">
        <button id="do-save-button" style="display:none;">保存</button>
        <button id="do-load-button">始める</button>
      </div>
      <div class="c-flexbox" style="margin-top:15px;">
        <button id="clear-all-slots-button" style="background-color:#b71c1c; border-color:#b71c1c;">全クリア</button>
      </div>
    `,
    showCloseButton: true,
    appearanceType: "center",
    closeOnOutsideClick: true,
    cancelLabel: "閉じる",
    // モーダルが開いた後でDOM要素が存在するようになる → onOpenでイベントを付与
    onOpen: async () => {
      // もしスロット未作成なら5つ作る
      await ensureInitialSlots();

      // イベント紐付け
      const addSlotBtn = document.getElementById("add-slot-button");
      if (addSlotBtn) {
        addSlotBtn.addEventListener("click", onAddSlot);
      }

      const doSaveBtn = document.getElementById("do-save-button");
      if (doSaveBtn) {
        doSaveBtn.addEventListener("click", onClickSave);
      }

      const doLoadBtn = document.getElementById("do-load-button");
      if (doLoadBtn) {
        doLoadBtn.addEventListener("click", onClickLoad);
      }

      const clearAllSlotsBtn = document.getElementById("clear-all-slots-button");
      if (clearAllSlotsBtn) {
        clearAllSlotsBtn.addEventListener("click", onClearAllSlots);
      }

      // 初期表示
      await renderSlotList();
    }
  });
};

/**
 * スロット一覧を描画
 */
window.renderSlotList = async function () {
  const container = document.getElementById("slot-items-container");
  if (!container) return;

  container.innerHTML = "";

  // 全スロット取得
  const all = await listAllSlots();
  for (const slot of all) {
    const rowContainer = document.createElement("div");
    rowContainer.className = "save-slot-row-container";

    const deleteButton = document.createElement("button");
    deleteButton.className = "save-slot-delete";
    deleteButton.innerHTML = `<span class="iconmoon icon-cross"></span>`;
    deleteButton.addEventListener("click", async (e) => {
      e.stopPropagation(); // ラベルクリック(=ラジオ選択)と区別
      await onDeleteSlot(slot.slotIndex);
    });

    const row = document.createElement("div");
    row.className = "save-slot-row";

    const rb = document.createElement("input");
    rb.type = "radio";
    rb.name = "slotRadio";
    rb.value = slot.slotIndex;
    rb.id = "slotRadio_" + slot.slotIndex;

    const label = document.createElement("label");
    label.setAttribute("for", rb.id);

    if (!slot.data) {
      // 空き
      label.textContent = `${slot.slotIndex}: 空き`;
    } else {
      const ymd = (slot.updatedAt || "").split("T")[0];
      const title = slot.data.scenarioTitle || "NoTitle";
      label.textContent = `${slot.slotIndex}: ${ymd} ${title}`;
    }

    row.appendChild(rb);
    row.appendChild(label);
    rowContainer.appendChild(row);
    rowContainer.appendChild(deleteButton);
    container.appendChild(rowContainer);
  }

  // セーブボタンの表示/非表示を切り替え
  const doSaveBtn = document.getElementById("do-save-button");
  if (doSaveBtn) {
    // 現在のシナリオがあればセーブ可能
    if (window.currentScenarioId) {
      doSaveBtn.style.display = "";
    } else {
      doSaveBtn.style.display = "none";
    }
  }
};

/**
 * 個別スロットを削除
 */
window.onDeleteSlot = async function (slotIndex) {
  // 確認ダイアログを multiModal で
  multiModal.open({
    title: "スロット削除",
    contentHtml: `<p>スロット${slotIndex}を削除します。よろしいですか？</p>`,
    showCloseButton: true,
    appearanceType: "center",
    closeOnOutsideClick: true,
    okLabel: "OK",
    cancelLabel: "キャンセル",
    onOk: async () => {
      // 削除
      await deleteUniversalSlot(slotIndex);
      // 再描画
      await renderSlotList();
    }
  });
};

/**
 * 「+」ボタン → スロット追加
 */
window.onAddSlot = async function () {
  // 全スロット取得して、maxIndex+1 のスロットを作る
  const all = await listAllSlots();
  let maxIdx = 0;
  for (const s of all) {
    if (s.slotIndex > maxIdx) maxIdx = s.slotIndex;
  }
  const newIdx = maxIdx + 1;

  const rec = {
    slotIndex: newIdx,
    updatedAt: new Date().toISOString(),
    data: null
  };
  await putUniversalSave(rec);

  await renderSlotList();
};

/**
 * 「セーブ」ボタン
 *   - 選択したスロットに現在シナリオの内容を詰める
 *   - 空でない場合は「上書きしても良いか」ダイアログ
 */
window.onClickSave = async function () {
  // 選択スロット
  const selected = document.querySelector('input[name="slotRadio"]:checked');
  if (!selected) {
    multiModal.open({
      title: "エラー",
      contentHtml: "<p>スロットを選択してください。</p>",
      cancelLabel: "閉じる"
    });
    return;
  }
  const slotIndex = parseInt(selected.value, 10);

  // スロットを取得 (すでに何かあるか確認)
  const existingSlot = await getUniversalSave(slotIndex);
  if (existingSlot && existingSlot.data) {
    // 既に何か入っている → 上書き確認
    multiModal.open({
      title: "上書き確認",
      contentHtml: `<p>スロット${slotIndex}は既に使われています。<br>上書きしてもよろしいですか？</p>`,
      showCloseButton: true,
      appearanceType: "center",
      closeOnOutsideClick: true,
      okLabel: "OK",
      cancelLabel: "キャンセル",
      onOk: async () => {
        await doSaveToSlot(slotIndex);
      }
    });
  } else {
    await doSaveToSlot(slotIndex);
  }
};

async function doSaveToSlot(slotIndex) {
  // 現在のシナリオID
  if (!window.currentScenarioId) {
    multiModal.open({
      title: "エラー",
      contentHtml: "<p>現在のシナリオIDが不明です。</p>",
      cancelLabel: "閉じる"
    });
    return;
  }
  // シナリオ本体
  const scenarioObj = await getScenarioById(window.currentScenarioId);
  if (!scenarioObj) {
    multiModal.open({
      title: "エラー",
      contentHtml: "<p>シナリオがDBに存在しません。</p>",
      cancelLabel: "閉じる"
    });
    return;
  }
  // シーン一覧
  const scenes = await getSceneEntriesByScenarioId(window.currentScenarioId);

  // データ詰める
  const data = {
    scenarioId: window.currentScenarioId,
    scenarioTitle: scenarioObj.title || "(無題)",
    scenarioWizardData: scenarioObj.wizardData || {},
    scenes
  };

  // スロットに保存
  const rec = {
    slotIndex,
    updatedAt: new Date().toISOString(),
    data
  };
  await putUniversalSave(rec);

  multiModal.open({
    title: "保存完了",
    contentHtml: `<p>スロット${slotIndex}にセーブしました。</p>`,
    cancelLabel: "OK"
  });
  renderSlotList();
}

/**
 * 「ロード」ボタン
 *   - 選択スロットの scenarioId が現在と同じなら即ロード
 *   - 違う場合は scenario.html?slotIndex=...&action=load へ飛ぶ
 */
window.onClickLoad = async function () {
  const selected = document.querySelector('input[name="slotRadio"]:checked');
  if (!selected) {
    multiModal.open({
      title: "エラー",
      contentHtml: "<p>スロットを選択してください。</p>",
      cancelLabel: "閉じる"
    });
    return;
  }
  const slotIndex = parseInt(selected.value, 10);
  const slot = await getUniversalSave(slotIndex);
  if (!slot || !slot.data) {
    multiModal.open({
      title: "エラー",
      contentHtml: "<p>そのスロットは空です。</p>",
      cancelLabel: "閉じる"
    });
    return;
  }

  const targetScenarioId = slot.data.scenarioId;
  if (!targetScenarioId) {
    multiModal.open({
      title: "エラー",
      contentHtml: "<p>スロットにシナリオ情報がありません。</p>",
      cancelLabel: "閉じる"
    });
    return;
  }

  // 現在のシナリオと同じ？
  if (targetScenarioId === window.currentScenarioId) {
    // 同じなら今の画面でロード処理
    await doLoadScenarioFromSlot(slot.data);
    multiModal.open({
      title: "ロード完了",
      contentHtml: `<p>現在のシナリオをスロット${slotIndex}で上書きしました。</p>`,
      cancelLabel: "OK"
    });
  } else {
    // 違うシナリオID → scenario.html?slotIndex=..&action=load へ飛ぶ
    const url = `scenario.html?slotIndex=${slotIndex}&action=load`;
    window.location.href = url;
  }
};

/**
 * 全クリアボタン
 */
window.onClearAllSlots = async function () {
  multiModal.open({
    title: "全スロットをクリア",
    contentHtml: "<p>全スロットをクリアし、空き状態に戻します。よろしいですか？</p>",
    showCloseButton: true,
    appearanceType: "center",
    closeOnOutsideClick: true,
    okLabel: "OK",
    cancelLabel: "キャンセル",
    onOk: async () => {
      // 全削除
      const all = await listAllSlots();
      for (const s of all) {
        await deleteUniversalSlot(s.slotIndex);
      }
      // 初期スロット5つを作成
      await ensureInitialSlots();
      // 再描画
      await renderSlotList();
      multiModal.open({
        title: "完了",
        contentHtml: "<p>全スロットをクリアし、初期状態に戻しました。</p>",
        cancelLabel: "OK"
      });
    }
  });
};

/**
 * スロット data からシナリオをDBへ反映し、メモリ更新
 * (現在のシナリオIDと同じ前提)
 */
window.doLoadScenarioFromSlot = async function (slotData) {
  // slotData = { scenarioId, scenarioTitle, scenarioWizardData, scenes }
  const sId = slotData.scenarioId;

  // DB上のシナリオを取得
  let scenarioObj = await getScenarioById(sId);
  if (!scenarioObj) {
    multiModal.open({
      title: "エラー",
      contentHtml: "<p>該当シナリオがDBに見つかりません。ロードできません。</p>",
      cancelLabel: "閉じる"
    });
    return;
  }

  // シナリオを上書き
  scenarioObj.title = slotData.scenarioTitle || "(無題)";
  scenarioObj.wizardData = slotData.scenarioWizardData || {};
  await updateScenario(scenarioObj, true);

  // シーン履歴を入れ替え
  const existing = await getSceneEntriesByScenarioId(sId);
  for (const e of existing) {
    await deleteSceneEntry(e.entryId);
  }
  for (const sc of slotData.scenes) {
    delete sc.entryId; // 自動採番
    sc.scenarioId = sId;
    await addSceneEntry(sc);
  }

  // メモリ更新
  await loadScenarioData(sId);
}

/* ======================================
   ▼ スロット管理用 IndexedDB 関数
====================================== */

window.ensureInitialSlots = async function () {
  const all = await listAllSlots();
  if (all.length > 0) {
    return; // 既に何かある
  }
  // slotIndex=1～5 を空きで作成
  for (let i = 1; i <= 5; i++) {
    const rec = {
      slotIndex: i,
      updatedAt: new Date().toISOString(),
      data: null
    };
    await putUniversalSave(rec);
  }
};

window.listAllSlots = function () {
  return new Promise((resolve, reject) => {
    if (!db) {
      console.warn("DB未初期化");
      resolve([]);
      return;
    }
    const tx = db.transaction("universalSaves", "readonly");
    const store = tx.objectStore("universalSaves");
    const req = store.getAll();
    req.onsuccess = (evt) => {
      const result = evt.target.result || [];
      result.sort((a, b) => a.slotIndex - b.slotIndex);
      resolve(result);
    };
    req.onerror = (err) => reject(err);
  });
};

window.getUniversalSave = function (slotIndex) {
  return new Promise((resolve, reject) => {
    if (!db) return reject("DB未初期化");
    const tx = db.transaction("universalSaves", "readonly");
    const store = tx.objectStore("universalSaves");
    const req = store.get(slotIndex);
    req.onsuccess = e => {
      resolve(e.target.result || null);
    };
    req.onerror = err => reject(err);
  });
};

window.putUniversalSave = function (record) {
  return new Promise((resolve, reject) => {
    if (!db) return reject("DB未初期化");
    const tx = db.transaction("universalSaves", "readwrite");
    const store = tx.objectStore("universalSaves");
    const req = store.put(record);
    req.onsuccess = () => resolve();
    req.onerror = err => reject(err);
  });
};

/** 新規追加: スロットを1件削除 */
window.deleteUniversalSlot = function (slotIndex) {
  return new Promise((resolve, reject) => {
    if (!db) return reject("DB未初期化");
    const tx = db.transaction("universalSaves", "readwrite");
    const store = tx.objectStore("universalSaves");
    const delReq = store.delete(slotIndex);
    delReq.onsuccess = () => resolve();
    delReq.onerror = err => reject(err);
  });
};
---
indexedDB.js
/* indexedDB.js */
let db = null;

function initIndexedDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open("trpgDB", 17); // バージョンを16に

    request.onupgradeneeded = (event) => {
      db = event.target.result;

      // characterData
      if (!db.objectStoreNames.contains("characterData")) {
        db.createObjectStore("characterData", { keyPath: "id" });
      }

      // scenarios
      if (!db.objectStoreNames.contains("scenarios")) {
        const scenarioStore = db.createObjectStore("scenarios", {
          keyPath: "scenarioId",
          autoIncrement: true
        });
        scenarioStore.createIndex("updatedAt", "updatedAt", { unique: false });
      } else {
        // 既に "scenarios" ストアがある場合
      }

      // sceneEntries
      let sceneStore;
      if (!db.objectStoreNames.contains("sceneEntries")) {
        sceneStore = db.createObjectStore("sceneEntries", {
          keyPath: "entryId",
          autoIncrement: true
        });
        sceneStore.createIndex("scenarioId", "scenarioId", { unique: false });
      } else {
        sceneStore = request.transaction.objectStore("sceneEntries");
      }
      // content_en用index(重複可)
      if (sceneStore && !sceneStore.indexNames.contains("content_en")) {
        try {
          sceneStore.createIndex("content_en", "content_en", { unique: false });
        } catch (e) {
          console.warn("content_enのIndex作成に失敗:", e);
        }
      }

      // wizardState
      if (!db.objectStoreNames.contains("wizardState")) {
        db.createObjectStore("wizardState", { keyPath: "id" });
      }

      // parties
      if (!db.objectStoreNames.contains("parties")) {
        const partyStore = db.createObjectStore("parties", {
          keyPath: "partyId",
          autoIncrement: true
        });
        partyStore.createIndex("updatedAt", "updatedAt", { unique: false });
      }

      // bgImages
      if (!db.objectStoreNames.contains("bgImages")) {
        db.createObjectStore("bgImages", {
          keyPath: "id",
          autoIncrement: true
        });
      }

      // sceneSummaries
      if (!db.objectStoreNames.contains("sceneSummaries")) {
        const sumStore = db.createObjectStore("sceneSummaries", {
          keyPath: "summaryId",
          autoIncrement: true
        });
        sumStore.createIndex("chunkIndex", "chunkIndex", { unique: true });
      }

      // endings
      if (!db.objectStoreNames.contains("endings")) {
        db.createObjectStore("endings", { keyPath: ["scenarioId", "type"] });
      }

      // avatarData
      if (!db.objectStoreNames.contains("avatarData")) {
        db.createObjectStore("avatarData", { keyPath: "id" });
      }

      // ===== ここから追加 =====
      // entitiesストア（アイテムやキャラクターを管理）
      if (!db.objectStoreNames.contains("entities")) {
        const entStore = db.createObjectStore("entities", {
          keyPath: "entityId",
          autoIncrement: true
        });
        entStore.createIndex("scenarioId", "scenarioId", { unique: false });
      }
      if (!db.objectStoreNames.contains("universalSaves")) {
        const store = db.createObjectStore("universalSaves", {
          keyPath: "slotIndex" // 1,2,3...をユニークキーに
        });
        // 追加のindexは不要なら何もしない
      }
    };

    request.onsuccess = (event) => {
      db = event.target.result;
      resolve();
    };
    request.onerror = (event) => {
      reject(event.target.error);
    };
  });
}

/**
 * 新しいシナリオを作成
 */
function createNewScenario(wizardData, title = "新シナリオ") {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("scenarios", "readwrite");
    const store = tx.objectStore("scenarios");

    const now = new Date();
    const record = {
      title: title,
      wizardData: wizardData,
      createdAt: now.toISOString(),
      updatedAt: now.toISOString(),
      bookShelfFlag: false,        // 新規はデフォルトOFF
      hideFromHistoryFlag: false   // 新規はデフォルトOFF
    };

    const addReq = store.add(record);
    addReq.onsuccess = (evt) => {
      const newId = evt.target.result;
      resolve(newId);
    };
    addReq.onerror = (err) => {
      reject(err);
    };
  });
}

/**
 * シナリオを更新
 */
function updateScenario(scenario, noUpdateDateTimeFlag) {
  return new Promise((resolve, reject) => {
    if (!db) return reject("DB未初期化");
    if (!noUpdateDateTimeFlag) {
      scenario.updatedAt = new Date().toISOString();
    }
    if (typeof scenario.bookShelfFlag === "undefined") scenario.bookShelfFlag = false;
    if (typeof scenario.hideFromHistoryFlag === "undefined") scenario.hideFromHistoryFlag = false;
    if (scenario.bookShelfFlag && typeof scenario.shelfOrder !== "number") {
      scenario.shelfOrder = Date.now();
    }

    const tx = db.transaction("scenarios", "readwrite");
    const store = tx.objectStore("scenarios");
    const req = store.put(scenario);
    req.onsuccess = () => resolve();
    req.onerror = err => reject(err);
  });
}

/**
 * シナリオをID指定で取得
 */
function getScenarioById(scenarioId) {
  return new Promise((resolve, reject) => {
    if (!db) return reject("DB未初期化");
    const tx = db.transaction("scenarios", "readonly");
    const store = tx.objectStore("scenarios");
    const getReq = store.get(scenarioId);
    getReq.onsuccess = (evt) => {
      resolve(evt.target.result || null);
    };
    getReq.onerror = (err) => reject(err);
  });
}

/**
 * シナリオを全件取得
 */
function listAllScenarios() {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("scenarios", "readonly");
    const store = tx.objectStore("scenarios");
    const req = store.getAll();
    req.onsuccess = (evt) => {
      const result = evt.target.result || [];
      result.forEach(sc => {
        sc.bookShelfFlag = sc.bookShelfFlag || false;
        sc.hideFromHistoryFlag = sc.hideFromHistoryFlag || false;
      });
      result.sort((a, b) => (b.updatedAt || "").localeCompare(a.updatedAt || ""));
      resolve(result);
    };
    req.onerror = (err) => {
      reject(err);
    };
  });
}

/** シナリオ削除 */
function deleteScenarioById(scenarioId) {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction(["scenarios", "sceneEntries"], "readwrite");
    const scenarioStore = tx.objectStore("scenarios");
    const sceneEntriesStore = tx.objectStore("sceneEntries");

    // 1) シナリオ本体を削除
    const deleteReq = scenarioStore.delete(scenarioId);
    deleteReq.onsuccess = () => {
      // 2) sceneEntriesで scenarioId === scenarioId のものを削除
      const idx = sceneEntriesStore.index("scenarioId");
      const range = IDBKeyRange.only(scenarioId);

      idx.openCursor(range).onsuccess = (evt) => {
        const cursor = evt.target.result;
        if (cursor) {
          sceneEntriesStore.delete(cursor.primaryKey);
          cursor.continue();
        }
      };

      tx.oncomplete = () => {
        resolve();
      };
      tx.onerror = (err) => {
        reject(err);
      };
    };
    deleteReq.onerror = (err) => {
      reject(err);
    };
  });
}

/* シーン履歴: add/update/get/delete */
function addSceneEntry(entry) {
  return new Promise((resolve, reject) => {
    if (!db) return reject("DB未初期化");
    const tx = db.transaction("sceneEntries", "readwrite");
    const store = tx.objectStore("sceneEntries");
    const addReq = store.add(entry);
    addReq.onsuccess = (evt) => {
      resolve(evt.target.result);
    };
    addReq.onerror = (err) => {
      reject(err);
    };
  });
}

function updateSceneEntry(entry) {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("sceneEntries", "readwrite");
    const store = tx.objectStore("sceneEntries");
    const putReq = store.put(entry);
    putReq.onsuccess = () => {
      resolve();
    };
    putReq.onerror = (err) => {
      reject(err);
    };
  });
}

function getSceneEntriesByScenarioId(scenarioId) {
  return new Promise((resolve, reject) => {
    if (!db) return reject("DB未初期化");
    const tx = db.transaction("sceneEntries", "readonly");
    const store = tx.objectStore("sceneEntries");
    const index = store.index("scenarioId");
    const range = IDBKeyRange.only(scenarioId);
    const results = [];
    index.openCursor(range).onsuccess = (evt) => {
      const cursor = evt.target.result;
      if (cursor) {
        results.push(cursor.value);
        cursor.continue();
      } else {
        results.sort((a, b) => a.entryId - b.entryId);
        resolve(results);
      }
    };
    index.openCursor(range).onerror = (err) => reject(err);
  });
}

function deleteSceneEntry(entryId) {
  return new Promise((resolve, reject) => {
    if (!db) return reject("DB未初期化");
    const tx = db.transaction("sceneEntries", "readwrite");
    const store = tx.objectStore("sceneEntries");
    const delReq = store.delete(entryId);
    delReq.onsuccess = () => {
      resolve();
    };
    delReq.onerror = (err) => {
      reject(err);
    };
  });
}

/* ---------- シーン要約関連 ---------- */
function addSceneSummaryRecord(summaryObj) {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("sceneSummaries", "readwrite");
    const store = tx.objectStore("sceneSummaries");
    const addReq = store.add(summaryObj);
    addReq.onsuccess = (evt) => resolve(evt.target.result);
    addReq.onerror = (err) => reject(err);
  });
}

function getSceneSummaryByChunkIndex(chunkIndex) {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("sceneSummaries", "readonly");
    const store = tx.objectStore("sceneSummaries");
    const idx = store.index("chunkIndex");
    const req = idx.get(chunkIndex);
    req.onsuccess = () => {
      resolve(req.result || null);
    };
    req.onerror = (err) => {
      reject(err);
    };
  });
}

function updateSceneSummaryRecord(summaryObj) {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("sceneSummaries", "readwrite");
    const store = tx.objectStore("sceneSummaries");
    const putReq = store.put(summaryObj);
    putReq.onsuccess = () => {
      resolve();
    };
    putReq.onerror = (err) => {
      reject(err);
    };
  });
}

function deleteSceneSummaryByChunkIndex(chunkIndex) {
  return new Promise(async (resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    try {
      const sumRec = await getSceneSummaryByChunkIndex(chunkIndex);
      if (!sumRec) {
        return resolve();
      }
      const tx = db.transaction("sceneSummaries", "readwrite");
      const store = tx.objectStore("sceneSummaries");
      const delReq = store.delete(sumRec.summaryId);
      delReq.onsuccess = () => resolve();
      delReq.onerror = (err) => reject(err);
    } catch (e) {
      reject(e);
    }
  });
}

/* ---------- パーティ関連 ---------- */
window.initIndexedDB = initIndexedDB;
window.createNewScenario = createNewScenario;
window.updateScenario = updateScenario;
window.getScenarioById = getScenarioById;
window.addSceneEntry = addSceneEntry;
window.getSceneEntriesByScenarioId = getSceneEntriesByScenarioId;
window.deleteSceneEntry = deleteSceneEntry;

window.addSceneSummaryRecord = addSceneSummaryRecord;
window.getSceneSummaryByChunkIndex = getSceneSummaryByChunkIndex;
window.updateSceneSummaryRecord = updateSceneSummaryRecord;
window.deleteSceneSummaryByChunkIndex = deleteSceneSummaryByChunkIndex;

/** キャラデータ関連 */
window.saveCharacterDataToIndexedDB = function (characterData) {
  return new Promise((resolve, reject) => {
    if (!db) {
      console.warn("DBが未初期化です。");
      resolve();
      return;
    }
    const tx = db.transaction("characterData", "readwrite");
    const store = tx.objectStore("characterData");
    const record = { id: "characterData", data: characterData };
    const putReq = store.put(record);
    putReq.onsuccess = () => {
      resolve();
    };
    putReq.onerror = (err) => {
      reject(err);
    };
  });
};

window.loadCharacterDataFromIndexedDB = function() {
  return new Promise((resolve) => {
    if (!db) {
      console.warn("DBが未初期化です。");
      resolve([]);
      return;
    }
    const tx = db.transaction("characterData", "readonly");
    const store = tx.objectStore("characterData");
    const getReq = store.get("characterData");
    getReq.onsuccess = (event) => {
      if (event.target.result && event.target.result.data) {
        resolve(event.target.result.data);
      } else {
        resolve([]);
      }
    };
    getReq.onerror = () => {
      resolve([]);
    };
  });
};

window.saveWizardDataToIndexedDB = function(wizardData) {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("wizardState", "readwrite");
    const store = tx.objectStore("wizardState");
    const record = { id: "wizardData", data: wizardData };
    const req = store.put(record);
    req.onsuccess = () => resolve();
    req.onerror = (err) => reject(err);
  });
};

window.loadWizardDataFromIndexedDB = function() {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("wizardState", "readonly");
    const store = tx.objectStore("wizardState");
    const getReq = store.get("wizardData");
    getReq.onsuccess = (evt) => {
      if (evt.target.result) {
        resolve(evt.target.result.data);
      } else {
        resolve(null);
      }
    };
    getReq.onerror = (err) => {
      reject(err);
    };
  });
};

window.createParty = function (name) {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("parties", "readwrite");
    const store = tx.objectStore("parties");
    const now = new Date().toISOString();
    const rec = {
      name: name,
      createdAt: now,
      updatedAt: now
    };
    const req = store.add(rec);
    req.onsuccess = (evt) => {
      resolve(evt.target.result); // partyId
    };
    req.onerror = (err) => {
      reject(err);
    };
  });
};

window.getPartyById = function (partyId) {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("parties", "readonly");
    const store = tx.objectStore("parties");
    const req = store.get(partyId);
    req.onsuccess = (evt) => {
      resolve(evt.target.result || null);
    };
    req.onerror = (err) => {
      reject(err);
    };
  });
};

window.listAllParties = function () {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("parties", "readonly");
    const store = tx.objectStore("parties");
    const req = store.getAll();
    req.onsuccess = (evt) => {
      const list = evt.target.result || [];
      list.sort((a, b) => (b.updatedAt || "").localeCompare(a.updatedAt || ""));
      resolve(list);
    };
    req.onerror = (err) => {
      reject(err);
    };
  });
};

window.updateParty = function (party) {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    party.updatedAt = new Date().toISOString();
    const tx = db.transaction("parties", "readwrite");
    const store = tx.objectStore("parties");
    const req = store.put(party);
    req.onsuccess = () => {
      resolve();
    };
    req.onerror = (err) => {
      reject(err);
    };
  });
};

window.deletePartyById = function (partyId) {
  return new Promise((resolve, reject) => {
    if (!db) {
      return reject("DB未初期化");
    }
    const tx = db.transaction("parties", "readwrite");
    const store = tx.objectStore("parties");
    const req = store.delete(partyId);
    req.onsuccess = () => {
      resolve();
    };
    req.onerror = (err) => {
      reject(err);
    };
  });
};

/* エンディング関連 */
window.getEnding = function (scenarioId, type) {
  return new Promise((resolve, reject) => {
    if (!db) return reject("DB未初期化");
    const tx = db.transaction("endings", "readonly");
    const store = tx.objectStore("endings");
    const getReq = store.get([scenarioId, type]);
    getReq.onsuccess = (evt) => {
      resolve(evt.target.result || null);
    };
    getReq.onerror = (err) => reject(err);
  });
};

window.saveEnding = function (scenarioId, type, story) {
  return new Promise((resolve, reject) => {
    if (!db) return reject("DB未初期化");
    const tx = db.transaction("endings", "readwrite");
    const store = tx.objectStore("endings");
    const rec = {
      scenarioId,
      type,
      story,
      createdAt: new Date().toISOString()
    };
    const putReq = store.put(rec);
    putReq.onsuccess = () => resolve();
    putReq.onerror = (err) => reject(err);
  });
};

window.deleteEnding = function (scenarioId, type) {
  return new Promise((resolve, reject) => {
    if (!db) return reject("DB未初期化");
    const tx = db.transaction("endings", "readwrite");
    const store = tx.objectStore("endings");
    const delReq = store.delete([scenarioId, type]);
    delReq.onsuccess = () => resolve();
    delReq.onerror = (err) => reject(err);
  });
};

// ============ Entitiesストア関連 ============
window.addEntity = function(entity) {
  return new Promise((resolve, reject) => {
    if (!db) return reject("DB未初期化");
    const tx = db.transaction("entities", "readwrite");
    const store = tx.objectStore("entities");
    const req = store.add(entity);
    req.onsuccess = evt => {
      resolve(evt.target.result);
    };
    req.onerror = err => reject(err);
  });
};

window.updateEntity = function(entity) {
  return new Promise((resolve, reject) => {
    if (!db) return reject("DB未初期化");
    const tx = db.transaction("entities", "readwrite");
    const store = tx.objectStore("entities");
    const req = store.put(entity);
    req.onsuccess = () => resolve();
    req.onerror = err => reject(err);
  });
};

window.getEntitiesByScenarioId = function(scenarioId) {
  return new Promise((resolve, reject) => {
    if (!db) return reject("DB未初期化");
    const tx = db.transaction("entities", "readonly");
    const store = tx.objectStore("entities");
    const idx = store.index("scenarioId");
    const range = IDBKeyRange.only(scenarioId);
    const results = [];
    idx.openCursor(range).onsuccess = evt => {
      const cursor = evt.target.result;
      if (cursor) {
        results.push(cursor.value);
        cursor.continue();
      } else {
        resolve(results);
      }
    };
    idx.openCursor(range).onerror = err => reject(err);
  });
};

window.deleteEntity = function(entityId) {
  return new Promise((resolve, reject) => {
    if (!db) return reject("DB未初期化");
    const tx = db.transaction("entities", "readwrite");
    const store = tx.objectStore("entities");
    const req = store.delete(entityId);
    req.onsuccess = () => resolve();
    req.onerror = err => reject(err);
  });
};
---
sceneMain.js
/********************************
 * sceneMain.js
 *  - ページ全体の初期化・イベント登録
 *  - 複数シナリオ対応
 *  - ユニークスロット方式ロード対応
 ********************************/

window.addEventListener("DOMContentLoaded", () => {
  const autoCbx = document.getElementById("auto-generate-candidates-checkbox");
  if (autoCbx) {
    // 初期状態読み込み
    autoCbx.checked = (localStorage.getItem("autoGenerateCandidates") === "true");

    // 変更時に保存
    autoCbx.addEventListener("change", () => {
      localStorage.setItem("autoGenerateCandidates", autoCbx.checked);
    });
  }

  // シーン生成ボタン
  const nextSceneBtn = document.getElementById("next-scene");
  if (nextSceneBtn) {
    nextSceneBtn.addEventListener("click", () => {
      getNextScene();
    });
  }

  // 戻るボタン（暫定で history.back()）
  const backToMenuBtn = document.getElementById("back-to-menu");
  if (backToMenuBtn) {
    backToMenuBtn.addEventListener("click", () => {
      history.back();
    });
  }
});

window.onload = async () => {
  // 1) IndexedDB初期化
  await initIndexedDB();

  // 2) APIキー読み込み
  const savedApiKey = localStorage.getItem('apiKey');
  if (savedApiKey) {
    window.apiKey = savedApiKey;
  }

  // 3) URLパラメータを解析
  const urlParams = new URLSearchParams(window.location.search);

  // ▼ まず「slotIndex=.. & action=load」があれば、ユニークスロットからロード
  const slotIndexStr = urlParams.get("slotIndex");
  const action = urlParams.get("action");

  if (slotIndexStr && action === "load") {
    // ユニークスロットロード: universalSaves ストアから取得
    const sIdx = parseInt(slotIndexStr, 10);
    const slotRec = await getUniversalSave(sIdx);
    if (!slotRec || !slotRec.data) {
      alert("指定されたスロットが存在しない、または空です。ロードできません。");
      return;
    }
    const scenarioIdToLoad = slotRec.data.scenarioId;
    if (!scenarioIdToLoad) {
      alert("スロットにシナリオ情報がありません。ロードできません。");
      return;
    }

    // DBにシナリオがあるか確認
    const scObj = await getScenarioById(scenarioIdToLoad);
    if (!scObj) {
      alert("スロット内のシナリオがDBに存在しません。ロード不可。");
      return;
    }

    // シナリオIDを切り替え
    window.currentScenarioId = scenarioIdToLoad;

    // doLoadScenarioFromSlot() でDBのシーン履歴を上書きし、画面を更新
    await doLoadScenarioFromSlot(slotRec.data);

    // UI切り替え: inputセクション非表示、ゲーム画面表示
    const inputSec = document.querySelector('.input-section');
    if (inputSec) inputSec.style.display = 'none';
    const gameSec = document.querySelector('.game-section');
    if (gameSec) gameSec.style.display = 'block';

    alert(`スロット${sIdx}をロードし、シナリオID ${scenarioIdToLoad} を表示しました。`);
    return; // ここで完了
  }

  // ▼ それ以外は、従来の「?scenarioId=」をチェック
  const scenarioIdStr = urlParams.get("scenarioId");
  const scenarioId = scenarioIdStr ? parseInt(scenarioIdStr, 10) : null;
  window.currentScenarioId = scenarioId || null;

  // 4) シナリオIDがあれば、DBから読み込んで画面を構築
  if (window.currentScenarioId) {
    // 旧の「入力セクション」は非表示、ゲーム画面のみ表示
    const inputSec = document.querySelector('.input-section');
    if (inputSec) inputSec.style.display = 'none';

    const gameSec = document.querySelector('.game-section');
    if (gameSec) gameSec.style.display = 'block';

    // sceneManager.js 側の loadScenarioData() でシナリオ＆履歴を取得して表示
    await loadScenarioData(window.currentScenarioId);
    // updateSceneHistory(); // 必要なら
  }

  // -------- ネタバレ関連 --------
  const spoilerModal = document.getElementById("spoiler-modal");
  const spoilerButton = document.getElementById("spoiler-button");
  const closeSpoilerModalBtn = document.getElementById("close-spoiler-modal");
  if (spoilerButton) {
    spoilerButton.addEventListener("click", () => {
      spoilerModal.style.display = "flex";
    });
  }
  if (closeSpoilerModalBtn) {
    closeSpoilerModalBtn.addEventListener("click", () => {
      spoilerModal.style.display = "none";
    });
  }

  // 画像生成 (自動)
  const autoGenBtn = document.getElementById('image-auto-generate-button');
  if (autoGenBtn) {
    autoGenBtn.addEventListener('click', () => {
      generateImageFromCurrentScene();
    });
  }

  // 画像生成 (カスタム)
  const promptModalBtn = document.getElementById('image-prompt-modal-button');
  if (promptModalBtn) {
    promptModalBtn.addEventListener('click', () => {
      openImagePromptModal();
    });
  }

  // カスタム画像生成 決定
  const customGenBtn = document.getElementById('image-custom-generate-button');
  if (customGenBtn) {
    customGenBtn.addEventListener('click', () => {
      onCustomImageGenerate();
    });
  }

  // カスタム画像生成 キャンセル
  const customCancelBtn = document.getElementById('image-custom-cancel-button');
  if (customCancelBtn) {
    customCancelBtn.addEventListener('click', () => {
      closeImagePromptModal();
    });
  }

  // リクエストキャンセル
  const cancelRequestBtn = document.getElementById('cancel-request-button');
  if (cancelRequestBtn) {
    cancelRequestBtn.addEventListener('click', onCancelFetch);
  }

  // メニューに戻るボタン
  const backMenuBtn = document.getElementById('back-to-menu');
  if (backMenuBtn) {
    backMenuBtn.addEventListener('click', () => {
      window.location.href = "index.html";
    });
  }

  // ▼ 全クリアボタン
  const clearAllSlotsBtn = document.getElementById("clear-all-slots-button");
  if (clearAllSlotsBtn) {
    clearAllSlotsBtn.addEventListener("click", onClearAllSlots);
  }
  // 背景の初期化
  await initBackground("scenario");
};
---
carousel.js
function initCarousel() {
  const track = document.querySelector(".carousel-track");
  if (!track) return;

  let cells = Array.from(track.querySelectorAll(".carousel-cell"));
  if (cells.length < 1) return;

  const tabBtns = Array.from(document.querySelectorAll(".carousel-tab"));

  // 1) 先頭と末尾のクローンを作る（is-clonedクラス付与）
  const firstClone = cells[0].cloneNode(true);
  firstClone.classList.add("is-cloned");
  const lastClone = cells[cells.length - 1].cloneNode(true);
  lastClone.innerHTML = "";
  lastClone.classList.add("is-cloned");
  track.appendChild(firstClone);
  track.insertBefore(lastClone, track.firstElementChild);

  // 2) クローンを含む全セルを再取得
  let allCells = Array.from(track.querySelectorAll(".carousel-cell"));

  let currentIndex = 1; // 初期は「先頭クローンの直後」＝1
  let cellWidth = 0;
  let currentTranslate = 0;
  let prevTranslate = 0;
  let isDragging = false;
  let startX = 0;
  let animationId = 0;

  // MutationObserver でセルのサイズ変化を検知し、自動で再計算する ---
  let mutationTimer = null;
  const observer = new MutationObserver(() => {
    // 連続で変化が起きても対応できるようdebounce
    if (mutationTimer) {
      clearTimeout(mutationTimer);
    }
    mutationTimer = setTimeout(() => {
      // 内容が変わったあと、しばらくしてサイズ再計算
      updateCellWidth();
    }, 500);
  });
  observer.observe(track, {
    childList: true,
    subtree: true,
    characterData: true,
    attributes: true
  });
  // -----------------------------------------------------------------------

  // --- (追加) フォーカスを拾ってそのセルをアクティブ表示にする ---
  track.addEventListener("focusin", (e) => {
    // フォーカスされた要素がどの.cellに属するかを探す
    const targetCell = e.target.closest(".carousel-cell");
    if (!targetCell) return;

    // allCells配列上のインデックスを取得
    const idx = allCells.indexOf(targetCell);
    if (idx === -1) return;

    // クローン込みの currentIndex に設定して移動
    currentIndex = idx;
    setPositionByIndex(true);
  });
  // -----------------------------------------------------------------------

  // 3) タブボタンクリックで移動
  tabBtns.forEach((btn, i) => {
    btn.addEventListener("click", () => {
      currentIndex = i + 1; // クローンが先頭に1枚あるので+1
      setPositionByIndex(true);
      updateActiveTab(i);
    });
  });

  function updateActiveTab(realIndex) {
    tabBtns.forEach(t => t.classList.remove("active"));
    if (tabBtns[realIndex]) {
      tabBtns[realIndex].classList.add("active");
    }
  }

  // 4) ウィンドウリサイズや初期表示時にセル幅を計測
  function updateCellWidth() {
    const anyCell = allCells[0];
    if (!anyCell) return;
    cellWidth = anyCell.offsetWidth;
    if (!cellWidth) {
      requestAnimationFrame(updateCellWidth);
      return;
    }
    setPositionByIndex(false);
  }

  window.addEventListener("resize", updateCellWidth);
  updateCellWidth();

  // 5) ドラッグ / スワイプ関連
  track.addEventListener("pointerdown", dragStart);
  track.addEventListener("pointermove", dragAction);
  track.addEventListener("pointerup", dragEnd);
  track.addEventListener("pointercancel", dragEnd);
  track.addEventListener("pointerleave", dragEnd);

  function dragStart(e) {
    if (!cellWidth) return;

    const tag = e.target.tagName.toLowerCase();
    // テキストエリアやボタンなどはドラッグでスワイプしないように
    if (["textarea", "input", "button", "select"].includes(tag)) {
      return;
    }

    isDragging = true;
    track.style.transition = "none";
    startX = e.clientX;
    prevTranslate = currentTranslate;
    animationId = requestAnimationFrame(animation);
  }

  function dragAction(e) {
    if (!isDragging) return;
    const currentX = e.clientX;
    const diff = currentX - startX;
    currentTranslate = prevTranslate + diff;

    // クローンを含む全体範囲で強制クリップ
    const maxTranslate = 0;
    const minTranslate = -cellWidth * (allCells.length - 1);
    if (currentTranslate > maxTranslate) {
      currentTranslate = maxTranslate;
    } else if (currentTranslate < minTranslate) {
      currentTranslate = minTranslate;
    }

    e.preventDefault(); // 横スワイプを優先
  }

  function dragEnd() {
    if (!isDragging) return;
    isDragging = false;
    cancelAnimationFrame(animationId);

    const movedBy = currentTranslate - prevTranslate;
    const threshold = cellWidth * 0.1;
    if (movedBy < -threshold) {
      currentIndex++;
    } else if (movedBy > threshold) {
      currentIndex--;
    }

    setPositionByIndex(true);
  }

  function animation() {
    track.style.transform = `translateX(${currentTranslate}px)`;
    if (isDragging) {
      requestAnimationFrame(animation);
    }
  }

  // 6) インデックスに応じた位置へ移動
  function setPositionByIndex(smooth) {
    const oldTransform = track.style.transform; // 変更前のtransform

    if (smooth) {
      track.style.transition = "transform 0.3s";
    } else {
      track.style.transition = "none";
    }
    currentTranslate = -cellWidth * currentIndex;
    const newTransform = `translateX(${currentTranslate}px)`;
    track.style.transform = newTransform;

    // トランジションが発火しない場合もあるので、一応フォールバック
    if (smooth && oldTransform === newTransform) {
      handleTransitionEndManually();
    }
  }

  // 7) transitionend でクローンセル位置を調整
  track.addEventListener("transitionend", () => {
    handleTransitionEndManually();
  });

  // 8) 実処理
  function handleTransitionEndManually() {
    if (!cellWidth) return;

    // 先頭クローン(index=0)にいる → 最後の本物セルへ
    if (currentIndex === 0) {
      track.style.transition = "none";
      currentIndex = cells.length; // 本物の末尾
      currentTranslate = -cellWidth * currentIndex;
      track.style.transform = `translateX(${currentTranslate}px)`;
    }
    // 末尾クローン(index=allCells.length-1) → 先頭の本物セルへ
    else if (currentIndex === allCells.length - 1) {
      track.style.transition = "none";
      currentIndex = 1; // 本物の先頭
      currentTranslate = -cellWidth * currentIndex;
      track.style.transform = `translateX(${currentTranslate}px)`;
    }

    // タブのactive表示を更新
    let realIndex = currentIndex - 1;
    if (realIndex < 0) realIndex = 0;
    if (realIndex >= cells.length) realIndex = cells.length - 1;
    updateActiveTab(realIndex);
  }
}

// 複製セルに含まれるIDを削除
function removeDuplicateIDs() {
  // クローンセル（.is-cloned）を探す
  const clonedCells = document.querySelectorAll(".carousel-cell.is-cloned");
  // 配下にある id を削除
  clonedCells.forEach(cell => {
    const elemsWithId = cell.querySelectorAll("[id]");
    elemsWithId.forEach(el => {
      el.removeAttribute("id");
    });
  });
}
---
sceneGlobals.js
/********************************
 * sceneGlobals.js
 * グローバル変数や共通定数などを集めたファイル
 ********************************/

// -------------------------------
// ▼ グローバル変数
// -------------------------------
window.apiKey = '';

// シーン一覧
window.scenes = [];

// シナリオ全体の情報
window.currentScenarioId = null;
window.currentScenario = null;
window.scenarioType = null;
window.clearCondition = null;
window.sections = [];

// リクエストキャンセル用
window.currentRequestController = null;
window.cancelRequested = false;

// 要約をメモリ上でも管理
window.sceneSummaries = []; // sceneSummaries[chunkIndex] = { en: '...', ja: '...' }

// 選択されたアイテムを保持するための変数（アイテム使用用）
window.selectedItem = null;

// DOMPurify 用設定
window.DOMPURIFY_CONFIG = {
  ALLOWED_TAGS: ["p", "br", "hr", "h3", "h4", "h5", "span", "div", "strong", "em"],
  ALLOWED_ATTR: ["style"]
};
---
sceneManager.js
/********************************
 * sceneManager.js
 * シーン関連の主要ロジックをまとめる
 ********************************/

// --------------------------------------------------
// ▼ シナリオ読み込み
// --------------------------------------------------
window.loadScenarioData = async function (scenarioId) {
  try {
    const sc = await getScenarioById(scenarioId);
    if (!sc) {
      alert("指定シナリオが存在しません。");
      return;
    }
    window.currentScenario = sc;
    window.currentScenarioId = scenarioId;

    const wd = sc.wizardData || {};
    window.scenarioType = wd.scenarioType;
    window.clearCondition = wd.clearCondition || "";
    window.sections = wd.sections || [];

    // シーン一覧をDBから取得してメモリに整形
    await loadAllScenesForScenario(scenarioId);

    // 要約を読み込む
    for (let i = 0; i < 100; i++) {
      const sumRec = await getSceneSummaryByChunkIndex(i);
      if (!sumRec) break;
      window.sceneSummaries[i] = {
        en: sumRec.content_en,
        ja: sumRec.content_ja
      };
    }

    // シーン履歴の表示フラグ
    if (typeof sc.showHistory === 'undefined') {
      sc.showHistory = false;
    }

    // UI再描画 (sceneUI.js に定義)
    updateSceneHistory();
    showLastScene();
    refreshEndingButtons();
    await renderItemChips();

  } catch (err) {
    console.error("シナリオ読み込み失敗:", err);
    alert("読み込み失敗:" + err.message);
  }
};

/**
 * DB の sceneEntries から
 * type='scene', type='image' をまとめて取得し、
 * window.scenes に整形格納する
 */
async function loadAllScenesForScenario(scenarioId) {
  window.scenes = [];
  const allEntries = await getSceneEntriesByScenarioId(scenarioId);

  // シーンと画像を仕分け
  const sceneRecords = allEntries.filter(e => e.type === "scene");
  const imageRecords = allEntries.filter(e => e.type === "image");

  // entryId 昇順
  sceneRecords.sort((a, b) => a.entryId - b.entryId);
  imageRecords.sort((a, b) => a.entryId - b.entryId);

  // シーンごとに images を紐づけ
  for (const sRec of sceneRecords) {
    const scObj = {
      sceneId: sRec.sceneId,
      scenarioId: sRec.scenarioId,
      content: sRec.content || "",
      content_en: sRec.content_en || "",
      action: {
        content: sRec.actionContent || "",
        content_en: sRec.actionContent_en || ""
      },
      images: []
    };

    const imgs = imageRecords.filter(imgRec => imgRec.sceneId === sRec.sceneId);
    scObj.images = imgs.map(img => ({
      entryId: img.entryId,
      dataUrl: img.dataUrl,
      prompt: img.prompt || ""
    }));

    window.scenes.push(scObj);
  }
}

// --------------------------------------------------
// ▼ 次のシーン取得
// --------------------------------------------------
window.getNextScene = async function (useItem = false) {
  if (!window.apiKey) {
    alert("APIキー未設定");
    return;
  }

  const hasIntro = window.scenes.length > 0;
  let pinput = "";

  // 2回目以降のシーンであれば、プレイヤーの行動入力欄を参照
  if (hasIntro) {
    if (!useItem) {
      pinput = (document.getElementById("player-input")?.value || "").trim();
      if (!pinput) {
        alert("プレイヤー行動を入力してください");
        return;
      }
    }
  }

  // アイテム使用の場合
  if (useItem && window.selectedItem) {
    const nm = window.selectedItem.name || "不明アイテム";
    const ds = window.selectedItem.description || "説明不明";
    pinput = `「${nm}という名称の${ds}という説明のあるアイテムを使用します」`;
    window.selectedItem = null; // 使い終わったら解除
  }

  window.cancelRequested = false;
  showLoadingModal(true);

  try {
    // 1) プレイヤー行動を英訳
    let actionEn = "";
    if (pinput) {
      actionEn = await generateEnglishTranslation(pinput);
    }

    // 2) システム + ユーザープロンプト組み立て
    const wd = (window.currentScenario && window.currentScenario.wizardData) || {};
    const sections = wd.sections || [];

    let systemText =
      `あなたは経験豊かなやさしいTRPGのゲームマスターです。
以下を守ってください。
・背景黒が前提の装飾のタグを使う
・<<<< 絶対に出力は日本語で。Please answer in Japanese!!!! >>>>
・決して一つ前のレスポンスと同じにならない
・メタな表現をしない(ゲームマスター視点の内容を書かない)
・シナリオの設定と整合性が取る
・ユーザーが困っている場合はヒントを与える
・時々パーティを会話させる
・次の行動を促すようなシーンを作り、行動の多様性を妨げない
`;

    // セクション情報
    if (sections.length > 0) {
      systemText += "\n======\n";
      for (const sec of sections) {
        systemText += `【セクション${sec.number}】` + (sec.cleared ? "(クリア済み)" : "(未クリア)") + "\n";
        systemText += "条件: " + decompressCondition(sec.conditionZipped) + "\n\n";
      }
      systemText += "======\n";
    }

    const msgs = [{ role: "system", content: systemText }];

    // シナリオ概要 + パーティ情報
    if (window.currentScenario) {
      const scenarioWd = window.currentScenario.wizardData || {};
      const summ = scenarioWd.scenarioSummaryEn?.trim()
        ? scenarioWd.scenarioSummaryEn
        : (scenarioWd.scenarioSummary || "");

      msgs.push({ role: "user", content: "シナリオ概要:" + summ });

      // パーティ情報
      if (scenarioWd.party && scenarioWd.party.length > 0) {
        const ptxt = buildPartyInsertionText(scenarioWd.party); // sceneExtras.js で定義
        msgs.push({ role: "user", content: ptxt });
      }
    }

    // 3) 過去シーンを ChatGPT へ渡す（要約＋未要約部分）
    const actionCount = window.scenes.filter(sc => sc.action && sc.action.content.trim()).length;
    const chunkEnd = Math.floor((actionCount - 15) / 10);
    for (let i = 0; i <= chunkEnd; i++) {
      if (i < 0) continue;
      if (window.sceneSummaries[i]) {
        const sumObj = window.sceneSummaries[i];
        msgs.push({
          role: "assistant",
          content: sumObj.en || sumObj.ja || "(no summary)"
        });
      }
    }
    const skipCount = (chunkEnd + 1) * 10;
    let aCnt = 0;
    for (const scn of window.scenes) {
      if (scn.action?.content.trim()) {
        aCnt++;
        if (aCnt <= skipCount) continue;
        const actText = scn.action.content_en?.trim() ? scn.action.content_en : scn.action.content;
        msgs.push({ role: "user", content: "player action:" + actText });
      }
      if (aCnt <= skipCount) continue;
      const scText = scn.content_en?.trim() ? scn.content_en : scn.content;
      msgs.push({ role: "assistant", content: scText });
    }

    // 今回の行動
    if (pinput) {
      msgs.push({ role: "user", content: "プレイヤーの行動:" + pinput });
    }

    // 4) ChatGPT呼び出し
    window.currentRequestController = new AbortController();
    const signal = window.currentRequestController.signal;
    const chatModel = "gpt-4";

    const resp = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${window.apiKey}`
      },
      body: JSON.stringify({
        model: chatModel,
        messages: msgs,
        temperature: 0.7
      }),
      signal
    });
    if (window.cancelRequested) {
      showLoadingModal(false);
      return;
    }
    const data = await resp.json();
    if (data.error) throw new Error(data.error.message);

    // 5) 日本語化
    const rawScene = data.choices[0].message.content || "";
    let finalSceneJa = rawScene;
    let finalSceneEn = "";
    if (!containsJapanese(rawScene)) {
      finalSceneJa = await generateJapaneseTranslation(rawScene);
      finalSceneEn = rawScene;
    } else {
      finalSceneEn = await generateEnglishTranslation(rawScene);
    }

    // 6) DBに保存
    const sid = "scene_" + Date.now();
    const sRec = {
      scenarioId: window.currentScenarioId || 0,
      type: "scene",
      sceneId: sid,
      content: finalSceneJa,
      content_en: finalSceneEn,
      actionContent: pinput,
      actionContent_en: actionEn,
      prompt: "",
      dataUrl: ""
    };
    const newId = await addSceneEntry(sRec);
    sRec.entryId = newId;

    // メモリにも追加
    const newSceneObj = {
      sceneId: sid,
      scenarioId: sRec.scenarioId,
      content: finalSceneJa,
      content_en: finalSceneEn,
      action: {
        content: pinput,
        content_en: actionEn
      },
      images: []
    };
    window.scenes.push(newSceneObj);

    // 7) 挿絵用プロンプト
    const imagePromptText = await generateImagePromptFromScene(finalSceneJa);
    if (imagePromptText) {
      sRec.prompt = imagePromptText;
      await updateSceneEntry(sRec); // prompt更新
    }

    // 8) シナリオ更新
    if (window.currentScenario) {
      await updateScenario({
        ...window.currentScenario,
        updatedAt: new Date().toISOString()
      });
    }

    // 9) セクション達成チェック
    await checkSectionClearViaChatGPT(pinput, finalSceneJa);

    // 10) シーン要約処理 (10アクション単位)
    await handleSceneSummaries();

    // 11) UIの再描画
    const playerInputEl = document.getElementById("player-input");
    if (!useItem && playerInputEl) {
      playerInputEl.value = "";
    }
    updateSceneHistory();
    showLastScene();

    // 12) 回答候補コンテナクリア＆自動生成
    const candidatesContainer = document.getElementById("action-candidates-container");
    if (candidatesContainer) {
      candidatesContainer.innerHTML = "";
    }
    const autoGenCheckbox = document.getElementById("auto-generate-candidates-checkbox");
    if (autoGenCheckbox && autoGenCheckbox.checked) {
      onGenerateActionCandidates();
    }

  } catch (e) {
    if (e.name === "AbortError") {
      console.warn("シーン取得キャンセル");
    } else {
      console.error(e);
      alert("シーン取得失敗:" + e.message);
    }
  } finally {
    showLoadingModal(false);
  }
};

// --------------------------------------------------
// ▼ 英日翻訳系
// --------------------------------------------------
function containsJapanese(text) {
  return /[ぁ-んァ-ン一-龯]/.test(text);
}

async function generateEnglishTranslation(japaneseText) {
  if (!japaneseText.trim()) return "";
  const sys = "あなたは優秀な翻訳家です。";
  const u = `以下の日本語テキストを自然な英語に翻訳してください:\n${japaneseText}\n`;
  try {
    const resp = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${window.apiKey}`
      },
      body: JSON.stringify({
        model: "gpt-4",
        messages: [
          { role: "system", content: sys },
          { role: "user", content: u }
        ],
        temperature: 0.3
      })
    });
    const data = await resp.json();
    if (data.error) throw new Error(data.error.message);
    return data.choices[0].message.content.trim();
  } catch (err) {
    console.error("翻訳失敗:", err);
    return "";
  }
}

async function generateJapaneseTranslation(englishText) {
  if (!englishText.trim()) return "";
  const sys = "あなたは優秀な翻訳家です。";
  const u = `以下の英文を自然な日本語に翻訳:\n${englishText}`;
  try {
    const resp = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${window.apiKey}`
      },
      body: JSON.stringify({
        model: "gpt-4",
        messages: [
          { role: "system", content: sys },
          { role: "user", content: u }
        ],
        temperature: 0.3
      })
    });
    const data = await resp.json();
    if (data.error) throw new Error(data.error.message);
    return data.choices[0].message.content.trim();
  } catch (err) {
    console.error("翻訳失敗:", err);
    return englishText;
  }
}

// --------------------------------------------------
// ▼ セクション達成チェック
// --------------------------------------------------
async function checkSectionClearViaChatGPT(latestAction, latestScene) {
  const wd = window.currentScenario?.wizardData;
  if (!wd || !wd.sections) return;
  const sorted = wd.sections.slice().sort((a, b) => a.number - b.number);
  const firstUncleared = sorted.find(s => !s.cleared);
  if (!firstUncleared) return;

  const conditionText = decompressCondition(firstUncleared.conditionZipped);
  const scenarioSummary = wd.scenarioSummary || "(概要なし)";

  const messages = [
    {
      role: "system",
      content: "あなたはTRPGゲームマスターのサポートAIです。回答はYESまたはNOのみでお願いします。"
    },
    {
      role: "user",
      content: `
シナリオ概要:
${scenarioSummary}

達成条件:
「${conditionText}」

最新の行動とシーン:
(行動) ${latestAction}
(シーン) ${latestScene}

この達成条件は、今の行動やシーン内容から見て、既に満たされましたか？
YESかNOのみで答えてください。判断が難しい時はYESにしてください。
`
    }
  ];

  try {
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: { "Content-Type": "application/json", "Authorization": `Bearer ${window.apiKey}` },
      body: JSON.stringify({
        model: "gpt-4",
        messages,
        temperature: 0.0
      })
    });
    const data = await response.json();
    if (data.error) throw new Error(data.error.message);

    const answer = (data.choices[0].message.content || "").trim().toUpperCase();
    if (answer.startsWith("YES")) {
      firstUncleared.cleared = true;
      window.currentScenario.wizardData.sections = wd.sections;
      await updateScenario(window.currentScenario);
      showToast(`セクション${firstUncleared.number}をクリアしました。`);

      // クリアしたらエンディングボタン表示更新
      refreshEndingButtons();
    } else {
      console.log("未達成と判定されました。");
    }
  } catch (err) {
    console.error("セクション判定API失敗:", err);
  }
}

// --------------------------------------------------
// ▼ 要約作成
// --------------------------------------------------
async function handleSceneSummaries() {
  const actionCount = window.scenes.filter(s => s.action && s.action.content.trim()).length;
  if (actionCount >= 15) {
    const chunkIndex = Math.floor((actionCount - 15) / 10);
    if (chunkIndex >= 0 && !window.sceneSummaries[chunkIndex]) {
      const startAction = chunkIndex * 10 + 1;
      const endAction = (chunkIndex + 1) * 10;

      let gathered = [];
      let aCounter = 0;
      for (const scn of window.scenes) {
        if (scn.action?.content.trim()) {
          aCounter++;
        }
        if (aCounter >= startAction && aCounter <= endAction) {
          if (scn.action?.content.trim()) {
            gathered.push("A:" + scn.action.content);
          }
          gathered.push("S:" + scn.content);
        }
      }
      const textForSummary = gathered.join("\n");
      const enSummary = await generateSummaryWithLimit(textForSummary, 5, "en");
      const jaSummary = await generateSummaryWithLimit(textForSummary, 5, "ja");

      const sumRec = {
        chunkIndex,
        content_en: enSummary,
        content_ja: jaSummary
      };
      await addSceneSummaryRecord(sumRec);
      window.sceneSummaries[chunkIndex] = { en: enSummary, ja: jaSummary };
    }
  }
}

async function generateSummaryWithLimit(text, lines = 5, lang = "en") {
  if (!text.trim()) return "";
  let sys = "You are a talented summarizer. The final language must be English.";
  let user = `Summarize the following text in ${lines} lines of English:\n${text}`;

  if (lang === "ja") {
    sys = "あなたは優秀な要約者です。必ず日本語で。";
    user = `以下のテキストを${lines}行程度で簡潔にまとめてください:\n${text}`;
  }

  try {
    const resp = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${window.apiKey}`
      },
      body: JSON.stringify({
        model: "gpt-4",
        messages: [
          { role: "system", content: sys },
          { role: "user", content: user }
        ],
        temperature: 0.5
      })
    });
    const data = await resp.json();
    if (data.error) throw new Error(data.error.message);
    return data.choices[0].message.content.trim();
  } catch (err) {
    console.error("要約失敗:", err);
    return "";
  }
}

// --------------------------------------------------
// ▼ 挿絵用英語プロンプト生成
// --------------------------------------------------
async function generateImagePromptFromScene(sceneText) {
  if (!window.apiKey) return "";
  try {
    const systemMsg = {
      role: "system",
      content: "あなたは画像生成のための短い英語プロンプトを作るアシスタントです。"
    };
    const userMsg = {
      role: "user",
      content: `
以下のシーン文章をもとに、イラストを生成するための英語メインのキーワード列を作成してください。
説明文や文章体は禁止。
シーン:
${sceneText}
      `
    };

    const resp = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${window.apiKey}`
      },
      body: JSON.stringify({
        model: "gpt-4-0613",
        messages: [systemMsg, userMsg],
        temperature: 0.7
      })
    });
    const data = await resp.json();
    if (data.error) {
      console.warn("imagePrompt function callingエラー:", data.error);
      return "";
    }
    return (data.choices[0].message.content || "").trim();
  } catch (e) {
    console.error("generateImagePromptFromScene失敗:", e);
    return "";
  }
}

/** 最新シーンを要約しカード化に向けた情報を抽出 */
async function getLastSceneSummary() {

  const lastSceneEntry = [...window.scenes].slice(-1)[0] || null;
  if (!lastSceneEntry) return "シーンがありません。";

  const text = lastSceneEntry.content;
  const systemPrompt = `
あなたは優秀なカード作成用プロンプト生成者。
以下フォーマットで【名前】【タイプ】【外見】を作ってください。`;
  const userPrompt = `
シーン文:
${text}
ここからエレメントにできそうな対象1つを抽出し、【名前】【タイプ】【外見】を生成してください。
`;

  try {
    const resp = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": 'Bearer ' + window.apiKey
      },
      body: JSON.stringify({
        model: "gpt-4",
        messages: [
          { role: "system", content: systemPrompt },
          { role: "user", content: userPrompt }
        ]
      })
    });
    const data = await resp.json();
    if (data.error) throw new Error(data.error.message);

    return data.choices[0].message.content || "";
  } catch (e) {
    console.error("要約失敗:", e);
    return "(要約失敗)";
  }
}

// --------------------------------------------------
// ▼ 共通処理
// --------------------------------------------------
window.onCancelFetch = function () {
  if (window.currentRequestController) {
    window.currentRequestController.abort();
  }
  showLoadingModal(false);
};

window.decompressCondition = function (zippedBase64) {
  if (!zippedBase64) return "(不明)";
  try {
    const bin = atob(zippedBase64);
    const uint8 = new Uint8Array([...bin].map(c => c.charCodeAt(0)));
    const inf = pako.inflate(uint8);
    return new TextDecoder().decode(inf);
  } catch (e) {
    console.error("decompress失敗:", e);
    return "(解凍エラー)";
  }
};

window.showLoadingModal = function (show) {
  const m = document.getElementById("loading-modal");
  if (!m) return;
  if (show) {
    m.classList.add("active");
  } else {
    m.classList.remove("active");
  }
};
---
sceneExtras.js
/********************************
 * sceneExtras.js
 * エンディングやエンティティ(アイテム/登場人物)、
 * パーティ表示など補助的な機能をまとめる
 ********************************/

/* =============================
   エンディング関連
============================= */

window.showEndingModal = async function (type) {
  const scenarioId = window.currentScenario?.scenarioId;
  if (!scenarioId) {
    alert("シナリオ未選択");
    return;
  }
  const existing = await getEnding(scenarioId, type);
  if (existing) {
    openEndingModal(type, existing.story);
  } else {
    const newStory = await generateEndingStory(type);
    if (!newStory) return;
    await saveEnding(scenarioId, type, newStory);
    openEndingModal(type, newStory);
  }
};

// 2) multiModal版 openEndingModal
window.openEndingModal = function (type, story) {
  // typeが "clear" なら「クリアエンディング」、それ以外は「エンディング」
  const titleText = (type === "clear") ? "クリアエンディング" : "エンディング";

  // multiModal でモーダルを表示
  multiModal.open({
    title: titleText,
    contentHtml: `
      <pre id="ending-modal-story" style="white-space:pre-wrap;">${DOMPurify.sanitize(story)}</pre>
    `,
    showCloseButton: true,        // 右上×で閉じる
    closeOnOutsideClick: true,
    appearanceType: "center",
    // ボタン2つ: 「再生成」「閉じる」
    additionalButtons: [
      {
        label: "再生成",
        onClick: () => {
          // 再生成: type判定に工夫が必要
          onClickRegenerateEndingMulti(type);
        }
      }
    ],
    cancelLabel: "閉じる"  // 下部に「閉じる」ボタン
  });
};

// 3) onClickRegenerateEnding() を少し改造:
//    旧版では #ending-modal-title のテキストから typeを判定
//    → multiModal下ではHTML要素が消えているので
//    → openEndingModal側で引数を渡す or global変数を使う

window.onClickRegenerateEndingMulti = async function (type) {
  const scenarioId = window.currentScenario?.scenarioId;
  if (!scenarioId) return;
  // 旧コード:  #ending-modal-title.textContent.includes("クリア") → type="clear"
  // ここは既に type を引数で受け取るようにした

  // 1) 既存Ending削除
  await deleteEnding(scenarioId, type);

  // 2) 再生成
  const newStory = await generateEndingStory(type);
  if (!newStory) return;
  await saveEnding(scenarioId, type, newStory);

  // 3) multiModalを開き直す or 部分更新
  //    例: 開き直し
  openEndingModal(type, newStory);
};


async function generateEndingStory(type) {
  if (!window.apiKey) {
    alert("APIキーが未設定です");
    return "";
  }
  const scenario = window.currentScenario;
  if (!scenario) {
    alert("シナリオデータがありません");
    return "";
  }
  const wd = scenario.wizardData || {};
  const isClear = (type === "clear");
  const scenarioSummary = wd.scenarioSummary || "(概要なし)";
  const party = wd.party || [];

  // 最新10シーン
  let lastScenes = [...window.scenes];
  if (lastScenes.length > 10) {
    lastScenes = lastScenes.slice(-10);
  }
  const combinedSceneText = lastScenes.map(s => s.content).join("\n------\n");

  const sectionTextArr = (wd.sections || []).map(s => {
    const cond = decompressCondition(s.conditionZipped);
    return `・セクション${s.number}(${s.cleared ? "クリア" : "未クリア"}): ${cond}`;
  });
  const joinedSections = sectionTextArr.join("\n");
  const endTypePrompt = isClear ? "ハッピーエンド" : "バッドエンド";

  let prompt = `
以下の情報をもとに、
1)シナリオ概要
2)パーティ構成
3)あらすじ
4)セクション
5)その後の話

この5部構成でエンディングストーリーを作ってください。結末は必ず「${endTypePrompt}」にしてください。
あらすじ部分は、下記のシーン履歴をベースにしつつ、あまり簡潔になりすぎないように描写してください。

■シナリオ概要
${scenarioSummary}
`;

  if (party.length !== 0) {
    prompt += `\n■パーティ構成\n`;
    prompt += party.map(p => `- ${p.name}(${p.type || "?"})`).join("\n");
  }

  prompt += `
■シーン履歴(最大10シーン)
${combinedSceneText}

■セクション情報
${joinedSections}
`;

  try {
    showLoadingModal(true);
    window.currentRequestController = new AbortController();
    const signal = window.currentRequestController.signal;

    const resp = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${window.apiKey}`
      },
      body: JSON.stringify({
        model: "gpt-4",
        messages: [
          { role: "system", content: "あなたは優秀なTRPGエンディング生成アシスタントです。日本語で回答してください。" },
          { role: "user", content: prompt }
        ],
        temperature: 0.7
      }),
      signal
    });
    if (window.cancelRequested) {
      return "";
    }
    const data = await resp.json();
    if (data.error) throw new Error(data.error.message);

    return (data.choices[0].message.content || "").trim();
  } catch (err) {
    if (err.name === "AbortError") {
      console.warn("エンディング生成キャンセル");
      return "";
    }
    console.error("エンディング生成失敗:", err);
    alert("エンディング生成に失敗:\n" + err.message);
    return "";
  } finally {
    showLoadingModal(false);
  }
}

/** 全セクションがクリア済みかどうか */
window.areAllSectionsCleared = function () {
  if (!window.sections || !window.sections.length) return false;
  return window.sections.every(s => s.cleared);
};

/** エンディングボタン表示切り替え */
window.refreshEndingButtons = function () {
  const endingBtn = document.getElementById("ending-button");
  const clearEndingBtn = document.getElementById("clear-ending-button");
  if (!endingBtn || !clearEndingBtn) return;

  if (!window.sections || window.sections.length === 0) {
    endingBtn.style.display = "none";
    clearEndingBtn.style.display = "none";
    return;
  }

  // いずれか1つでもクリア済みか？
  const anyCleared = window.sections.some(sec => sec.cleared);
  // 全クリアか？
  const allCleared = areAllSectionsCleared();

  if (!anyCleared) {
    endingBtn.style.display = "none";
    clearEndingBtn.style.display = "none";
    return;
  }
  if (allCleared) {
    endingBtn.style.display = "none";
    clearEndingBtn.style.display = "inline-block";
  } else {
    endingBtn.style.display = "inline-block";
    clearEndingBtn.style.display = "none";
  }
};


/* =============================
   エンティティ関連
============================= */

/**
 * まとめてリスト描画＆アイテムチップス更新を行うヘルパー関数
 */
async function refreshEntitiesAndChips() {
  await renderEntitiesList();
  await renderItemChips();
}

/** シナリオ全体のテキストから新規エンティティ(アイテム/キャラ)を抽出して登録 */
window.onUpdateEntitiesFromAllScenes = async function () {
  if (!window.apiKey) {
    alert("APIキーが未設定です。");
    return;
  }
  const scenarioId = window.currentScenarioId;
  if (!scenarioId) {
    alert("シナリオIDが不明です");
    return;
  }
  const existingEntities = await getEntitiesByScenarioId(scenarioId);

  const actionCount = window.scenes.length;
  let chunkEnd = Math.floor((actionCount - 15) / 10);
  if (chunkEnd < 0) chunkEnd = 0;

  let scenarioText = "";

  // 1) 古い部分(要約)
  for (let i = 0; i < chunkEnd; i++) {
    const sumObj = window.sceneSummaries[i];
    if (sumObj && (sumObj.en || sumObj.ja)) {
      scenarioText += sumObj.en || sumObj.ja;
      scenarioText += "\n";
    }
  }

  // 2) スキップ数
  const skipCount = chunkEnd * 10;

  // 3) 直近は生テキスト(英語優先)
  let aCnt = 0;
  for (const scn of window.scenes) {
    if (scn.action?.content.trim()) {
      aCnt++;
    }
    if (aCnt <= skipCount && aCnt !== 0) continue;

    if (scn.action?.content.trim()) {
      const actionText = scn.action.content_en?.trim()
        ? scn.action.content_en
        : scn.action.content;
      scenarioText += `\n(プレイヤー行動)${actionText}\n`;
    }

    const sceneText = scn.content_en?.trim()
      ? scn.content_en
      : scn.content;
    scenarioText += `(シーン)${sceneText}\n`;
  }

  const existingTextArr = existingEntities.map(ent => {
    return `${ent.name}: ${ent.description}`;
  });
  const existingDesc = existingTextArr.join("\n") || "（なし）";

  const systemContent = "あなたはTRPGアシスタントAIです。日本語で回答してください。";
  const userContent = `
以下はTRPGのシナリオ中に登場したテキストです。
すでに抽出済みのアイテム/キャラクター(人物)は下記のとおりです：
${existingDesc}

新たに見つかったアイテムや登場人物があれば、JSON配列で出力してください。
固有名詞も日本語にしてください。日本語にできないものはカタカナにしてください。
さらに、もしプレイヤーがすでにそのアイテムを入手したと判断できる場合は "acquired": true、それ以外は "acquired": false としてください。
例：
[{"category":"item","name":"木の杖","description":"～","acquired": false}, {"category":"character","name":"太郎","description":"～"}]

地域や場所を含めないでください。
すでにあるものに似ている場合は出力しないでください。重複しそうなものは省いてください。
シナリオ全体本文:
====================
${scenarioText}
====================
`;

  try {
    showLoadingModal(true);
    const resp = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${window.apiKey}`
      },
      body: JSON.stringify({
        model: "gpt-4",
        messages: [
          { role: "system", content: systemContent },
          { role: "user", content: userContent }
        ],
        temperature: 0.5
      })
    });
    const data = await resp.json();
    if (data.error) throw new Error(data.error.message);

    const rawAnswer = data.choices[0].message.content;
    let newEntities = [];
    try {
      newEntities = JSON.parse(rawAnswer);
    } catch (e) {
      console.warn("JSONパース失敗:", e);
    }

    console.log(newEntities);

    const candidateListDiv = document.getElementById("entity-candidate-list");
    if (!newEntities || newEntities.length === 0) {
      if (candidateListDiv) {
        candidateListDiv.innerHTML = "新しく追加できそうなアイテム/人物はありませんでした。";
      }
      return;
    }

    for (const e of newEntities) {
      const rec = {
        scenarioId,
        category: (e.category === "character") ? "character" : "item",
        name: e.name || "名称不明",
        description: e.description || "",
        acquired: e.acquired === true,
        imageData: ""
      };
      await addEntity(rec);
    }
    // ▼ ここでまとめてUIを更新
    await refreshEntitiesAndChips();
    if (candidateListDiv) {
      candidateListDiv.innerHTML = "新しいアイテム/登場人物を自動登録しました。";
    }

  } catch (err) {
    console.error("onUpdateEntitiesFromAllScenes失敗:", err);
    alert("抽出に失敗:\n" + err.message);
  } finally {
    showLoadingModal(false);
  }
};

/** 情報モーダルを開いて一覧表示 */
window.openEntitiesModal = async function () {
  const infoModal = document.getElementById("info-modal");
  if (!infoModal) return;
  await renderEntitiesList();

  const candidateListDiv = document.getElementById("entity-candidate-list");
  if (candidateListDiv) candidateListDiv.innerHTML = "";

  infoModal.classList.add("active");
};

window.renderEntitiesList = async function () {
  const listDiv = document.getElementById("entity-list-container");
  if (!listDiv) return;
  listDiv.innerHTML = "";

  const scenarioId = window.currentScenarioId;
  if (!scenarioId) {
    listDiv.textContent = "シナリオが未選択です。";
    return;
  }

  const allEnts = await getEntitiesByScenarioId(scenarioId);
  const items = allEnts.filter(e => e.category === "item");
  const chars = allEnts.filter(e => e.category === "character");

  if (items.length > 0) {
    const itemTitle = document.createElement("h3");
    itemTitle.textContent = "アイテム";
    listDiv.appendChild(itemTitle);

    items.forEach((ent, index) => {
      const odd = (index % 2 === 1);
      const row = createEntityRow(ent, odd);
      listDiv.appendChild(row);
    });
  }

  if (chars.length > 0) {
    const charTitle = document.createElement("h3");
    charTitle.textContent = "キャラクター";
    listDiv.appendChild(charTitle);

    chars.forEach((ent, index) => {
      const odd = (index % 2 === 1);
      const row = createEntityRow(ent, odd);
      listDiv.appendChild(row);
    });
  }

  if (items.length === 0 && chars.length === 0) {
    listDiv.textContent = "アイテムや登場人物はありません。";
  }
};

function createEntityRow(entity, isOdd) {
  const row = document.createElement("div");
  row.className = "info-row";
  row.style.marginBottom = "20px";

  const topWrapper = document.createElement("div");
  topWrapper.style.justifyContent = "space-between";
  topWrapper.style.alignItems = "center";
  topWrapper.style.overflow = "hidden";

  if (entity.imageData) {
    const thumb = document.createElement("img");
    thumb.src = entity.imageData;
    thumb.alt = entity.name;
    thumb.style.height = "150px";
    thumb.style.objectFit = "contain";
    if (isOdd) {
      thumb.style.float = "left";
      thumb.style.paddingRight = "20px";
    } else {
      thumb.style.float = "right";
      thumb.style.paddingLeft = "20px";
    }
    thumb.style.borderRadius = "50%";
    thumb.style.shapeOutside = "circle(50%)";
    topWrapper.appendChild(thumb);
  }

  const infoSpan = document.createElement("span");
  // アイテムかつ acquired=true の場合は名前に【使用可能】を付加
  let displayName = entity.name;
  if (entity.category === "item" && entity.acquired) {
    displayName += "【使用可能】";
  }

  infoSpan.innerHTML = `<h4>${displayName}</h4> ${entity.description}`;

  topWrapper.appendChild(infoSpan);

  row.appendChild(topWrapper);

  // 下段： Wandボタン + ドロップダウン
  const bottomWrapper = document.createElement("div");
  bottomWrapper.className = "l-flexbox";

  const wandBtn = document.createElement("button");
  wandBtn.className = "scene-menu-button";
  wandBtn.innerHTML = '<div class="iconmoon icon-dots-three-horizontal"></div>';
  bottomWrapper.appendChild(wandBtn);

  const dropdown = document.createElement("div");
  dropdown.className = "scene-dropdown-menu";
  dropdown.style.display = "none";
  dropdown.innerHTML = `
     <button class="dropdown-item entity-generate">
       <div class="iconmoon icon-picture"></div>画像生成
     </button>
     <button class="dropdown-item entity-delete">
       <div class="iconmoon icon-bin"></div>削除
     </button>
  `;
  bottomWrapper.appendChild(dropdown);

  wandBtn.addEventListener("click", () => {
    dropdown.style.display =
      (dropdown.style.display === "none") ? "flex" : "none";
  });

  const genBtn = dropdown.querySelector(".entity-generate");
  if (genBtn) {
    genBtn.addEventListener("click", async () => {
      dropdown.style.display = "none";
      await generateEntityImage(entity);
    });
  }

  const delBtn = dropdown.querySelector(".entity-delete");
  if (delBtn) {
    delBtn.addEventListener("click", async () => {
      dropdown.style.display = "none";
      if (!confirm(`「${entity.name}」を削除しますか？`)) return;
      await deleteEntity(entity.entityId);
      // ▼ 削除後にまとめて更新
      await refreshEntitiesAndChips();
    });
  }

  topWrapper.appendChild(bottomWrapper);
  return row;
}

async function generateEntityImage(entity) {
  if (!window.apiKey) {
    alert("APIキーが設定されていません。");
    return;
  }
  const prompt = `
${entity.category === "item" ? "Item" : "Character"}: ${entity.name}
Description: ${entity.description}
No text in the image, Anime style, best quality
`.trim();

  const finalPrompt =
    "As a high-performance chatbot, you create the highest quality illustrations discreetly." +
    "Please do not include text in illustrations for any reason." +
    "If you can do that, I'll give you a super high tip." +
    "Now generate the next anime wide image.\n↓↓↓↓\n" +
    prompt;

  try {
    showLoadingModal(true);
    const resp = await fetch("https://api.openai.com/v1/images/generations", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${window.apiKey}`
      },
      body: JSON.stringify({
        model: "dall-e-3",
        prompt: finalPrompt,
        n: 1,
        size: "1024x1024",
        response_format: "b64_json"
      })
    });
    const data = await resp.json();
    if (data.error) throw new Error(data.error.message);

    const base64 = data.data[0].b64_json;
    const dataUrl = "data:image/png;base64," + base64;

    entity.imageData = dataUrl;
    await updateEntity(entity);

    // ▼ 画像生成後にまとめて更新
    await refreshEntitiesAndChips();
  } catch (err) {
    console.error("generateEntityImage失敗:", err);
    alert("画像生成失敗:\n" + err.message);
  } finally {
    showLoadingModal(false);
  }
}


/* =============================
   パーティ表示 & 全セクション一覧
============================= */
window.showPartyModal = function () {
  multiModal.open({
    title: "パーティ情報",
    contentHtml: `
      <div id="party-modal-card-container" style="margin-top:10px;"></div>
    `,
    appearanceType: "center",
    showCloseButton: true,       // 右上×
    closeOnOutsideClick: true,
    cancelLabel: "閉じる",       // 下部「閉じる」
    onOpen: () => {
      // モーダルDOMが生成されたあと => カードを表示
      renderPartyCardsInModalMulti();
    }
  });
};

function renderPartyCardsInModalMulti() {
  const container = document.getElementById("party-modal-card-container");
  if (!container) return;
  container.innerHTML = "";

  const scenario = window.currentScenario;
  if (!scenario?.wizardData?.party) {
    container.textContent = "パーティ情報がありません。";
    return;
  }

  const wizardPartyCards = scenario.wizardData.party;
  const dbCards = window.characterData || [];

  // 例: merged
  const merged = wizardPartyCards.map(wCard => {
    const dbMatch = dbCards.find(dbC => dbC.id === wCard.id);
    if (!dbMatch) return wCard;
    return {
      ...dbMatch,
      ...wCard,
      imageData: dbMatch.imageData || wCard.imageData
    };
  });

  merged.forEach(card => {
    const cardEl = createPartyCardElement(card); // 元のまま
    container.appendChild(cardEl);
  });
}


function createPartyCardElement(c) {
  const cardEl = document.createElement("div");
  cardEl.className = "card ";
  const rarityNum = (c.rarity || "★0").replace("★", "").trim();
  cardEl.className += "rarity" + rarityNum;

  cardEl.setAttribute("data-id", c.id);
  cardEl.addEventListener("click", () => {
    cardEl.classList.toggle("flipped");
  });

  const cardInner = document.createElement("div");
  cardInner.className = "card-inner";

  const cf = document.createElement("div");
  cf.className = "card-front";

  const bezel = document.createElement("div");
  bezel.className = "bezel rarity" + rarityNum;
  cf.appendChild(bezel);

  let roleLabel = "";
  if (c.role === "avatar") roleLabel = "(アバター)";
  else if (c.role === "partner") roleLabel = "(パートナー)";

  const tEl = document.createElement("div");
  tEl.className = "card-type";
  tEl.textContent = (c.type || "不明") + roleLabel;
  cf.appendChild(tEl);

  const imgCont = document.createElement("div");
  imgCont.className = "card-image";
  if (c.imageData) {
    const im = document.createElement("img");
    im.src = c.imageData;
    im.alt = c.name;
    imgCont.appendChild(im);
  }
  cf.appendChild(imgCont);

  const info = document.createElement("div");
  info.className = "card-info";

  const nm = document.createElement("p");
  nm.innerHTML = `<h3>${c.name}</h3>`;
  info.appendChild(nm);

  if (c.state) {
    const st = document.createElement("p");
    st.innerHTML = `<strong>状態：</strong>${c.state}`;
    info.appendChild(st);
  }
  const sp = document.createElement("p");
  sp.innerHTML = `<strong>特技：</strong>${c.special}`;
  info.appendChild(sp);

  const cap = document.createElement("p");
  cap.innerHTML = `<span>${c.caption || "なし"}</span>`;
  info.appendChild(cap);

  cf.appendChild(info);

  const cb = document.createElement("div");
  cb.className = "card-back";
  cb.innerHTML = `<strong>${c.type}</strong>`;

  cardInner.appendChild(cf);
  cardInner.appendChild(cb);
  cardEl.appendChild(cardInner);
  return cardEl;
}

/** 全セクション閲覧 */
window.showAllSectionsModal = function () {
  const modal = document.getElementById("all-sections-modal");
  if (!modal) return;

  const wd = (window.currentScenario && window.currentScenario.wizardData) || {};
  const sections = wd.sections || [];

  const container = document.getElementById("all-sections-content");
  container.textContent = "";

  if (!sections.length) {
    container.textContent = "セクション情報がありません。";
  } else {
    let text = "";
    for (const sec of sections) {
      text += `【セクション${sec.number}】` + (sec.cleared ? "(クリア済み)" : "(未クリア)") + "\n";
      text += "条件: " + decompressCondition(sec.conditionZipped) + "\n\n";
    }
    container.textContent = text;
  }
  modal.classList.add("active");
};

/** パーティ情報文章化（sceneManagerで利用） */
window.buildPartyInsertionText = function (party) {
  let txt = "【パーティ編成情報】\n";

  const ava = party.find(e => e.role === "avatar");
  if (ava) {
    txt += "◆プレイヤー(アバター)\n";
    txt += buildCardDescription(ava);
    txt += "\n";
  }
  const pt = party.filter(e => e.role === "partner");
  if (pt.length > 0) {
    txt += "◆パートナー\n";
    pt.forEach(p => {
      txt += buildCardDescription(p);
      txt += "\n";
    });
  }
  const others = party.filter(e => !e.role || e.role === "none");
  if (others.length > 0) {
    const cset = others.filter(x => x.type === "キャラクター");
    const mset = others.filter(x => x.type === "モンスター");
    const iset = others.filter(x => x.type === "アイテム");

    if (cset.length > 0) {
      txt += "◆キャラクター\n";
      cset.forEach(c => {
        txt += buildCardDescription(c);
        txt += "\n";
      });
    }
    if (mset.length > 0) {
      txt += "◆モンスター\n";
      mset.forEach(m => {
        txt += buildCardDescription(m);
        txt += "\n";
      });
    }
    if (iset.length > 0) {
      txt += "◆アイテム\n";
      iset.forEach(i => {
        txt += buildCardDescription(i);
        txt += "\n";
      });
    }
  }

  txt +=
    "以上を踏まえて、プレイヤー、パートナーは味方NPC、アイテムは登場するアイテム、" +
    "キャラクターは中立NPC、モンスターは敵対NPCとして扱ってください。" +
    "シナリオ概要を優先するため、世界観が合わない場合は調整してもよいです。";
  return txt;
};

function buildCardDescription(card) {
  let result = "";
  result += ` - 【名前】${card.name}\n`;
  result += `   【レア度】${card.rarity || "★0"}\n`;
  if (card.type === "キャラクター" || card.type === "モンスター") {
    result += `   【状態】${card.state || "なし"}\n`;
  }
  result += `   【特技】${card.special || "なし"}\n`;
  result += `   【キャプション】${card.caption || "なし"}\n`;
  result += `   【外見】${card.imageprompt || "なし"}\n`;
  return result;
}

---
sceneUI.js
/********************************
 * sceneUI.js
 * UI関連のイベント・表示更新など
 ********************************/

window.addEventListener("DOMContentLoaded", () => {
  // 初期化：カルーセルのセルクローンのID削除
  setTimeout(() => {
    initCarousel();
    removeDuplicateIDs();
  }, 500);

  // --------------------------------------------------
  // ▼ アプリケーションバーに各種ボタンを動的追加
  // --------------------------------------------------
  const applicationBar = document.querySelector(".application-bar");

  // セーブボタンを基本として左に追加していく
  const baseButton = document.getElementById("save-load-button");
  if (applicationBar && baseButton) {
    // 履歴ボタン
    const historyBtn = document.createElement("button");
    historyBtn.id = "toggle-history-button";
    historyBtn.innerHTML = '<div class="iconmoon icon-newspaper"></div>履歴';
    applicationBar.insertBefore(historyBtn, baseButton);
    historyBtn.addEventListener("click", toggleHistory);

    // PTボタン
    const partyButton = document.createElement("button");
    partyButton.id = "show-party-button";
    partyButton.innerHTML = '<div class="iconmoon icon-strategy"></div>PT';
    applicationBar.insertBefore(partyButton, baseButton);
    partyButton.addEventListener("click", showPartyModal);

    // 情報ボタン (アイテム/人物一覧)
    const infoButton = document.createElement("button");
    infoButton.id = "info-button";
    infoButton.innerHTML = '<div class="iconmoon icon-info"></div>情報';
    applicationBar.insertBefore(infoButton, baseButton);
    infoButton.addEventListener("click", openEntitiesModal); // sceneExtras.js
  }

  // --------------------------------------------------
  // ▼ トークン調整ボタン関連 (multiModal化)
  // --------------------------------------------------
  const tokenAdjustBtn = document.getElementById("token-adjust-button");
  if (tokenAdjustBtn) {
    tokenAdjustBtn.addEventListener("click", onOpenTokenAdjustModal);
  }

  // tokenAdjustOk / tokenAdjustCancel ボタンは不要になったので削除

  function onOpenTokenAdjustModal() {
    let missingCount = window.scenes.filter(sc => !sc.content_en).length;
    const msg = `${missingCount}件のシーン/アクションに内部英語データがありません。生成しますか？`;

    // multiModalで開く
    multiModal.open({
      title: "トークン調整",
      // contentHtmlに「進行状況」を表示する <p>を用意
      contentHtml: `
      <p id="token-adjust-message" style="margin-bottom:1em;">${DOMPurify.sanitize(msg)}</p>
      <p id="token-adjust-progress" style="min-height:1.5em;"></p>
    `,
      showCloseButton: true,
      closeOnOutsideClick: true,
      appearanceType: "center",
      // キャンセル/OKボタン
      cancelLabel: "キャンセル",
      okLabel: "OK",
      onOk: async () => {
        await onConfirmTokenAdjust();
        // モーダルはonOk後に自動close
      }
    });
  }

  async function onConfirmTokenAdjust() {
    const progressEl = document.getElementById("token-adjust-progress");

    let targets = window.scenes.filter(sc => !sc.content_en || !sc.content_en.trim());
    if (!window.apiKey) {
      alert("APIキー未設定");
      return;
    }
    if (targets.length === 0) {
      alert("不足はありません。");
      return; // ここでモーダルは自然に閉じる
    }

    let doneCount = 0;
    const total = targets.length;
    for (const sceneObj of targets) {
      doneCount++;
      if (progressEl) {
        progressEl.textContent = `${doneCount}/${total}件処理中...`;
      }
      const tr = await generateEnglishTranslation(sceneObj.content);
      sceneObj.content_en = tr;

      // DB更新
      const allEntries = await getSceneEntriesByScenarioId(sceneObj.scenarioId);
      const sceneRec = allEntries.find(e => e.type === "scene" && e.sceneId === sceneObj.sceneId);
      if (sceneRec) {
        sceneRec.content_en = tr;
        await updateSceneEntry(sceneRec);
      }
    }
    if (progressEl) {
      progressEl.textContent = `${total}/${total}件完了`;
    }
    alert("英語データ生成が完了しました。");
  }

  // --------------------------------------------------
  // ▼ セーブ/ロードモーダルのセーブボタン
  // --------------------------------------------------
  const doSaveButton = document.getElementById("do-save-button");
  if (doSaveButton) {
    doSaveButton.style.display = "block";
  }
  // --------------------------------------------------
  // ▼ ネタバレボタン (multiModal化)
  // --------------------------------------------------
  const spoilerButton = document.getElementById("spoiler-button");
  if (spoilerButton) {
    spoilerButton.addEventListener("click", () => {
      multiModal.open({
        title: "ネタバレ注意",
        contentHtml: `<p id="clear-condition-text" style="white-space:pre-wrap;"></p>`,
        showCloseButton: true,
        closeOnOutsideClick: true,
        appearanceType: "center",
        // 下部に閉じるボタンを出したければ:
        cancelLabel: "閉じる"
        // → これで右下に「閉じる」ボタンが表示される
      });
    });
  }

  // 「カードを取得する」ボタン (multiModal化)
  const getCardButton = document.getElementById("get-card-button");
  if (getCardButton) {
    getCardButton.addEventListener("click", async () => {
      // ここで summary などを取得
      const summary = await getLastSceneSummary();
      if (!summary) {
        alert("最新シーンがありません");
        return;
      }

      // multiModal でモーダルを開く
      multiModal.open({
        title: "カードプレビュー",
        // contentHtmlにプレビュー内容を組み立て
        contentHtml: `
        <div id="preview-card-container">
          <p style="white-space:pre-wrap;">${DOMPurify.sanitize(summary)}</p>
        </div>
      `,
        showCloseButton: true,    // 右上×で閉じる
        closeOnOutsideClick: true,
        appearanceType: "center",
        // ボタン
        cancelLabel: "キャンセル",
        okLabel: "倉庫に追加",
        onOk: async () => {
          // 「倉庫に追加」処理
          alert("ガチャ箱に追加しました。（仮）");
        }
        // onCancel も必要なら書く
      });
    });
  }

  // --------------------------------------------------
  // ▼ 回答候補のチェックボックス
  // --------------------------------------------------
  const autoGenCbx = document.getElementById("auto-generate-candidates-checkbox");
  if (autoGenCbx) {
    autoGenCbx.addEventListener("change", () => {
      if (autoGenCbx.checked) {
        onGenerateActionCandidates();
      }
    });
  }

  // --------------------------------------------------
  // ▼ アイテム使用ボタン
  // --------------------------------------------------
  const useItemBtn = document.getElementById("use-item-button");
  if (useItemBtn) {
    useItemBtn.addEventListener("click", () => {
      getNextScene(true); // sceneManager.js
    });
  }

  // ▼ 全セクション閲覧ボタン (multiModal化)
  const viewAllSectionsBtn = document.getElementById("view-all-sections-button");
  if (viewAllSectionsBtn) {
    viewAllSectionsBtn.addEventListener("click", showAllSectionsModal);
  }
  function showAllSectionsModal() {
    // ここで scenario.wizardData.sections などから一覧を作る
    multiModal.open({
      title: "全セクション一覧",
      contentHtml: `
        <div id="all-sections-container" style="max-height:60vh; overflow:auto;"></div>
      `,
      showCloseButton: true,
      appearanceType: "center",
      closeOnOutsideClick: true,
      cancelLabel: "閉じる",
      onOpen: () => {
        renderAllSections();
      }
    });
  }

  function renderAllSections() {
    const container = document.getElementById("all-sections-container");
    if (!container) return;
    container.innerHTML = "";

    // 例えば
    const wd = window.currentScenario?.wizardData;
    if (!wd || !wd.sections) {
      container.textContent = "セクション情報がありません。";
      return;
    }
    const sorted = [...wd.sections].sort((a, b) => a.number - b.number);
    sorted.forEach(sec => {
      const p = document.createElement("p");
      const clearedText = sec.cleared ? "【済】" : "【未】";
      p.textContent = `${sec.number} : ${clearedText} ${decompressCondition(sec.conditionZipped)}`;
      container.appendChild(p);
    });
  }

  // --------------------------------------------------
  // ▼ エンディングボタン (type='bad', 'clear')
  // --------------------------------------------------
  const endingBtn = document.getElementById("ending-button");
  if (endingBtn) {
    endingBtn.addEventListener("click", () => {
      showEndingModal("bad"); // sceneExtras.js
    });
  }
  const clearEndingBtn = document.getElementById("clear-ending-button");
  if (clearEndingBtn) {
    clearEndingBtn.addEventListener("click", () => {
      showEndingModal("clear");
    });
  }

  // エンディングモーダルのボタン
  const endingModalClose = document.getElementById("ending-modal-close-button");
  if (endingModalClose) {
    endingModalClose.addEventListener("click", () => {
      const m = document.getElementById("ending-modal");
      if (m) m.classList.remove("active");
    });
  }
  const endingModalRegen = document.getElementById("ending-modal-regenerate-button");
  if (endingModalRegen) {
    endingModalRegen.addEventListener("click", onClickRegenerateEnding); // sceneExtras.js
  }

  // --------------------------------------------------
  // ▼ メニューに戻るボタン
  // --------------------------------------------------
  const backMenuBtn = document.getElementById("back-to-menu");
  if (backMenuBtn) {
    backMenuBtn.addEventListener("click", () => {
      window.location.href = "index.html";
    });
  }

  // ▼ 情報ボタン (multiModal化)
  const infoButton = document.getElementById("info-button");
  if (infoButton) {
    infoButton.addEventListener("click", openEntitiesModal);
  }

  // 既存の info-close-button, info-modal は削除し、HTMLから <div id="info-modal"> も削除

  function openEntitiesModal() {
    // 「情報モーダル」を multiModal で開く
    multiModal.open({
      title: "情報",
      contentHtml: `
      <div style="margin-bottom:10px;">
        <button id="entity-update-button">シナリオから取得</button>
      </div>
      <div id="entity-candidate-list" style="margin-bottom:20px; padding:5px;"></div>
      <div id="entity-list-container" style="margin-bottom:20px; padding:5px;"></div>
    `,
      showCloseButton: true,       // 右上×で閉じる
      closeOnOutsideClick: true,   // モーダル外クリックでも閉じる
      cancelLabel: "閉じる",       // 下部に「閉じる」ボタン
      appearanceType: "center",
      // モーダルが開いた後にDOMが生成されるので onOpen でイベントなど付与
      onOpen: () => {
        renderEntitiesList();
        // 「シナリオから取得」ボタン
        const entityUpdateBtn = document.getElementById("entity-update-button");
        if (entityUpdateBtn) {
          entityUpdateBtn.addEventListener("click", onUpdateEntitiesFromAllScenes);
        }

        // 必要なら、候補一覧や既存一覧の描画
        // 例: 
        //   document.getElementById("entity-candidate-list").textContent = "候補なし";
        //   document.getElementById("entity-list-container").textContent = "エンティティ一覧";
      }
    });
  }

});


/* ===========================================================
   シーン履歴表示、最新シーン表示など UI更新系関数
=========================================================== */
/** 履歴表示を更新 */
window.updateSceneHistory = function () {
  const his = document.getElementById("scene-history");
  if (!his) return;
  his.innerHTML = "";

  // シナリオ/セクション情報
  const wd = window.currentScenario?.wizardData;
  let sections = [];
  if (wd && wd.sections) {
    sections = wd.sections;
  }
  const sorted = [...sections].sort((a, b) => a.number - b.number);
  const firstUncleared = sorted.find(s => !s.cleared);

  if (!firstUncleared && sorted.length > 0) {
    // 全部クリア済み
    const tile = document.createElement("div");
    tile.className = "history-tile summary title";
    tile.textContent = "シナリオ達成!";
    his.appendChild(tile);
  }

  for (const s of sorted) {
    const t = document.createElement("div");
    if (s.number < (firstUncleared?.number || Infinity)) {
      t.className = "history-tile summary";
      t.textContent = `${decompressCondition(s.conditionZipped)}(クリア済み)`;
    } else if (s.number === firstUncleared?.number) {
      t.className = "history-tile summary";
      t.textContent = `セクション${s.number} (未クリア)`;
    }
    his.appendChild(t);
  }
  let tile = document.createElement("div");
  tile.className = "history-tile summary separator";
  his.appendChild(tile);

  // シナリオ概要
  const scenarioSummaryEl = document.createElement("div");
  scenarioSummaryEl.id = "scenario-summary";
  scenarioSummaryEl.innerHTML = wd?.scenarioSummary || "";
  his.appendChild(scenarioSummaryEl);

  // 全シーンの描画 (最後の1件は下で別表示)
  const lastScene = [...window.scenes].slice(-1)[0] || null;
  const skipId = lastScene ? lastScene.sceneId : null;
  const toShow = window.scenes.filter(sc => sc.sceneId !== skipId);

  for (const scn of toShow) {
    const tile = document.createElement("div");
    tile.className = "history-tile";

    // アクション
    if (scn.action?.content) {
      const at = document.createElement("p");
      at.className = "action-text";
      at.setAttribute("contenteditable", window.apiKey ? "true" : "false");
      at.innerHTML = DOMPurify.sanitize(scn.action.content, DOMPURIFY_CONFIG);
      at.addEventListener("blur", async () => {
        await onSceneOrActionContentEdited(scn, at.innerHTML.trim(), true);
      });
      tile.appendChild(at);
    }

    // シーン本文
    const st = document.createElement("p");
    st.className = "scene-text";
    st.setAttribute("contenteditable", window.apiKey ? "true" : "false");
    st.innerHTML = DOMPurify.sanitize(scn.content, DOMPURIFY_CONFIG);
    st.addEventListener("blur", async () => {
      await onSceneOrActionContentEdited(scn, st.innerHTML.trim(), false);
    });
    tile.appendChild(st);

    // 画像一覧
    const scImages = scn.images || [];
    scImages.forEach((imgRec, index) => {
      const img = document.createElement("img");
      img.src = imgRec.dataUrl;
      img.alt = "生成画像";
      img.style.maxHeight = "350px";
      img.style.width = "100%";
      img.style.objectFit = "contain";

      img.addEventListener("click", () => {
        openImageViewer(scn, index);
      });
      tile.appendChild(img);
    });

    // シーン操作ドロップダウン
    const c = document.createElement("div");
    const dropdown = document.createElement("div");
    dropdown.className = "scene-dropdown-menu";
    dropdown.style.display = "none";
    dropdown.innerHTML = `
      <button class="dropdown-item scene-delete">
        <div class="iconmoon icon-bin"></div>シーンを削除
      </button>
      <button class="dropdown-item scene-illustration">
        <div class="iconmoon icon-picture"></div>挿絵を生成
      </button>
    `;
    c.appendChild(dropdown);

    c.className = "r-flexbox";
    const wandBtn = document.createElement("button");
    wandBtn.className = "scene-menu-button";
    wandBtn.innerHTML = '<div class="iconmoon icon-dots-three-horizontal"></div>';
    c.appendChild(wandBtn);

    wandBtn.addEventListener("click", () => {
      dropdown.style.display = (dropdown.style.display === "none") ? "flex" : "none";
    });

    const delBtn = dropdown.querySelector(".scene-delete");
    if (delBtn) {
      delBtn.addEventListener("click", async () => {
        dropdown.style.display = "none";
        await deleteScene(scn);
      });
    }
    const illustBtn = dropdown.querySelector(".scene-illustration");
    if (illustBtn) {
      illustBtn.addEventListener("click", async () => {
        dropdown.style.display = "none";
        await generateImageForScene(scn);
      });
    }

    tile.appendChild(c);
    his.appendChild(tile);
  }
  his.scrollTop = his.scrollHeight;
};

/** 最新シーン表示 */
window.showLastScene = function () {
  const storyDiv = document.getElementById("story");
  const lastSceneImagesDiv = document.getElementById("last-scene-images");
  const lastSceneAdded = document.getElementById("last-scene-added");

  if (!storyDiv || !lastSceneImagesDiv) return;

  const nextSceneBtn = document.getElementById("next-scene");
  const playerInput = document.getElementById("player-input");
  const playerActionLabel = document.getElementById("player-action");

  const lastScene = [...window.scenes].slice(-1)[0] || null;
  if (lastScene) {
    storyDiv.innerHTML = "";
    lastSceneAdded.innerHTML = "";

    // プレイヤーアクション
    if (lastScene.action?.content) {
      const at = document.createElement("p");
      at.className = "action-text";
      at.setAttribute("contenteditable", window.apiKey ? "true" : "false");
      at.innerHTML = DOMPurify.sanitize(lastScene.action.content, DOMPURIFY_CONFIG);
      at.addEventListener("blur", async () => {
        await onSceneOrActionContentEdited(lastScene, at.innerHTML.trim(), true);
      });
      storyDiv.appendChild(at);
    }

    // シーン本文
    const st = document.createElement("p");
    st.className = "scene-text";
    st.setAttribute("contenteditable", window.apiKey ? "true" : "false");
    st.innerHTML = DOMPurify.sanitize(lastScene.content, DOMPURIFY_CONFIG);
    st.addEventListener("blur", async () => {
      await onSceneOrActionContentEdited(lastScene, st.innerHTML.trim(), false);
    });
    storyDiv.appendChild(st);

    // ドロップダウン
    const dropdown = document.createElement("div");
    dropdown.className = "scene-dropdown-menu";
    dropdown.style.display = "none";
    dropdown.innerHTML = `
      <button class="dropdown-item last-scene-delete">
        <div class="iconmoon icon-bin"></div>シーンを削除
      </button>
      <button class="dropdown-item last-scene-illustration">
        <div class="iconmoon icon-picture"></div>挿絵を生成
      </button>
    `;
    lastSceneAdded.appendChild(dropdown);

    const wandBtn = document.createElement("button");
    wandBtn.className = "scene-menu-button";
    wandBtn.innerHTML = '<div class="iconmoon icon-dots-three-horizontal"></div>';
    lastSceneAdded.appendChild(wandBtn);

    wandBtn.addEventListener("click", () => {
      dropdown.style.display = (dropdown.style.display === "none") ? "block" : "none";
    });

    const delItem = dropdown.querySelector(".last-scene-delete");
    if (delItem) {
      delItem.addEventListener("click", async () => {
        dropdown.style.display = "none";
        await deleteScene(lastScene);
      });
    }
    const illustItem = dropdown.querySelector(".last-scene-illustration");
    if (illustItem) {
      illustItem.addEventListener("click", async () => {
        dropdown.style.display = "none";
        await generateImageForScene(lastScene);
      });
    }

    // 画像一覧
    lastSceneImagesDiv.innerHTML = "";
    lastScene.images.forEach((imgObj, index) => {
      const div = document.createElement("div");
      div.className = "image-container";

      const imgEl = document.createElement("img");
      imgEl.src = imgObj.dataUrl;
      imgEl.alt = "生成画像";
      imgEl.style.maxHeight = "50vh";
      imgEl.style.objectFit = "contain";
      imgEl.addEventListener("click", () => {
        openImageViewer(lastScene, index);
      });

      div.appendChild(imgEl);
      lastSceneImagesDiv.appendChild(div);
    });

    if (window.apiKey) {
      nextSceneBtn.style.display = "inline-block";
      playerInput.style.display = "inline-block";
      playerActionLabel.textContent = "プレイヤーの行動を入力してください";
    } else {
      nextSceneBtn.style.display = "none";
      playerInput.style.display = "none";
      playerActionLabel.textContent = "";
    }
  } else {
    // シーンが無い場合（導入前）
    storyDiv.innerHTML = "";
    lastSceneImagesDiv.innerHTML = "";
    if (window.apiKey) {
      nextSceneBtn.style.display = "inline-block";
      playerInput.style.display = "none";
      playerActionLabel.textContent = "最初のシーン(導入)を作成します。";
    } else {
      nextSceneBtn.style.display = "none";
      playerInput.style.display = "none";
      playerActionLabel.textContent = "";
    }
  }
};


/* ===========================================================
   シーンテキスト編集、履歴トグル、アイテムchips表示 など
=========================================================== */
/** シーンorアクションのテキストを編集 */
window.onSceneOrActionContentEdited = async function (sceneObj, newText, isActionEdit) {
  if (!window.apiKey) return;
  const oldText = isActionEdit ? sceneObj.action.content : sceneObj.content;
  if (newText.trim() === oldText.trim()) {
    return;
  }
  showLoadingModal(true);
  try {
    // 英訳
    const en = await generateEnglishTranslation(newText);
    if (isActionEdit) {
      sceneObj.action.content = newText;
      sceneObj.action.content_en = en;
    } else {
      sceneObj.content = newText;
      sceneObj.content_en = en;
    }
    // DB更新
    const allEntries = await getSceneEntriesByScenarioId(sceneObj.scenarioId);
    const sceneRec = allEntries.find(e => e.type === "scene" && e.sceneId === sceneObj.sceneId);
    if (sceneRec) {
      sceneRec.content = sceneObj.content;
      sceneRec.content_en = sceneObj.content_en;
      sceneRec.actionContent = sceneObj.action.content;
      sceneRec.actionContent_en = sceneObj.action.content_en;
      await updateSceneEntry(sceneRec);
    }
  } catch (err) {
    console.error("再翻訳失敗:", err);
  } finally {
    showLoadingModal(false);
  }
};

/** 履歴表示のトグル */
window.toggleHistory = async function () {
  if (!window.currentScenario) return;
  const hist = document.getElementById("scene-history");
  if (!hist) return;

  window.currentScenario.showHistory = !window.currentScenario.showHistory;
  hist.style.display = window.currentScenario.showHistory ? 'block' : 'none';

  await updateScenario(window.currentScenario);
};

/** アイテムチップスを表示 */
window.renderItemChips = async function () {
  const container = document.getElementById("item-chips-container");
  if (!container) return;
  container.innerHTML = "";

  if (!window.currentScenario) return;
  const scenarioId = window.currentScenarioId;
  if (!scenarioId) return;

  // DB側アイテム
  const ents = await getEntitiesByScenarioId(scenarioId);
  const acquiredItems = ents.filter(e => e.category === "item" && e.acquired);

  // wizardDataのパーティアイテム
  const pArr = window.currentScenario?.wizardData?.party || [];
  const partyItems = pArr.filter(c => c.type === "アイテム");

  const result = [];
  const addedNames = new Set();

  // 1) パーティアイテム
  for (const it of partyItems) {
    const nm = it.name || "無名アイテム";
    if (addedNames.has(nm)) continue;
    addedNames.add(nm);

    result.push({
      name: nm,
      description: it.caption || "(説明不明)",
      imageData: it.imageData || ""
    });
  }
  // 2) DB取得アイテム
  for (const it of acquiredItems) {
    const nm = it.name || "無名アイテム";
    if (addedNames.has(nm)) continue;
    addedNames.add(nm);

    result.push({
      name: nm,
      description: it.description || "(説明不明)",
      imageData: it.imageData || ""
    });
  }

  if (result.length === 0) {
    container.textContent = "使用可能なアイテムはありません。";
    return;
  }

  let currentSelectedChip = null;
  result.forEach(item => {
    const chip = document.createElement("div");
    chip.className = "chip chip-withimage";
    // 画像表示
    if (item.imageData) {
      const im = document.createElement("img");
      im.src = item.imageData;
      im.alt = item.name;
      chip.appendChild(im);
    }
    // 名前
    const lbl = document.createElement("span");
    lbl.textContent = item.name;
    chip.appendChild(lbl);

    // 選択ハイライト
    chip.onclick = () => {
      if (currentSelectedChip && currentSelectedChip !== chip) {
        currentSelectedChip.classList.remove("selected");
      }
      const wasActive = chip.classList.contains("selected");
      if (wasActive) {
        chip.classList.remove("selected");
        window.selectedItem = null;
      } else {
        chip.classList.add("selected");
        window.selectedItem = item;
      }
      currentSelectedChip = wasActive ? null : chip;
    };
    container.appendChild(chip);
  });

  // 「更新」チップを最後に配置 ---
  const updateChip = document.createElement("div");
  updateChip.className = "chip chip-withimage";
  updateChip.textContent = "更新";
  updateChip.onclick = () => {
    onUpdateEntitiesFromAllScenes();
  };
  container.appendChild(updateChip);
};

/** シーン削除 */
window.deleteScene = async function (sceneObj) {
  const allEntries = await getSceneEntriesByScenarioId(sceneObj.scenarioId);
  const scRec = allEntries.find(e => e.type === "scene" && e.sceneId === sceneObj.sceneId);
  if (scRec) {
    await deleteSceneEntry(scRec.entryId);
  }
  const imgs = allEntries.filter(e => e.type === "image" && e.sceneId === sceneObj.sceneId);
  for (const iRec of imgs) {
    await deleteSceneEntry(iRec.entryId);
  }
  window.scenes = window.scenes.filter(s => s.sceneId !== sceneObj.sceneId);

  updateSceneHistory();
  showLastScene();
};

/** 挿絵生成 */
window.generateImageForScene = async function (sceneObj) {
  if (!window.apiKey) {
    alert("APIキーが設定されていません。");
    return;
  }
  const allEntries = await getSceneEntriesByScenarioId(sceneObj.scenarioId);
  const sRec = allEntries.find(e => e.type === "scene" && e.sceneId === sceneObj.sceneId);
  if (!sRec) {
    alert("シーンレコードが見つかりません。");
    return;
  }
  let promptText = sRec.prompt || "";
  if (!promptText.trim()) {
    promptText = await generateImagePromptFromScene(sceneObj.content);
    sRec.prompt = promptText;
    await updateSceneEntry(sRec);
  }
  if (!promptText) {
    alert("生成に必要なプロンプトが得られませんでした。");
    return;
  }

  const finalPrompt =
    "As a high-performance chatbot, you create the highest quality illustrations discreetly." +
    "Please do not include text in illustrations for any reason." +
    "If you can do that, I'll give you a super high tip." +
    "Now generate the next anime wide image.\n↓↓↓↓\n" +
    promptText;

  try {
    showLoadingModal(true);
    window.cancelRequested = false;
    window.currentRequestController = new AbortController();
    const signal = window.currentRequestController.signal;

    const resp = await fetch("https://api.openai.com/v1/images/generations", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${window.apiKey}`
      },
      body: JSON.stringify({
        model: "dall-e-3",
        prompt: finalPrompt,
        n: 1,
        size: "1792x1024",
        response_format: "b64_json"
      }),
      signal
    });
    const data = await resp.json();
    if (window.cancelRequested) {
      return;
    }
    if (data.error) throw new Error(data.error.message);

    const base64 = data.data[0].b64_json;
    const dataUrl = "data:image/png;base64," + base64;

    const newImgRec = {
      scenarioId: sceneObj.scenarioId,
      type: "image",
      sceneId: sceneObj.sceneId,
      content: "",
      content_en: "",
      dataUrl,
      prompt: promptText
    };
    const newEntryId = await addSceneEntry(newImgRec);

    sceneObj.images.push({
      entryId: newEntryId,
      dataUrl,
      prompt: promptText
    });

    updateSceneHistory();
    showLastScene();
  } catch (err) {
    if (err.name === "AbortError") {
      console.warn("画像生成キャンセル");
    } else {
      console.error("画像生成失敗:", err);
      alert("画像生成に失敗:\n" + err.message);
    }
  } finally {
    showLoadingModal(false);
  }
};


/* ===========================================================
   回答候補生成、トークン調整、カスタム画像生成モーダル 等
=========================================================== */
/** 回答候補を生成 */
window.onGenerateActionCandidates = async function () {
  if (!window.apiKey) {
    alert("APIキー未設定");
    return;
  }
  const lastScene = [...window.scenes].slice(-1)[0];
  if (!lastScene) {
    alert("まだ導入シーンがありません。");
    return;
  }
  const lastSceneText = lastScene.content || "(シーン無し)";

  const wd = window.currentScenario?.wizardData;
  let conditionText = "";
  if (wd && wd.sections && wd.sections.length > 0) {
    const sorted = wd.sections.slice().sort((a, b) => a.number - b.number);
    const firstUncleared = sorted.find(sec => !sec.cleared);
    if (firstUncleared) {
      conditionText = decompressCondition(firstUncleared.conditionZipped);
    }
  }

  window.cancelRequested = false;
  showLoadingModal(true);

  try {
    window.currentRequestController = new AbortController();
    const signal = window.currentRequestController.signal;

    const prompt = `
あなたはTRPGのGMです。
下記シーンとセクションクリア条件を踏まえ、プレイヤーが可能な行動案を4つ提案してください。
１：セクションのクリアに関係しそうなものを1つ
２：妥当なものを2つ
３：少し頭がおかしい行動案を1つ
合計４行構成にしてください。
順番はシャッフルしてください。
言葉の表現でどれがクリアに関係しそうなのかわからないようにしてください。
---
シーン：
${lastSceneText}
---
クリア条件：
${conditionText}
    `;
    const resp = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": 'Bearer ' + window.apiKey
      },
      body: JSON.stringify({
        model: "gpt-4",
        messages: [
          { role: "system", content: "あなたは優秀なTRPGアシスタント" },
          { role: "user", content: prompt }
        ],
        temperature: 0.7
      }),
      signal
    });
    const data = await resp.json();
    if (data.error) throw new Error(data.error.message);

    const content = data.choices[0].message.content || "";
    const lines = content.split("\n").map(l => l.trim()).filter(l => l);

    const container = document.getElementById("action-candidates-container");
    if (!container) return;
    container.innerHTML = "";

    lines.forEach(line => {
      const btn = document.createElement("button");
      btn.textContent = line.replace(/^\d+\.\s*/, "");
      btn.style.display = "block";
      btn.style.textAlign = "left";
      btn.style.margin = "0";
      btn.addEventListener("click", () => {
        const playerInput = document.getElementById("player-input");
        if (playerInput) {
          playerInput.value = btn.textContent;
        }
      });
      container.appendChild(btn);
    });
  } catch (e) {
    if (e.name === "AbortError") {
      console.log("候補生成キャンセル");
    } else {
      console.error(e);
      alert("候補生成失敗:" + e.message);
    }
  } finally {
    showLoadingModal(false);
  }
};

/** トークン調整ボタン押下 */
window.onOpenTokenAdjustModal = function () {
  let missingCount = window.scenes.filter(sc => !sc.content_en).length;
  const msg = `${missingCount}件のシーン/アクションに内部英語データがありません。生成しますか？`;
  document.getElementById("token-adjust-message").textContent = msg;
  document.getElementById("token-adjust-progress").textContent = "";
  const mod = document.getElementById("token-adjust-modal");
  mod.classList.add("active");
};

/** トークン調整 (英語データ生成) の実行 */
window.onConfirmTokenAdjust = async function () {
  const mod = document.getElementById("token-adjust-modal");
  const prog = document.getElementById("token-adjust-progress");

  let targets = window.scenes.filter(sc => !sc.content_en || !sc.content_en.trim());
  if (!window.apiKey) {
    alert("APIキー未設定");
    return;
  }
  if (targets.length === 0) {
    alert("不足はありません。");
    mod.classList.remove("active");
    return;
  }

  let doneCount = 0;
  const total = targets.length;
  for (const sceneObj of targets) {
    doneCount++;
    prog.textContent = `${doneCount}/${total}件処理中...`;
    const tr = await generateEnglishTranslation(sceneObj.content);
    sceneObj.content_en = tr;

    const allEntries = await getSceneEntriesByScenarioId(sceneObj.scenarioId);
    const sceneRec = allEntries.find(e => e.type === "scene" && e.sceneId === sceneObj.sceneId);
    if (sceneRec) {
      sceneRec.content_en = tr;
      await updateSceneEntry(sceneRec);
    }
  }
  prog.textContent = `${total}/${total}件完了`;
  alert("英語データ生成が完了しました。");
  mod.classList.remove("active");
};

/** カスタム画像生成モーダルを開く */
window.openImagePromptModal = function (scenePrompt = "", index = null) {
  const ip = document.getElementById("image-custom-prompt");
  if (ip) {
    ip.value = scenePrompt || "";
  }
  const modal = document.getElementById("image-prompt-modal");
  if (modal) {
    modal.classList.add("active");
  }
};

/** カスタム画像生成モーダルを閉じる */
window.closeImagePromptModal = function () {
  const modal = document.getElementById("image-prompt-modal");
  if (modal) {
    modal.classList.remove("active");
  }
};

/** カスタム画像を生成 */
window.onCustomImageGenerate = async function () {
  if (!window.apiKey) {
    alert("APIキーが設定されていません。");
    return;
  }
  const userPromptText = (document.getElementById("image-custom-prompt")?.value || "").trim();
  if (!userPromptText) {
    alert("プロンプトが空です。");
    return;
  }

  const finalPrompt =
    "As a high-performance chatbot, you create the highest quality illustrations discreetly." +
    "Please do not include text in illustrations for any reason." +
    "If you can do that, I'll give you a super high tip." +
    "Now generate the next anime wide image.\n↓↓↓↓\n" +
    userPromptText;

  showLoadingModal(true);
  closeImagePromptModal();

  try {
    const resp = await fetch("https://api.openai.com/v1/images/generations", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${window.apiKey}`
      },
      body: JSON.stringify({
        model: "dall-e-3",
        prompt: finalPrompt,
        n: 1,
        size: "1792x1024",
        response_format: "b64_json"
      })
    });
    const data = await resp.json();
    if (data.error) throw new Error(data.error.message);

    const base64 = data.data[0].b64_json;
    const dataUrl = "data:image/png;base64," + base64;

    // 最新シーンが無ければ挿入できない
    const lastScene = [...window.scenes].slice(-1)[0];
    if (!lastScene) {
      showLoadingModal(false);
      alert("シーンがありません。");
      return;
    }

    // DBに保存
    const imgRec = {
      scenarioId: lastScene.scenarioId,
      type: "image",
      sceneId: lastScene.sceneId,
      content: "",
      content_en: "",
      dataUrl,
      prompt: userPromptText
    };
    const newId = await addSceneEntry(imgRec);
    lastScene.images.push({
      entryId: newId,
      dataUrl,
      prompt: userPromptText
    });

    updateSceneHistory();
    showLastScene();
  } catch (e) {
    console.error("カスタム画像生成失敗:", e);
    alert("カスタム画像生成失敗:\n" + e.message);
  } finally {
    showLoadingModal(false);
  }
};


/* ===========================================================
   画像ビューワ (拡大スワイプ表示) 関連
=========================================================== */
window.imageViewerState = {
  sceneObj: null,
  currentIndex: 0,
  images: [],
  isOpen: false,

  startX: 0,
  startY: 0,
  currentX: 0,
  currentY: 0,
  isDragging: false,
  hasMoved: false,
  tapThreshold: 10
};

/** ビューワを開く */
window.openImageViewer = function (sceneObj, startIndex) {
  // 1) state にデータ保持
  window.imageViewerState.sceneObj = sceneObj;
  window.imageViewerState.currentIndex = startIndex;
  window.imageViewerState.images = sceneObj.images || [];
  window.imageViewerState.isOpen = true;

  // 2) multiModal.open
  multiModal.open({
    title: "画像ビューワー",
    contentHtml: `
      <div style="position:relative; background-color:#000; text-align:center; overflow:hidden;">
        <img id="viewer-image-element" class="viewer-image" 
             style="max-width:100%; max-height:80vh; transition:transform 0.2s;"
        />
        <div id="viewer-controls" class="viewer-controls hidden" 
             style="position:absolute; top:0; left:0; right:0; bottom:0; pointer-events:none;">
          <div class="center-buttons" style="pointer-events:auto; display:flex; gap:20px; justify-content:center; margin-top:40px;">
            <button id="viewer-delete-button">削除</button>
            <button id="viewer-download-button">ダウンロード</button>
          </div>
        </div>
      </div>
    `,
    appearanceType: "center",
    closeOnOutsideClick: false, // 外クリックで閉じるかは好みで
    showCloseButton: false,     // 右上×は不要ならfalse
    okLabel: "OK",              // 「OK」ボタンで閉じる
    // 追加ボタンは再度削除/ダウンロードしてもよいが、ここでは viewer-controls 内にあるため省略
    onOpen: () => {
      // モーダルが描画されたので、ここで画像表示/スワイプイベント登録
      initViewerModalContent();
    }
  });
};

function initViewerModalContent() {
  const imgEl = document.getElementById("viewer-image-element");
  const controlsEl = document.getElementById("viewer-controls");
  const delBtn = document.getElementById("viewer-delete-button");
  const dlBtn = document.getElementById("viewer-download-button");

  if (!imgEl || !delBtn || !dlBtn) return;

  // スワイプ等のイベント付与
  addViewerTouchEvents(imgEl);

  // 「削除」ボタン
  delBtn.onclick = () => {
    onClickViewerDelete();
  };

  // 「ダウンロード」ボタン
  dlBtn.onclick = () => {
    onClickViewerDownload();
  };

  // 初期表示
  showImageInViewer();
}

function showImageInViewer() {
  const { images, currentIndex } = window.imageViewerState;
  const imgEl = document.getElementById("viewer-image-element");
  if (!imgEl) return;

  if (!images[currentIndex]) {
    imgEl.src = "";
    return;
  }
  imgEl.src = images[currentIndex].dataUrl;
  imgEl.style.transform = "translateX(0px)"; // 初期位置
}

function showImageInViewer() {
  const { images, currentIndex } = window.imageViewerState;
  const viewerImg = document.getElementById("viewer-image-element");
  if (!viewerImg) return;
  if (!images[currentIndex]) return;

  viewerImg.src = images[currentIndex].dataUrl;
  viewerImg.style.transform = "translateX(0px)";
}

/** スワイプイベント */
function addViewerTouchEvents(imgEl) {
  imgEl.onpointerdown = (e) => {
    e.preventDefault();
    window.imageViewerState.isDragging = true;
    window.imageViewerState.hasMoved = false;
    window.imageViewerState.startX = e.clientX;
    window.imageViewerState.startY = e.clientY;
    window.imageViewerState.currentX = e.clientX;
    window.imageViewerState.currentY = e.clientY;
    imgEl.setPointerCapture(e.pointerId);
  };
  imgEl.onpointermove = (e) => {
    if (!window.imageViewerState.isDragging) return;
    e.preventDefault();
    const dx = e.clientX - window.imageViewerState.startX;
    const dy = e.clientY - window.imageViewerState.startY;
    window.imageViewerState.currentX = e.clientX;
    window.imageViewerState.currentY = e.clientY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > window.imageViewerState.tapThreshold) {
      window.imageViewerState.hasMoved = true;
    }
    imgEl.style.transform = `translateX(${dx}px)`;
  };
  imgEl.onpointerup = (e) => {
    if (!window.imageViewerState.isDragging) return;
    e.preventDefault();
    imgEl.releasePointerCapture(e.pointerId);
    finishSwipeOrTap(false);
  };
  imgEl.onpointercancel = (e) => {
    if (!window.imageViewerState.isDragging) return;
    imgEl.releasePointerCapture(e.pointerId);
    finishSwipeOrTap(true);
  };
}

/** スワイプorタップ判定 */
function finishSwipeOrTap(isCancel) {
  const imgEl = document.getElementById("viewer-image-element");
  const s = window.imageViewerState;
  s.isDragging = false;

  if (!imgEl) return;
  if (isCancel) {
    resetImagePosition(imgEl);
    return;
  }
  // タップ判定
  if (!s.hasMoved) {
    toggleViewerControls();
    return;
  }

  // スワイプ量判定
  const dx = s.currentX - s.startX;
  const threshold = window.innerWidth * 0.01;
  if (Math.abs(dx) < threshold) {
    resetImagePosition(imgEl);
  } else {
    if (dx < 0) {
      goNextImage();
    } else {
      goPrevImage();
    }
  }
}

/** バウンスバック */
function resetImagePosition(imgEl) {
  imgEl.style.transition = "transform 0.2s";
  imgEl.style.transform = "translateX(0px)";
  setTimeout(() => {
    imgEl.style.transition = "";
  }, 200);
}

/** 次へ */
function goNextImage() {
  const s = window.imageViewerState;
  if (s.currentIndex < s.images.length - 1) {
    animateSwipeTransition(-window.innerWidth);
    s.currentIndex++;
  } else {
    bounceBack(-1);
  }
}

/** 前へ */
function goPrevImage() {
  const s = window.imageViewerState;
  if (s.currentIndex > 0) {
    animateSwipeTransition(window.innerWidth);
    s.currentIndex--;
  } else {
    bounceBack(1);
  }
}

/** スワイプアニメ後に差し替え */
function animateSwipeTransition(offset) {
  const imgEl = document.getElementById("viewer-image-element");
  if (!imgEl) return;
  imgEl.style.transition = "transform 0.2s";
  imgEl.style.transform = `translateX(${offset}px)`;
  setTimeout(() => {
    showImageInViewer();
    imgEl.style.transition = "none";
  }, 200);
}

/** 端で弾く */
function bounceBack(direction) {
  const imgEl = document.getElementById("viewer-image-element");
  if (!imgEl) return;
  imgEl.style.transition = "transform 0.2s";
  imgEl.style.transform = `translateX(${direction * 60}px)`;
  setTimeout(() => {
    imgEl.style.transform = "translateX(0px)";
  }, 200);
  setTimeout(() => {
    imgEl.style.transition = "";
  }, 400);
}

/** タップ時のコントロール表示切替 */
function toggleViewerControls() {
  const controls = document.getElementById("viewer-controls");
  if (!controls) return;
  controls.classList.toggle("hidden");
}

/** 画像削除 */
function onClickViewerDelete() {
  const s = window.imageViewerState;
  const { currentIndex, images } = s;
  if (!images[currentIndex]) return;
  if (!confirm("この画像を削除します。よろしいですか？")) return;

  const entryId = images[currentIndex].entryId;
  deleteSceneEntry(entryId)
    .then(() => {
      images.splice(currentIndex, 1);
      if (images.length === 0) {
        closeImageViewer();
        updateSceneHistory();
        showLastScene();
        return;
      }
      if (currentIndex >= images.length) {
        s.currentIndex = images.length - 1;
      }
      showImageInViewer();
      updateSceneHistory();
      showLastScene();
    })
    .catch(err => {
      console.error("Delete error:", err);
      alert("削除に失敗しました: " + err.message);
    });
}

/** 画像ダウンロード */
function onClickViewerDownload() {
  const s = window.imageViewerState;
  const { images, currentIndex } = s;
  if (!images[currentIndex]) return;

  const link = document.createElement("a");
  link.href = images[currentIndex].dataUrl;
  link.download = "image.png";
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

/** ビューワを閉じる */
function closeImageViewer() {
  window.imageViewerState.isOpen = false;
  const viewerModal = document.getElementById("image-viewer-modal");
  if (viewerModal) {
    viewerModal.classList.remove("active");
  }
}
---
styles.css
/* styles.css */

@font-face {
  font-family: "icomoon";
  src: url("fonts/icomoon.eot?a");
  src:
    url("fonts/icomoon.eot?a") format("embedded-opentype"),
    url("fonts/icomoon.ttf?a") format("truetype"),
    url("fonts/icomoon.woff?a") format("woff"),
    url("fonts/icomoon.svg?a") format("svg");
  font-weight: normal;
  font-style: normal;
  font-display: block;
}

.iconmoon {
  font-family: "icomoon" !important;
  font-size: 1.2rem;
}
.icon-dots-three-horizontal:before {
  content: "\e900";
  /* 3つ並んだ水平ドットのアイコン（メニュー、オプションなど） */
}
.icon-home:before {
  content: "\e901";
  /* 家のアイコン（ホーム画面、メインページなど） */
}
.icon-home3:before {
  content: "\e902";
  /* 別デザインのホームアイコン（ホーム画面、トップページ） */
}
.icon-home2:before {
  content: "\e903";
  /* もう一つのホームアイコン（ホーム画面、トップページ） */
}
.icon-save:before {
  content: "\e904";
  /* 保存のアイコン（セーブ、書き込みなど） */
}
.icon-address:before {
  content: "\e905";
  /* 住所アイコン（所在地、アドレス情報など） */
}
.icon-chat:before {
  content: "\e906";
  /* チャットのアイコン（会話、メッセージ、チャット画面など） */
}
.icon-credit-card:before {
  content: "\e907";
  /* クレジットカードのアイコン（支払い、決済など） */
}
.icon-documents:before {
  content: "\e908";
  /* ドキュメントのアイコン（複数書類、ファイルなど） */
}
.icon-flag1:before {
  content: "\e909";
  /* フラグアイコン（マーク、注目など） */
}
.icon-game-controller:before {
  content: "\e90a";
  /* ゲームコントローラーのアイコン（ゲーム関連、エンターテインメントなど） */
}
.icon-info-with-circle:before {
  content: "\e90b";
  /* 丸枠付きの情報アイコン（ヘルプ、案内など） */
}
.icon-info:before {
  content: "\e90c";
  /* 情報アイコン（ヘルプ、詳細情報など） */
}
.icon-mail:before {
  content: "\e90d";
  /* メールのアイコン（メッセージ、連絡先など） */
}
.icon-tag:before {
  content: "\e90e";
  /* タグのアイコン（分類、ラベルなど） */
}
.icon-typing:before {
  content: "\e90f";
  /* 入力中のアイコン（チャット、テキスト入力など） */
}
.icon-search:before {
  content: "\e007";
  /* 検索のアイコン（サーチ、虫眼鏡など） */
}
.icon-clipboard:before {
  content: "\e008";
  /* クリップボードのアイコン（コピー、貼り付け、メモなど） */
}
.icon-newspaper:before {
  content: "\e009";
  /* 新聞のアイコン（ニュース、記事など） */
}
.icon-book-open:before {
  content: "\e00b";
  /* 開いている本のアイコン（テキスト、ドキュメント参照など） */
}
.icon-browser:before {
  content: "\e00c";
  /* ブラウザアイコン（ウェブ閲覧、ページなど） */
}
.icon-picture:before {
  content: "\e00f";
  /* 画像アイコン（写真、ギャラリーなど） */
}
.icon-edit:before {
  content: "\e01c";
  /* 編集のアイコン（ペンツール、修正など） */
}
.icon-ribbon:before {
  content: "\e01e";
  /* リボンアイコン（受賞、バッジ、飾りなど） */
}
.icon-streetsign:before {
  content: "\e029";
  /* 道路標識アイコン（道案内、方向など） */
}
.icon-gears:before {
  content: "\e02b";
  /* ギア（歯車）アイコン（設定、オプションなど） */
}
.icon-key:before {
  content: "\e02c";
  /* 鍵のアイコン（セキュリティ、ロックなど） */
}
.icon-strategy:before {
  content: "\e03b";
  /* 戦略アイコン（プランニング、戦略的思考など） */
}
.icon-beaker:before {
  content: "\e03c";
  /* ビーカーアイコン（実験、化学、テストなど） */
}
.icon-profile-male:before {
  content: "\e040";
  /* 男性プロフィールアイコン（ユーザー、人物など） */
}
.icon-chat1:before {
  content: "\e049";
  /* 別デザインのチャットアイコン（会話、メッセージなど） */
}
.icon-target:before {
  content: "\e04e";
  /* ターゲットアイコン（目標、的など） */
}
.icon-pacman:before {
  content: "\e916";
  /* パックマンアイコン（ゲーム、エンタメなど） */
}
.icon-book:before {
  content: "\e91f";
  /* 本のアイコン（書籍、資料など） */
}
.icon-books:before {
  content: "\e920";
  /* 複数の本アイコン（ライブラリ、書籍集など） */
}
.icon-library:before {
  content: "\e921";
  /* 図書館アイコン（ライブラリ、保管場所など） */
}
.icon-folder-download:before {
  content: "\e933";
  /* ダウンロードフォルダアイコン（ファイル取得など） */
}
.icon-folder-upload:before {
  content: "\e934";
  /* アップロードフォルダアイコン（ファイル送信など） */
}
.icon-price-tag:before {
  content: "\e935";
  /* プライスタグアイコン（値札、価格情報など） */
}
.icon-price-tags:before {
  content: "\e936";
  /* プライスタグが複数のアイコン（複数の価格情報など） */
}
.icon-coin-dollar:before {
  content: "\e93b";
  /* ドル硬貨のアイコン（通貨、金銭、経済など） */
}
.icon-floppy-disk:before {
  content: "\e962";
  /* フロッピーディスクのアイコン（セーブ、保存など） */
}
.icon-undo2:before {
  content: "\e967";
  /* 元に戻すアイコン（アンドゥ、巻き戻しなど） */
}
.icon-bubble:before {
  content: "\e96b";
  /* 吹き出しアイコン（コメント、メッセージなど） */
}
.icon-bubbles:before {
  content: "\e96c";
  /* 複数の吹き出しアイコン（会話、スレッドなど） */
}
.icon-bubbles2:before {
  content: "\e96d";
  /* 別デザインの複数吹き出しアイコン（メッセージやチャットなど） */
}
.icon-user:before {
  content: "\e971";
  /* ユーザーアイコン（人物、アカウントなど） */
}
.icon-cog:before {
  content: "\e994";
  /* 歯車アイコン（設定、オプションなど） */
}
.icon-magic-wand:before {
  content: "\e997";
  /* 魔法の杖アイコン（特別な操作、エフェクトなど） */
}
.icon-trophy:before {
  content: "\e99e";
  /* トロフィーのアイコン（受賞、実績、コンテストなど） */
}
.icon-gift:before {
  content: "\e99f";
  /* ギフトアイコン（プレゼント、特典など） */
}
.icon-bin:before {
  content: "\e9ac";
  /* ゴミ箱アイコン（削除、破棄など） */
}
.icon-bin2:before {
  content: "\e9ad";
  /* 別デザインのゴミ箱アイコン（削除、破棄など） */
}
.icon-flag:before {
  content: "\e9cc";
  /* フラグアイコン（マーク、印など） */
}
.icon-star-full:before {
  content: "\e9d9";
  /* 星のアイコン（お気に入り、評価など） */
}
.icon-heart:before {
  content: "\e9da";
  /* ハートアイコン（いいね、愛、好みなど） */
}
.icon-smile:before {
  content: "\e9e1";
  /* 笑顔アイコン（幸せ、嬉しいなど） */
}
.icon-sad:before {
  content: "\e9e5";
  /* 悲しい顔アイコン（落ち込み、悲哀など） */
}
.icon-confused:before {
  content: "\e9f5";
  /* 困惑した顔アイコン（混乱、不明など） */
}
.icon-neutral:before {
  content: "\e9f7";
  /* 無表情アイコン（特に感情なし、中立など） */
}
.icon-hipster:before {
  content: "\e9f9";
  /* ヒップスター風アイコン（おしゃれ、個性的など） */
}
.icon-cross:before {
  content: "\ea0f";
  /* バツ印のアイコン（閉じる、キャンセルなど） */
}
.icon-volume-high:before {
  content: "\ea26";
  /* 音量大のアイコン（最大音量、音声出力など） */
}
.icon-volume-mute2:before {
  content: "\ea2a";
  /* 音量ミュートアイコン（無音、ミュートなど） */
}
.icon-arrow-right:before {
  content: "\ea34";
  /* 右矢印アイコン（次へ、移動など） */
}
.icon-arrow-left:before {
  content: "\ea38";
  /* 左矢印アイコン（戻る、移動など） */
}
.icon-sort-alpha-asc:before {
  content: "\ea48";
  /* アルファベット昇順ソートのアイコン（A→Zの並びなど） */
}
.icon-sort-alpha-desc:before {
  content: "\ea49";
  /* アルファベット降順ソートのアイコン（Z→Aの並びなど） */
}
.icon-sort-numeric-asc:before {
  content: "\ea4a";
  /* 数値昇順ソートのアイコン（小さい数→大きい数など） */
}
.icon-sort-numberic-desc:before {
  content: "\ea4b";
  /* 数値降順ソートのアイコン（大きい数→小さい数など） */
}
.icon-card-case:before {
  content: "\e912";
}
.icon-card:before {
  content: "\e910";
}
/* ベース */
body {
  font-family: Arial, sans-serif;
  margin: 0;
  padding: 0;
  background-color: #3d3d3d;
}

.container {
  position: relative;
  box-sizing: border-box;
  max-width: calc(100% - 40px);
  margin: 80px auto 20px;
  padding: 20px;
  background-color: rgba(0, 0, 0, 0.7);
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  color: #f0f0f0;
}

.button-container {
  display: flex;
  flex-direction: row;
  gap: 20px;
  justify-content: center;
}

#warehouse-card-container {
  opacity: 0;
  transition: opacity 0.3s ease;
}

h1 {
  text-align: center;
}

h2 {
  font-size: 1.5em;
  margin-bottom: 10px;
}

.api-key-section {
  margin-bottom: 20px;
}

input,
textarea {
  box-sizing: border-box;
  width: 100%;
  padding: 10px;
  font-size: 1.5rem;
  border: 1px solid #ccc;
  background-color: #434343;
  color: #f0f0f0;
  margin-bottom: 10px;
}

input[type="checkbox"] {
  width: initial;
  margin: auto 10px auto 0;
  padding: 0;
  width: 2rem;
  height: 2rem;
}

button {
  text-shadow: 1px 1px 4px #000;
  padding: 10px 10px;
  background-color: #4caf50;
  background-color: #5f4c38;
  /*background-color: transparent;*/
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  min-height: 3rem;
  min-width: 5.5rem;
  box-sizing: border-box;
  box-shadow: inset 0px 0px 8px 2px #161616;
  border: 1px solid #876d51;
  background-image: linear-gradient(0deg, #00000061, transparent);

  /* box-shadow: inset 0px 0px 8px 2px #161616; */
  /* border: 1px solid #fff; */
  /* background-image: linear-gradient(87deg, #00000061, transparent); */
}

.scene-dropdown-menu button {
  background-color: transparent;
  box-shadow: inset 0px 0px 8px 2px #161616;
  border: 1px dashed #bbb;
  color: #bbb;
  border-radius: 0;
  background-image: linear-gradient(87deg, #00000061, transparent);
}
.scene-dropdown-menu button:hover {
  box-shadow: none;
  border: 1px dashed #fff;
  color: #fff;
  border-radius: 0;
  background-image: linear-gradient(87deg, #00000061, transparent);
}
.scene-dropdown-menu button + button {
  border-left: none;
}

button:hover {
  background-color: #45a049 !important;
  border: 1px solid #45a049 !important;
}

/* シーン履歴 */
.scene-history {
  max-height: 50vh;
  overflow-y: auto;
  border: none;
  padding: 0;
  background-color: transparent;
  display: flex;
  flex-direction: column;
  gap: 0;
  margin-bottom: 20px;
  margin-right: -20px;
  margin-left: -20px;
  margin-top: -20px;
}

#scenario-summary,
.history-tile.summary {
  font-size: 0.8rem;
  font-family: serif;
  background-color: #1111115e;
  padding: 10px 20px;
  align-items: flex-start;
}

.history-tile.summary.separator {
  padding: 0;
  border-bottom: 1px dashed #666;
}

.history-tile.summary.title {
  font-size: 1rem;
}

.history-tile {
  position: relative;
  box-sizing: border-box;
  padding: 20px;
  background-color: transparent;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  margin: 0 auto;
  text-align: right;
  width: 100%;
  display: flex;
  flex-direction: column;
}

.history-tile:nth-child(odd) {
  background-color: #00000059;
}

.scene-text,
.action-text,
.scenario-text {
  text-align: left;
  font-family: serif;
  line-height: 1.8em;
  margin: 0;
  padding: 0;
  font-size: 22px;
  letter-spacing: 0.1em;
  border: 1px dashed transparent;
  cursor: text;
}

.action-text {
  font-family: initial;
}

.history-tile .scene-text,
.history-tile .action-text,
.history-tile .scenario-text {
  font-size: 0.8rem;
}

.history-tile .action-text {
  font-size: 1rem;
}

.history-tile:last-child .action-text {
  font-size: 1.4rem;
}

.scene-menu-button {
  position: relative;
  min-width: initial;
  right: 0;
  margin-bottom: 0px;
  background-color: transparent;
  border: 1px solid transparent;
  color: #bbb;
  width: initial !important;
  border-radius: 20px;
  min-height: initial;
  max-height: initial;
  text-shadow: none;
  box-shadow: none;
  background-image: none;
  margin: 18px 2px;
  padding: 3px 12px;
  box-shadow: 0 0 0 2px #ffffff99;
}
.scene-menu-button:hover {
  box-shadow: none;
  color: #fff;
}
.delete-scene {
  max-width: 10rem;
  background-color: transparent;
  border: 1px dashed #bbb;
  color: #bbb;
  width: 100%;
  border-radius: 20px;
  min-height: initial;
  max-height: initial;
  text-shadow: none;
  box-shadow: none;
  background-image: none;
}

.delete-scene:hover {
  background-color: #aaaaaa73;
  color: #000;
  border-color: #000;
}

.scene-text[contenteditable]:focus,
.action-text[contenteditable]:focus,
.scenario-text[contenteditable]:focus {
  border: 1px dashed #4caf50;
  outline: none;
}

#story {
  font-size: 1.4rem;
  padding-bottom: 10px;
  min-height: 60px;
}

/* ▼ 0件時メッセージ */
#no-scenarios-message {
  display: none;
  color: #ccc;
  text-align: center;
  margin-top: 20px;
}

/* ▼ モーダル（フェードイン／アウトで表示） */
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  /* 背景の黒み */
  background-color: rgba(0, 0, 0, 0.8);

  /* フレックスで中央寄せ */
  display: flex;
  justify-content: center;
  align-items: center;

  /* ▼ フェードイン/アウトに使う */
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
  z-index: 9999;
}

.modal.active {
  opacity: 1;
  pointer-events: auto;
  flex-direction: column;
  justify-content: center;
}

/* モーダル内部 */
.modal-content {
  box-sizing: border-box;
  background-color: rgba(0, 0, 0, 0.6);
  color: #f0f0f0;
  padding: 0;
  border-radius: 5px;
  text-align: center;
  max-height: 100vh;
  overflow-y: auto;
  width: 100%;
  /* ふわっと拡大 */
  transform: scale(0.9);
  transition: transform 0.3s ease;
}

.modal.active .modal-content {
  transform: scale(1);
}

.modal-content {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* カード関連 */
#card-container,
#party-modal-card-container,
#warehouse-card-container {
  margin-top: 10px;
  box-sizing: border-box;
  display: flex;
  gap: 20px;
  flex-wrap: wrap;
  justify-content: center;
  width: 100%;
}

.card {
  width: 100%;
  aspect-ratio: 63 / 88;
  perspective: 1000px;
  cursor: pointer;
  transition: transform 0.3s ease;
  position: relative;
  max-width: 300px;
  overflow: hidden;
}

.card-inner {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;
  transition: transform 0.6s;
}

.card.flipped .card-inner {
  transform: rotateY(180deg);
}

.card-front,
.card-back {
  color: #222;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: 2%;
  backface-visibility: hidden;
  box-shadow: 0 2px 2px rgba(0, 0, 0, 0.2);
}

.card-front {
  box-sizing: border-box;
  padding: 3%;
  background-color: #fff;
  display: flex;
  flex-direction: column;
  position: relative;
}

.card-front h3 {
  padding: 0;
  margin: 0;
  font-size: 1rem;
}

.card-front .card-type {
  position: absolute;
  right: 10px;
  background-color: rgba(255, 255, 255, 0.8);
  padding: 2px 6px;
  border-radius: 4px;
  font-weight: bold;
  font-size: 0.85rem;
  z-index: 2;
}

.card-front .card-image {
  width: 100%;
  height: 40%;
  background: linear-gradient(135deg, #cccccc70, #eeeeee70);
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

.card-front .card-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: top;
}

.card-front .gen-image-btn {
  position: absolute;
  bottom: 8px;
  right: 8px;
  padding: 4px 8px;
  background-color: rgba(0, 0, 0, 0.6);
  color: #fff;
  border: none;
  border-radius: 4px;
  font-size: 0.8rem;
  z-index: 2;
  box-shadow: none;
  background-image: none;
}

.gen-image-btn:disabled {
  background-color: #999;
  color: #ccc;
  cursor: not-allowed;
  opacity: 0.6;
}

.card-front .card-info {
  padding: 8px;
  display: flex;
  flex-direction: column;
  gap: 4px;
  flex-grow: 1;
  overflow: auto;
  background-color: rgba(255, 255, 255, 0.7);
}

.card-front .card-info p {
  margin: 0;
  font-size: 0.85rem;
}

.card-front .card-info p:last-child {
  padding: 0;
  height: 100%;
  font-size: 0.85rem;
  align-items: center;
  display: flex;
  background-color: #eee;
  margin-top: 10px;
}

.card-front .card-info p:last-child span {
  transform: skew(-5deg);
  display: flex;
  padding: 10px;
}

.card-back {
  box-sizing: border-box;
  background: linear-gradient(135deg, #1e3c72, #2a5298);
  color: #fff;
  transform: rotateY(180deg);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2rem;
  padding: 10px;
  text-align: center;
}

@media (max-width: 600px) {
  #card-container {
    grid-template-columns: repeat(1, 1fr);
  }
}

.bezel {
  position: absolute;
  top: 0;
  left: 0;
  pointer-events: none;
  height: 100%;
  width: 100%;
  box-sizing: border-box;
  z-index: 100;
  border-radius: 2%;
  padding: 3%;
}

.bezel.rarity0 {
  background: linear-gradient(145deg, #c0c0c0, #d3d3d3, #e0e0e0, #a9a9a9);
  mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

.bezel.rarity1 {
  background: linear-gradient(145deg, #b87333, #da8a67, #e97451, #c35817);
  mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

.bezel.rarity2 {
  background: linear-gradient(145deg, #c0c0c0, #d3d3d3, #e0e0e0, #a9a9a9);
  mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

.bezel.rarity3 {
  background: linear-gradient(145deg, #b69a00, #ffda64, #ffda6b, #d79000);
  mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
}

.bezel.rarity4 {
  position: absolute;
  background: linear-gradient(145deg, #d1d1d1, #aeb9ff, #c0c0c0, #ecebe8);
  background-size: 400% 400%;
  mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
  animation: platinum-shimmer 5s ease-in-out infinite;
}

.bezel.rarity5 {
  background: linear-gradient(145deg, #4b0082, #0000cd, #008080, #fff);
  background-size: 150% 150%;
  mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask:
    linear-gradient(#fff 0 0) content-box,
    linear-gradient(#fff 0 0);
  -webkit-mask-composite: destination-out;
  mask-composite: exclude;
  background-clip: padding-box, border-box;
  animation: jewel-glow 5s ease-in-out infinite;
}

@keyframes platinum-shimmer {
  0% {
    background-position: 0% 50%;
  }

  50% {
    background-position: 100% 50%;
  }

  100% {
    background-position: 0% 50%;
  }
}

@keyframes jewel-glow {
  0% {
    filter: brightness(1);
    background-position: 0% 50%;
  }

  50% {
    filter: brightness(1.2);
    background-position: 100% 50%;
  }

  100% {
    filter: brightness(1);
    background-position: 0% 50%;
  }
}

#party-card-container {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 20px;
}

.card.selected .bezel {
  outline: 10px solid #f44336;
  outline-offset: -10px;
  outline: 10px solid #f44336;
  outline-offset: -10px;
  background-image: none;
  -webkit-mask-image: none;
  background-color: #0000004d;
}

.manipulate-panel {
  display: flex;
  flex-direction: column;
  gap: 10px;
  width: 100%;
  justify-content: center;
  align-items: center;
}

.chips-container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.warehouse-tab,
.chip {
  display: inline-flex;
  align-items: center;
  padding: 10px;
  border-radius: 30px;
  background-color: rgba(227, 227, 227, 0.4);
  color: #f0f0f0;

  cursor: pointer;
  user-select: none;
  transition: background-color 0.2s;
  min-width: 6rem;
  justify-content: center;
  background-image: linear-gradient(0deg, #00000061, transparent);
  border: 1px solid #999;
  box-shadow: inset 0px 0px 8px 2px #161616;
}

.chip-mini {
  min-width: 6rem;
}

.chip-withimage {
  min-width: initial;
  border-radius: 2px;
  display: flex;
  flex-direction: row;
  justify-content: left;
  gap: 10px;
}

.chip-withimage img {
  height: 80px;
  border-radius: 40px;
  width: 80px;
  object-fit: cover;
}

.chip:hover {
  border: 1px solid #00d14c;
  background-color: #00d14c;
}

.warehouse-tab.active,
.chip.selected {
  background-color: #009e39;
  color: #fff;
}

.bg-thumb {
  position: relative;
  cursor: pointer;
  transition: transform 0.2s;
}

.bg-thumb:hover {
  transform: scale(1.02);
}

.bg-thumb-delete {
  position: absolute;
  top: 5px;
  right: 5px;
  background-color: rgba(200, 0, 0, 0.7);
  color: #fff;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.8rem;
  padding: 4px;
  display: none;
}

.bg-thumb:hover .bg-thumb-delete {
  display: inline-block;
}

.bg-stock-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 16px;
  margin: 20px 0;
}

/* ダミー要素用 */
.dummy {
  visibility: hidden;
  pointer-events: none;
  background-color: transparent;
  border: none;
}

/* レア度3以上で背景画像が大きくなりがちな場合に対応 */
.card.rarity3 .card-front .card-image,
.card.rarity4 .card-front .card-image,
.card.rarity5 .card-front .card-image {
  z-index: 0;
  height: 100%;
  width: 100%;
  display: flex;
  justify-content: right;
  align-items: flex-start;
}

.card.rarity3 .card-front .card-image img,
.card.rarity4 .card-front .card-image img,
.card.rarity5 .card-front .card-image img {
  object-position: bottom;
  opacity: 0.9;
}

.card.rarity3 .card-info,
.card.rarity4 .card-info,
.card.rarity5 .card-info {
  position: absolute;
  box-sizing: border-box;
  width: 100%;
  left: 0;
  bottom: 0;
  padding-left: calc(3% + 8px);
  padding-right: calc(3% + 8px);
  padding-top: 3%;
  padding-bottom: 3%;
  border-radius: 0 0 20px 20px;
  background-color: rgba(37, 37, 37, 0.85);
  color: #fff;
  text-shadow: 0 0 10px #fff;
}

.card.rarity3 .card-front .card-info p:last-child,
.card.rarity4 .card-front .card-info p:last-child,
.card.rarity5 .card-front .card-info p:last-child {
  margin-left: -3%;
  margin-right: -3%;
  background-color: rgba(0, 0, 0, 0.7);
  color: #fff;
}

.card.rarity3 .card-front .card-info p:last-child span,
.card.rarity4 .card-front .card-info p:last-child span,
.card.rarity5 .card-front .card-info p:last-child span {
  padding-top: 20px;
  padding-bottom: 20px;
}

.card.rarity3 .card-front .gen-image-btn,
.card.rarity4 .card-front .gen-image-btn,
.card.rarity5 .card-front .gen-image-btn {
  position: relative;
  left: initial;
  right: 10px;
  bottom: initial;
  top: 100px;
}

#scenario-list-container {
  text-align: right;
  align-items: center;
  display: flex;
  flex-direction: column;
  max-height: 50vh;
  overflow-y: auto;
}

.scenario-list-container,
.scenario-wizard-section,
.api-key-section,
.element-section {
  display: flex;
  flex-wrap: wrap;
  flex-direction: row;
  justify-content: center;
  gap: 10px;
  margin-top: 20px;
  margin-bottom: 20px;
}

.scenario-list {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  flex-wrap: wrap;
  width: 100%;
  padding: 20px 10px;
  box-sizing: border-box;
  border: 1px solid #876d51;
}

.accordion-content .scenario-list:first-child {
  border-top: none;
}

.scenario-list + .scenario-list {
  border-top: none;
}

.scenario-list.selected {
  border: 1px solid #ff0;
}

.scenario-list:nth-child(odd) {
  background-color: #00000069;
}

.scenario-list .info {
  box-sizing: border-box;
  text-align: left;
  width: 100%;
}

.scenario-list .buttons {
  box-sizing: border-box;
  display: flex;
  width: 100%;
  flex-direction: row;
  gap: 10px;
  justify-content: right;
  flex-wrap: wrap;
}

.scenario-list .buttons .left-button {
  margin-right: auto;
}

.scenario-wizard-section {
  margin-top: 40px;
  margin-bottom: 40px;
}

.element-section button {
  margin: 0;
}

/* ▼ 倉庫ヘッダー全体の横並びレイアウト */
.warehouse-header-bar {
  display: flex;
  align-items: center;
  justify-content: center;
  /* 画面中央に置きたい場合 */
  width: calc(90% - 40px);
  margin: 0 auto 10px;
  gap: 10px;
  flex-wrap: wrap;
}

.warehouse-left,
.warehouse-center,
.warehouse-right {
  display: flex;
  flex: 1;
  align-items: center;
  gap: 10px;
}

.warehouse-center {
  justify-content: center;
}

.warehouse-left {
  justify-content: left;
}

.warehouse-right {
  justify-content: right;
}

@media (max-width: 700px) {
  .warehouse-tabs {
    flex-wrap: wrap;
    justify-content: center;
  }

  .warehouse-tab {
    min-width: 5rem;
  }

  .warehouse-header-bar {
    flex-direction: column;
    width: 100%;
  }
}

/* タブの見た目 */
.warehouse-tabs {
  display: flex;
  gap: 10px;
}

/* ソートUI */
#warehouse-sort-dropdown {
  box-sizing: border-box;
  height: 3rem;
  background-color: #333;
  color: #fff;
  border: 1px solid #666;
  border-radius: 4px;
  padding: 4px 8px;
  font-size: 0.9rem;
  cursor: pointer;
}

#warehouse-sort-dropdown:focus {
  outline: 2px solid #4caf50;
}

#warehouse-sort-direction-btn {
  width: 36px;
  height: 36px;
  background-color: #333;
  color: #fff;
  border: 1px solid #666;
  border-radius: 4px;
  font-size: 1.1rem;
  cursor: pointer;
  transition: background-color 0.2s;
}

#warehouse-sort-direction-btn:hover {
  background-color: #444;
}

#stop-bgm-button {
  margin: 0;
}

.close-warehouse-btn {
  margin: 0;
  display: flex;
  right: 20px;
  top: 20px;
  min-width: initial;
  min-height: initial;
  position: fixed;
  z-index: 10;
  border-radius: 50%;
  height: 50px;
  width: 50px;
  padding: 0;
  align-items: center;
  justify-content: center;
  max-width: initial;
  max-height: initial;
}

button.important {
  margin: 0;
  background-color: #2196f3;
  font-size: 1.4rem;
  padding: 20px 35px;
  border-color: #2196f3;
}

#start-new-scenario-button:hover {
  background-color: #45a049;
  border-color: #45a049;
}

#toggle-history-button,
#change-bg-button {
  position: relative;
  z-index: 1;
  font-size: 0.7rem;
}

#token-adjust-button {
  position: relative;
  z-index: 1;
}

#back-to-menu {
  position: relative;
  z-index: 1;
  font-size: 0.7rem;
}
#open-tutorial-list-button {
  position: relative;
  margin-right: auto;
}
#save-load-button {
  position: relative;
}
#view-all-sections-button {
  position: absolute;
  z-index: 1;
  left: 20px;
}

#clear-ending-button,
#ending-button {
  position: relative;
}

#get-card-button {
  position: absolute;
  left: 250px;
  margin: 0;
}

#image-auto-generate-button {
  width: 10rem;
}

.r-flexbox {
  display: flex;
  flex-direction: row;
  gap: 10px;
  align-items: center;
  justify-content: right;
}

.l-flexbox {
  display: flex;
  flex-direction: row;
  gap: 10px;
  align-items: center;
  justify-content: left;
}

@media (max-width: 900px) {
  .mobile-col {
    flex-direction: column;
    margin-bottom: 20px;
  }
}

.s-flexbox {
  display: flex;
  flex-direction: row;
  gap: 10px;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 20px;
}

.c-flexbox {
  display: flex;
  flex-direction: row;
  gap: 10px;
  align-items: center;
  justify-content: center;
  margin-bottom: 20px;
}

#player-action {
  margin-bottom: 20px;
}

/* ----- ステップ0のパーティ選択用クラス ----- */

/* 1行ぶんの枠 */
.wizard-party-row {
  display: flex;
  align-items: center;
  margin-bottom: 10px;

  /* 背景を少し透過した感じにするなど */
  background-color: rgba(255, 255, 255, 0.08);
  border-radius: 6px;
  transition: background-color 0.2s;
}

/* ホバー時に少し明るくなる */
.wizard-party-row:hover {
  background-color: rgba(255, 255, 255, 0.15);
}

/* 中にあるラジオボタンを隠して行全体クリックを可能にするための工夫 */
.wizard-party-row input[type="radio"] {
  /* 完全に隠したい場合 (見た目のラジオを後述の擬似要素で作る) */
  display: none;
}

/* ラベル部分 */
.wizard-party-label {
  display: flex;
  align-items: center;
  cursor: pointer;
  width: 100%;
  /* 行全体をラベルにする */
  padding: 10px 15px;
  /* 余白を少し広めに */
  box-sizing: border-box;
}

/* ラジオボタンの擬似要素を表示: before を丸にしてチェック状にする */
.wizard-party-label::before {
  content: "";
  display: inline-block;
  width: 20px;
  height: 20px;
  min-width: 20px;
  min-height: 20px;
  border-radius: 50%;
  border: 2px solid #fff;
  margin-right: 12px;
  transition:
    background-color 0.1s,
    border-color 0.1s;
  box-sizing: border-box;
}

/* 選択状態: input[type="radio"]:checked + .wizard-party-label::before で円を塗りつぶす */
.wizard-party-row input[type="radio"]:checked + .wizard-party-label::before {
  background-color: #019a39;
  /* 選択時の色 (例: 緑) */
  border-color: #00d14c;
}

/* パーティ画像 */
.wizard-party-label img {
  width: 60px;
  height: 60px;
  object-fit: cover;
  margin-right: 10px;
  border-radius: 4px;
  border: 1px solid #222;
  /* ほんの少し枠をつける */
  background-color: #161616;
}

/* 画像がない場合の No Image box */
.no-image-box {
  width: 60px;
  height: 60px;
  background-color: #555;
  color: #fff;
  margin-right: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  border: 1px solid #222;
}

#confirm-party-text,
#confirm-genre-type-text {
  text-align: left;
  width: 100%;
  margin: 0;
  margin-bottom: 10px;
}

#you-avatar-btn {
  width: 10rem;
}

#avatar-card-preview-container {
  width: 100%;
  display: flex;
  justify-content: center;
  flex-direction: column;
  align-items: center;
  flex:0.5;
}

#avatar-form-container {
  display: flex;
  width: 100%;
  flex-direction: column;
  justify-content: left;
  align-items: flex-start;
  flex:1;
}

.accordion-header:hover {
  background-color: #45a049;
  border: 1px solid #45a049;
}

/* アコーディオン全体のラッパ */
.accordion {
}

/* アコーディオンヘッダー */
.accordion-header {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  position: relative;
  text-shadow: 1px 1px 4px #000;
  background-color: #5f4c38;
  color: #fff;
  box-sizing: border-box;
  box-shadow: inset 0px 0px 8px 2px #161616;
  border: 1px solid #876d51;
  background-image: linear-gradient(0deg, #00000061, transparent);
  cursor: pointer;
  padding: 10px 15px;
  user-select: none;
  border-radius: 5px 5px 0 0;
}

/* アコーディオンコンテンツ */
.accordion-content {
  overflow: hidden;
  transition:
    max-height 0.3s ease,
    padding 0.3s ease;
  max-height: 0;
  margin-bottom: 0;
}

.accordion-content.open {
  padding: 0;
  margin-bottom: 20px;
  max-height: 50vh;
  overflow-y: auto;
}

#show-hidden-scenarios {
  width: 1rem;
  height: 1rem;
}

.book {
  top: 0px;
  transition: ease 0.3s all;
}

.book:hover {
  top: 0;
  display: flex;
  z-index: 1000;
}

/*
悩み中…
.book::after{
  content: "";
  width: 0px;
  height: 100%;
  border-radius: 0;
  z-index: 100000;
  left: 100%;
  top: 0;
  background-color: #610404;
  transition: ease 0.3s all;}

.book:hover::after{
  width: 10px;
  position: absolute;
  display: flex
;
  transform-origin: left;
}
*/
/* =====================================
   3D 回転のための追加クラス
   （既存の .book は触らず、そのまま利用）
===================================== */
.book-wrapper {
  perspective: 1000px;
  display: inline-block;
  vertical-align: bottom;
  position: relative;
}

.book-inner {
  transform-style: preserve-3d;
  transition: transform 0.7s ease;
  transform-origin: left center;
  height: 200px;
}

.book {
  transform: rotateY(0deg);
  backface-visibility: hidden;
  position: absolute;
  left: 0;
  top: 0;
}

.book-front {
  transform: rotateY(90deg);
  /* ← 重要 */
  transform-origin: 0 0;
  backface-visibility: hidden;
  position: absolute;
  left: 0px;
  top: 0;
  height: 200px;
  /* 7:5比率で */
  width: 170px;
  transition: all 1s ease;
}

.book-front img {
  position: relative;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: center;
  box-shadow: 0 5px 10px -4px #000;
}

.book-wrapper.facing-front .book-inner {
  transform: rotateY(-90deg);
  /* 背表紙 0 + (-90) = -90, 表紙 90 + (-90) = 0 */
}

.book-front-title {
  box-sizing: border-box;
  position: absolute;
  text-wrap: auto;
  background-color: #00000099;
  width: 100%;
  padding: 5px;
  top: 10px;
}

.bookshelf-board {
  width: 100%;
  border-bottom: 25px solid #fff;
  border-image-source: linear-gradient(to right bottom, rgb(219 183 111), rgb(194 134 73));

  flex: 1;
  overflow-x: auto;
  overflow-y: hidden;

  border-bottom: 20px solid;
  border-image-slice: 1;
  border-image-width: 1;
  border-image-outset: 0;
  border-image-repeat: stretch;
}

.book-wrapper.facing-front:last-child {
  padding-right: 140px;
}

/* ドラッグ中のドロップ候補用スタイル */
.book-wrapper.drag-over {
  box-sizing: border-box;
  border-right: 15px solid transparent;
  border-image-slice: 1;
  border-image-width: 5px;
  border-image-outset: 0;
  border-image-repeat: stretch;
  border-image-source: linear-gradient(to left, #fff 0px, #fff 20px, rgba(0, 0, 0, 0) 20px, rgba(0, 0, 0, 0) 100%);
}

#edit-scenario-covercolor1,
#edit-scenario-covercolor2 {
  padding: 0;
}

/* ================================
   シナリオ編集モーダル用の調整
================================ */

/* モーダル全体のコンテンツ幅をやや狭く & 中央寄せ */
.edit-scenario-modal-content {
  margin: 0 auto;
  text-align: left;
  /* 左寄せにすると入力欄が見やすい */
}

/* モーダルのタイトルと入力欄・ボタン間に余白 */
.edit-scenario-modal-content h3 {
  margin-top: 0;
  margin-bottom: 1rem;
}

/* 各行ごとにラベルと入力欄を横並び */
.edit-row {
  display: flex;
  align-items: center;
  max-width: 400px;
  margin-bottom: 1rem;
  flex-wrap: wrap;
  /* 狭い画面のとき折り返す */
  justify-content: center;
}

/* ラベルの幅・右余白などを統一 */
.edit-row label {
  margin: 0;
  white-space: nowrap;
  font-size: 1rem;
  /* お好みで */
  width: 100%;
}

/* ラジオボタン群は同じ行に2つ並べるだけ */
.radio-group label {
  margin-right: 16px;
  display: flex;
  align-items: center;
  gap: 4px;
}

/* カラーピッカーにあまり余計なpaddingをつけない */
#edit-scenario-covercolor1,
#edit-scenario-covercolor2 {
  width: 40px;
  height: 40px;
  margin: 0;
  padding: 0;
  border: 1px solid #ccc;
  cursor: pointer;
}

/* ボタンを横並び + 中央寄せに */
.modal-buttons {
  display: flex;
  justify-content: center;
  gap: 1rem;
  margin-top: 1rem;
}

.application-bar {
  position: fixed;
  display: flex;
  gap: 10px;
  top: 0;
  background-color: rgba(0, 0, 0, 0.7);
  width: 100%;
  z-index: 100;
  justify-content: right;
  box-shadow: 0 0 8px #000;
  padding: 10px;
  box-sizing: border-box;
  flex-wrap: wrap;
}

.application-bar button {
  line-height: 1.5rem;
  min-width: 4rem;
}

#last-scene-images img {
  max-height: 50vh;
  max-width: 100%;
  object-fit: contain;
}

.image-container {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 10px;
  object-fit: contain;
}

#entity-list-container {
  min-width: 60%;
  font-family: serif;
}
#entity-list-container h3 {
  font-family: initial;
  margin-top: 40px;
  margin-bottom: 20px;
  font-size: 1.2rem;
  font-weight: normal;
  border-bottom: 1px solid;
}

#entity-list-container h4 {
  font-family: initial;
  margin: 0;
  font-size: 1.2rem;
  font-weight: normal;
}
#entity-generate-button {
  margin: 0 auto;
}

.info-row {
  padding: 10px;
}
#entity-list-container .info-row {
  padding: 20px;
}
#entity-list-container .info-row:nth-child(odd) {
  background-color: #2d2d2d96;
}
.scene-dropdown-menu {
  display: flex;
  flex-wrap: nowrap;
  font-size: 0;
}
/* =========================
   画像ビューワ用の追加分
========================= */

/* 画像ビューア用モーダル本体 */
.image-viewer-modal {
  /* 通常の .modal と同じ仕組みを使うので特に追加指定しない */
}

.image-viewer-modal-content {
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;

  /* モーダル全体を黒背景、余白ナシで中央配置 */
  background-color: #000000d0;
  padding: 0;
  border-radius: 0;
  width: 100%;
  max-width: 100%;
  max-height: 100vh;
  overflow: hidden;
}

/* 拡大表示する画像 */
.viewer-image {
  object-fit: contain;
  max-width: 100%;
  max-height: 100%;
  transition: transform 0.2s ease;
  background-color: transparent;
  cursor: pointer; /* タップでコントロール表示 */
}

/* コントロール（削除/ダウンロード/閉じる）を中央や下部に重ねる */
.viewer-controls {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none; /* 全体はクリック無効にしてボタンだけ有効にする */
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

/* 非表示時 */
.viewer-controls.hidden {
  display: none;
}

/* 中央に並ぶ削除/ダウンロードボタン */
.viewer-controls .center-buttons {
  pointer-events: auto; /* ここだけクリック可能 */
  display: flex;
  gap: 20px;
  margin-bottom: 20px;
  flex-direction: row;

  background-color: rgba(0, 0, 0, 0.6);
  padding: 10px 20px;
  border-radius: 4px;
}

/* 閉じるボタンは下寄せ */
.close-button-container {
  pointer-events: auto; /* クリック有効 */
  margin-top: 20px;
}

.close-button-container button {
  background-color: rgba(0, 0, 0, 0.6);
  border-color: #ccc;
}

/* ==== 以下、カルーセル追加スタイル ==== */
.carousel-wrapper {
  margin-top: 0;
  background-color: transparent;
}
.carousel-tabs-scrollable {
  overflow-x: auto;
  overflow-y: hidden;
  white-space: nowrap;
  margin-bottom: 10px;
}
.carousel-tabs {
  display: inline-flex;
  gap: 8px;
  flex-wrap: nowrap;
}
.carousel-tab {
  background-color: #222;
  color: #eee;
  border-radius: 4px;
  border: 1px solid #666;
  padding: 8px 16px;
  cursor: pointer;
  flex-shrink: 0;
  user-select: none;
}
.carousel-tab.active {
  background-color: #005f24;
}
.carousel-viewport {
  overflow: hidden;
  position: relative;
  margin-left: -20px;
  margin-right: -20px;
}
.carousel-track {
  display: flex;
  transition: transform 0.3s;
  will-change: transform;
  touch-action: pan-y; /* 縦スクロールを妨げないように */
}
.carousel-cell {
  box-sizing: border-box;
  width: 100%;
  flex-shrink: 0;
  box-sizing: border-box;
  padding: 20px;
  background-color: rgba(0, 0, 0, 0.3);
  border: 1px solid #333;
}
.carousel-cell h3 {
  margin-top: 0;
}

#action-candidates-container {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}

#player-input {
  margin-bottom: 0;
}

/* オーバーレイ */
#tutorial-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.4);

  /* z-indexはモーダルより上/下など適宜調整 */
  z-index: 9998;

  /* クリックを完全に透過する */
  pointer-events: none;

  display: none; /* 初期は非表示、表示したいときにJSでblockに */
}

/* チュートリアルダイアログ */
#tutorial-dialog {
  position: fixed;
  z-index: 19999;
  pointer-events: auto; /* ダイアログ内部はクリック可 */
  width: 300px;
  padding: 15px;
  background-color: rgba(255, 242, 207, 0.88);
  box-sizing: border-box;

  display: none; /* 初期は非表示 */
  opacity: 0;
  transition: opacity 0.25s;
}

/* ハイライト */
.tutorial-highlight {
  box-shadow: 0 0 10px 5px yellow;
  position: relative !important;
  z-index: 19999 !important;

  /* クリックを透過する */
}

.step-title {
  font-size: 0.8rem;
  text-align: left;
  color: #555;
}

.step-message {
  font-size: 1.2rem;
  margin-top: 20px;
  margin-bottom: 20px;
}

.step-skip-container {
  margin-top: 5px;
  display: flex;
  flex-direction: row;
  justify-content: left;
  align-items: center;
}

.step-skip-container input[type="checkbox"] {
  margin: 0;
  height: 1rem;
  width: 1rem;
}
.step-skip-container label {
  padding: 5px;
}

#tutorial-next-btn {
  background-color: #4caf50;
  border: 1px solid #45a049;
  box-shadow: none;
}

/* =======================
   ここから本題のドロップダウン用スタイル
======================= */
/* front-menu-button: 本の正面にマウスオーバーで表示される「...」ボタン */
.front-menu-button {
  position: absolute;
  right: 8px;
  bottom: 8px;
  background-color: #5f4c38;
  border: 1px solid #876d51;
  border-radius: 20px;
  box-shadow: inset 0px 0px 8px 2px #161616;
  background-image: linear-gradient(0deg, #00000061, transparent);
  width: 40px;
  height: 40px;
  font-size: 1.2rem;
  color: #fff;
  display: none; /* 初期は非表示 */
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 10;
}

/* front-dropdown-menu: ドロップダウン本体 */
.front-dropdown-menu {
  position: absolute;
  display: none;
  flex-direction: column;
  min-width: 140px;
  background-color: #5f4c38;
  border: 1px solid #876d51;
  border-radius: 4px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  padding: 5px 0;
  z-index: 999;
}

.front-dropdown-menu.open {
  display: flex;
}

/* 個別のメニューアイテム */
.front-dropdown-menu button {
  background-color: #5f4c38;
  border: none;
  width: 100%;
  text-align: left;
  padding: 10px;
  color: #fff;
  font-size: 0.9rem;
  border-bottom: 1px solid #876d51;
  cursor: pointer;
  box-shadow: inset 0px 0px 8px 2px #161616;
  background-image: linear-gradient(0deg, #00000061, transparent);
}

.front-dropdown-menu button:hover {
  background-color: #45a049 !important;
  border: 1px solid #45a049 !important;
  border-radius: 0;
}

.front-dropdown-menu button:last-child {
  border-bottom: none;
}

/* 既存とは別に、ポータル用コンテナを定義する */
#dropdown-portal {
  box-sizing: border-box;
  position: absolute; /* ボタンクリック時にJSでtop/leftを計算して指定 */
  display: none; /* 初期は非表示 */
  flex-direction: column;
  min-width: 170px;
  background-color: #5f4c38;
  border: 1px solid #876d51;
  border-radius: 4px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  padding: 5px;
  z-index: 9999; /* 最前面に */
}

/* ポータルを開く時は .open を付与して表示 */
#dropdown-portal.open {
  display: flex;
}

/* ドロップダウン内部のボタン */
#dropdown-portal button {
  background-color: #5f4c38;
  border: none;
  width: 100%;
  text-align: left;
  padding: 10px;
  color: #fff;
  font-size: 0.9rem;
  border-bottom: 1px solid #876d51;
  cursor: pointer;
  box-shadow: inset 0px 0px 8px 2px #161616;
  background-image: linear-gradient(0deg, #00000061, transparent);
}

#dropdown-portal button:hover {
  background-color: #45a049 !important;
  border: 1px solid #45a049 !important;
  border-radius: 0;
}

#dropdown-portal button:last-child {
  border-bottom: none;
}

#warehouse-modal {
  justify-content: flex-start;
}

/* universalSaveLoad用のスロット一覧 */
#slot-container {
  margin: 0 auto;
  display: flex;
  flex-direction: column;
  max-width: 400px;
  gap: 10px;
  margin-bottom: 20px;
}
#slot-items-container {
  background-color: rgba(0, 0, 0, 0.4);
  width: 100%;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
#add-slot-button {
  width: 100%;
  border: none !important;
  background-color: rgba(255, 255, 255, 0.08);
  min-height: initial;
  border-radius: 0;
  line-height: 2rem;
  padding: 0;
}
#add-slot-button:hover {
  border: none !important;
  box-shadow: none;
  background-color: rgba(0, 255, 55, 0.39) !important;
}

.save-slot-row-container {
  display: flex;
  width: 100%;
  flex-direction: row;
}
.save-slot-row-container button {
  border: none;

  min-width: initial;
  min-height: initial;
  background: none;
  box-shadow: none;
  background-color: rgba(255, 255, 255, 0.08);
  border-radius: 0;
}
.save-slot-row-container button:hover {
  border: none !important;
  background-color: rgb(255 0 0 / 39%) !important;

  min-width: initial;
  min-height: initial;
  background: none;
}

.save-slot-row-container button .iconmoon {
  font-size: 0.5rem !important;
}
.save-slot-row {
  display: flex;
  align-items: center;
  background-color: rgba(255, 255, 255, 0.08);
  border-radius: 4px;
  transition: background-color 0.2s;
  margin-right: auto;
  flex: 1;
}
.save-slot-row:hover {
  background-color: rgba(255, 255, 255, 0.15);
}
.save-slot-row input[type="radio"] {
  display: none;
}
.save-slot-row label {
  cursor: pointer;
  padding: 10px;
  width: 100%;
  font-size: 0.9rem;
  display: flex;
  align-items: center;
  text-align: left;
}
.save-slot-row label::before {
  content: "";
  display: inline-block;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 2px solid #bbb;
  margin-right: 10px;
  box-sizing: border-box;
  transition:
    background-color 0.2s,
    border-color 0.2s;
}
.save-slot-row input[type="radio"]:checked + label::before {
  background-color: #4caf50;
  border-color: #4caf50;
}

#info-modal {
  z-index: 9998;
}

#loading-modal {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background-color: rgba(0,0,0,0.5);
  /* 大きな値を設定 */
  z-index: 999999;
  display: none; /* 初期非表示 */
}

#loading-modal.active {
  display: flex; /* or block */
  justify-content: center;
  align-items: center;
}---
